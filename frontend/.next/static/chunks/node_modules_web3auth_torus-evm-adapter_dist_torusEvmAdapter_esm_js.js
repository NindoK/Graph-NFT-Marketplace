/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["node_modules_web3auth_torus-evm-adapter_dist_torusEvmAdapter_esm_js"],{

/***/ "./node_modules/@metamask/obs-store/dist/ComposedStore.js":
/*!****************************************************************!*\
  !*** ./node_modules/@metamask/obs-store/dist/ComposedStore.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ComposedStore = void 0;\nconst ObservableStore_1 = __webpack_require__(/*! ./ObservableStore */ \"./node_modules/@metamask/obs-store/dist/ObservableStore.js\");\nclass ComposedStore extends ObservableStore_1.ObservableStore {\n    constructor(children) {\n        // Typecast: Preserve existing behavior\n        super({});\n        // subscribe to children\n        this._children = children || {};\n        Object.keys(this._children).forEach((childKey) => {\n            const child = this._children[childKey];\n            this._addChild(childKey, child);\n        });\n    }\n    _addChild(childKey, child) {\n        const updateFromChild = (childValue) => {\n            const state = this.getState();\n            state[childKey] = childValue;\n            this.putState(state);\n        };\n        child.subscribe(updateFromChild);\n        updateFromChild(child.getState());\n    }\n}\nexports.ComposedStore = ComposedStore;\n//# sourceMappingURL=ComposedStore.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL29icy1zdG9yZS9kaXN0L0NvbXBvc2VkU3RvcmUuanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QscUJBQXFCO0FBQ3JCLDBCQUEwQixtQkFBTyxDQUFDLHFGQUFtQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svb2JzLXN0b3JlL2Rpc3QvQ29tcG9zZWRTdG9yZS5qcz9jNzBjIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Db21wb3NlZFN0b3JlID0gdm9pZCAwO1xuY29uc3QgT2JzZXJ2YWJsZVN0b3JlXzEgPSByZXF1aXJlKFwiLi9PYnNlcnZhYmxlU3RvcmVcIik7XG5jbGFzcyBDb21wb3NlZFN0b3JlIGV4dGVuZHMgT2JzZXJ2YWJsZVN0b3JlXzEuT2JzZXJ2YWJsZVN0b3JlIHtcbiAgICBjb25zdHJ1Y3RvcihjaGlsZHJlbikge1xuICAgICAgICAvLyBUeXBlY2FzdDogUHJlc2VydmUgZXhpc3RpbmcgYmVoYXZpb3JcbiAgICAgICAgc3VwZXIoe30pO1xuICAgICAgICAvLyBzdWJzY3JpYmUgdG8gY2hpbGRyZW5cbiAgICAgICAgdGhpcy5fY2hpbGRyZW4gPSBjaGlsZHJlbiB8fCB7fTtcbiAgICAgICAgT2JqZWN0LmtleXModGhpcy5fY2hpbGRyZW4pLmZvckVhY2goKGNoaWxkS2V5KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjaGlsZCA9IHRoaXMuX2NoaWxkcmVuW2NoaWxkS2V5XTtcbiAgICAgICAgICAgIHRoaXMuX2FkZENoaWxkKGNoaWxkS2V5LCBjaGlsZCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfYWRkQ2hpbGQoY2hpbGRLZXksIGNoaWxkKSB7XG4gICAgICAgIGNvbnN0IHVwZGF0ZUZyb21DaGlsZCA9IChjaGlsZFZhbHVlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBzdGF0ZSA9IHRoaXMuZ2V0U3RhdGUoKTtcbiAgICAgICAgICAgIHN0YXRlW2NoaWxkS2V5XSA9IGNoaWxkVmFsdWU7XG4gICAgICAgICAgICB0aGlzLnB1dFN0YXRlKHN0YXRlKTtcbiAgICAgICAgfTtcbiAgICAgICAgY2hpbGQuc3Vic2NyaWJlKHVwZGF0ZUZyb21DaGlsZCk7XG4gICAgICAgIHVwZGF0ZUZyb21DaGlsZChjaGlsZC5nZXRTdGF0ZSgpKTtcbiAgICB9XG59XG5leHBvcnRzLkNvbXBvc2VkU3RvcmUgPSBDb21wb3NlZFN0b3JlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q29tcG9zZWRTdG9yZS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@metamask/obs-store/dist/ComposedStore.js\n");

/***/ }),

/***/ "./node_modules/@metamask/obs-store/dist/MergedStore.js":
/*!**************************************************************!*\
  !*** ./node_modules/@metamask/obs-store/dist/MergedStore.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.MergedStore = void 0;\nconst ObservableStore_1 = __webpack_require__(/*! ./ObservableStore */ \"./node_modules/@metamask/obs-store/dist/ObservableStore.js\");\nclass MergedStore extends ObservableStore_1.ObservableStore {\n    constructor(children = []) {\n        // Typecast: Preserve existing behavior\n        super({});\n        this._children = children;\n        // subscribe to children\n        children.forEach((child) => this._addChild(child));\n        this._updateWholeState();\n    }\n    _addChild(child) {\n        child.subscribe(() => this._updateWholeState());\n    }\n    _updateWholeState() {\n        const childStates = this._children.map((child) => child.getState());\n        // apply shallow merge over states\n        const state = Object.assign({}, ...childStates);\n        this.putState(state);\n    }\n}\nexports.MergedStore = MergedStore;\n//# sourceMappingURL=MergedStore.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL29icy1zdG9yZS9kaXN0L01lcmdlZFN0b3JlLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG1CQUFtQjtBQUNuQiwwQkFBMEIsbUJBQU8sQ0FBQyxxRkFBbUI7QUFDckQ7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svb2JzLXN0b3JlL2Rpc3QvTWVyZ2VkU3RvcmUuanM/NGY5ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTWVyZ2VkU3RvcmUgPSB2b2lkIDA7XG5jb25zdCBPYnNlcnZhYmxlU3RvcmVfMSA9IHJlcXVpcmUoXCIuL09ic2VydmFibGVTdG9yZVwiKTtcbmNsYXNzIE1lcmdlZFN0b3JlIGV4dGVuZHMgT2JzZXJ2YWJsZVN0b3JlXzEuT2JzZXJ2YWJsZVN0b3JlIHtcbiAgICBjb25zdHJ1Y3RvcihjaGlsZHJlbiA9IFtdKSB7XG4gICAgICAgIC8vIFR5cGVjYXN0OiBQcmVzZXJ2ZSBleGlzdGluZyBiZWhhdmlvclxuICAgICAgICBzdXBlcih7fSk7XG4gICAgICAgIHRoaXMuX2NoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgICAgIC8vIHN1YnNjcmliZSB0byBjaGlsZHJlblxuICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKChjaGlsZCkgPT4gdGhpcy5fYWRkQ2hpbGQoY2hpbGQpKTtcbiAgICAgICAgdGhpcy5fdXBkYXRlV2hvbGVTdGF0ZSgpO1xuICAgIH1cbiAgICBfYWRkQ2hpbGQoY2hpbGQpIHtcbiAgICAgICAgY2hpbGQuc3Vic2NyaWJlKCgpID0+IHRoaXMuX3VwZGF0ZVdob2xlU3RhdGUoKSk7XG4gICAgfVxuICAgIF91cGRhdGVXaG9sZVN0YXRlKCkge1xuICAgICAgICBjb25zdCBjaGlsZFN0YXRlcyA9IHRoaXMuX2NoaWxkcmVuLm1hcCgoY2hpbGQpID0+IGNoaWxkLmdldFN0YXRlKCkpO1xuICAgICAgICAvLyBhcHBseSBzaGFsbG93IG1lcmdlIG92ZXIgc3RhdGVzXG4gICAgICAgIGNvbnN0IHN0YXRlID0gT2JqZWN0LmFzc2lnbih7fSwgLi4uY2hpbGRTdGF0ZXMpO1xuICAgICAgICB0aGlzLnB1dFN0YXRlKHN0YXRlKTtcbiAgICB9XG59XG5leHBvcnRzLk1lcmdlZFN0b3JlID0gTWVyZ2VkU3RvcmU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1NZXJnZWRTdG9yZS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@metamask/obs-store/dist/MergedStore.js\n");

/***/ }),

/***/ "./node_modules/@metamask/obs-store/dist/ObservableStore.js":
/*!******************************************************************!*\
  !*** ./node_modules/@metamask/obs-store/dist/ObservableStore.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ObservableStore = void 0;\nconst safe_event_emitter_1 = __importDefault(__webpack_require__(/*! @metamask/safe-event-emitter */ \"./node_modules/@metamask/safe-event-emitter/index.js\"));\nclass ObservableStore extends safe_event_emitter_1.default {\n    constructor(initState) {\n        super();\n        if (initState) {\n            this._state = initState;\n        }\n        else {\n            // Typecast/default state: Preserve existing behavior\n            this._state = {};\n        }\n    }\n    // wrapper around internal getState\n    getState() {\n        return this._getState();\n    }\n    // wrapper around internal putState\n    putState(newState) {\n        this._putState(newState);\n        this.emit('update', newState);\n    }\n    updateState(partialState) {\n        // if non-null object, merge\n        if (partialState && typeof partialState === 'object') {\n            const state = this.getState();\n            this.putState(Object.assign(Object.assign({}, state), partialState));\n            // if not object, use new value\n        }\n        else {\n            this.putState(partialState);\n        }\n    }\n    // subscribe to changes\n    subscribe(handler) {\n        this.on('update', handler);\n    }\n    // unsubscribe to changes\n    unsubscribe(handler) {\n        this.removeListener('update', handler);\n    }\n    //\n    // private\n    //\n    // read from persistence\n    _getState() {\n        return this._state;\n    }\n    // write to persistence\n    _putState(newState) {\n        this._state = newState;\n    }\n}\nexports.ObservableStore = ObservableStore;\n//# sourceMappingURL=ObservableStore.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL29icy1zdG9yZS9kaXN0L09ic2VydmFibGVTdG9yZS5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHVCQUF1QjtBQUN2Qiw2Q0FBNkMsbUJBQU8sQ0FBQywwRkFBOEI7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9vYnMtc3RvcmUvZGlzdC9PYnNlcnZhYmxlU3RvcmUuanM/ZDcwMSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuT2JzZXJ2YWJsZVN0b3JlID0gdm9pZCAwO1xuY29uc3Qgc2FmZV9ldmVudF9lbWl0dGVyXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIkBtZXRhbWFzay9zYWZlLWV2ZW50LWVtaXR0ZXJcIikpO1xuY2xhc3MgT2JzZXJ2YWJsZVN0b3JlIGV4dGVuZHMgc2FmZV9ldmVudF9lbWl0dGVyXzEuZGVmYXVsdCB7XG4gICAgY29uc3RydWN0b3IoaW5pdFN0YXRlKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIGlmIChpbml0U3RhdGUpIHtcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlID0gaW5pdFN0YXRlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gVHlwZWNhc3QvZGVmYXVsdCBzdGF0ZTogUHJlc2VydmUgZXhpc3RpbmcgYmVoYXZpb3JcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlID0ge307XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gd3JhcHBlciBhcm91bmQgaW50ZXJuYWwgZ2V0U3RhdGVcbiAgICBnZXRTdGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldFN0YXRlKCk7XG4gICAgfVxuICAgIC8vIHdyYXBwZXIgYXJvdW5kIGludGVybmFsIHB1dFN0YXRlXG4gICAgcHV0U3RhdGUobmV3U3RhdGUpIHtcbiAgICAgICAgdGhpcy5fcHV0U3RhdGUobmV3U3RhdGUpO1xuICAgICAgICB0aGlzLmVtaXQoJ3VwZGF0ZScsIG5ld1N0YXRlKTtcbiAgICB9XG4gICAgdXBkYXRlU3RhdGUocGFydGlhbFN0YXRlKSB7XG4gICAgICAgIC8vIGlmIG5vbi1udWxsIG9iamVjdCwgbWVyZ2VcbiAgICAgICAgaWYgKHBhcnRpYWxTdGF0ZSAmJiB0eXBlb2YgcGFydGlhbFN0YXRlID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLmdldFN0YXRlKCk7XG4gICAgICAgICAgICB0aGlzLnB1dFN0YXRlKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUpLCBwYXJ0aWFsU3RhdGUpKTtcbiAgICAgICAgICAgIC8vIGlmIG5vdCBvYmplY3QsIHVzZSBuZXcgdmFsdWVcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucHV0U3RhdGUocGFydGlhbFN0YXRlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBzdWJzY3JpYmUgdG8gY2hhbmdlc1xuICAgIHN1YnNjcmliZShoYW5kbGVyKSB7XG4gICAgICAgIHRoaXMub24oJ3VwZGF0ZScsIGhhbmRsZXIpO1xuICAgIH1cbiAgICAvLyB1bnN1YnNjcmliZSB0byBjaGFuZ2VzXG4gICAgdW5zdWJzY3JpYmUoaGFuZGxlcikge1xuICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKCd1cGRhdGUnLCBoYW5kbGVyKTtcbiAgICB9XG4gICAgLy9cbiAgICAvLyBwcml2YXRlXG4gICAgLy9cbiAgICAvLyByZWFkIGZyb20gcGVyc2lzdGVuY2VcbiAgICBfZ2V0U3RhdGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdGF0ZTtcbiAgICB9XG4gICAgLy8gd3JpdGUgdG8gcGVyc2lzdGVuY2VcbiAgICBfcHV0U3RhdGUobmV3U3RhdGUpIHtcbiAgICAgICAgdGhpcy5fc3RhdGUgPSBuZXdTdGF0ZTtcbiAgICB9XG59XG5leHBvcnRzLk9ic2VydmFibGVTdG9yZSA9IE9ic2VydmFibGVTdG9yZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU9ic2VydmFibGVTdG9yZS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@metamask/obs-store/dist/ObservableStore.js\n");

/***/ }),

/***/ "./node_modules/@metamask/obs-store/dist/asStream.js":
/*!***********************************************************!*\
  !*** ./node_modules/@metamask/obs-store/dist/asStream.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.storeAsStream = void 0;\nconst stream_1 = __webpack_require__(/*! stream */ \"./node_modules/next/dist/compiled/stream-browserify/index.js\");\nclass ObservableStoreStream extends stream_1.Duplex {\n    constructor(obsStore) {\n        super({\n            // pass values, not serializations\n            objectMode: true,\n        });\n        // dont buffer outgoing updates\n        this.resume();\n        // save handler so we can unsubscribe later\n        this.handler = (state) => this.push(state);\n        // subscribe to obsStore changes\n        this.obsStore = obsStore;\n        this.obsStore.subscribe(this.handler);\n    }\n    // emit current state on new destination\n    pipe(dest, options) {\n        const result = super.pipe(dest, options);\n        dest.write(this.obsStore.getState());\n        return result;\n    }\n    // write from incoming stream to state\n    _write(chunk, _encoding, callback) {\n        this.obsStore.putState(chunk);\n        callback();\n    }\n    // noop - outgoing stream is asking us if we have data we arent giving it\n    _read(_size) {\n        return undefined;\n    }\n    // unsubscribe from event emitter\n    _destroy(err, callback) {\n        this.obsStore.unsubscribe(this.handler);\n        super._destroy(err, callback);\n    }\n}\nfunction storeAsStream(obsStore) {\n    return new ObservableStoreStream(obsStore);\n}\nexports.storeAsStream = storeAsStream;\n//# sourceMappingURL=asStream.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL29icy1zdG9yZS9kaXN0L2FzU3RyZWFtLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHFCQUFxQjtBQUNyQixpQkFBaUIsbUJBQU8sQ0FBQyw0RUFBUTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9vYnMtc3RvcmUvZGlzdC9hc1N0cmVhbS5qcz9mZjNkIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5zdG9yZUFzU3RyZWFtID0gdm9pZCAwO1xuY29uc3Qgc3RyZWFtXzEgPSByZXF1aXJlKFwic3RyZWFtXCIpO1xuY2xhc3MgT2JzZXJ2YWJsZVN0b3JlU3RyZWFtIGV4dGVuZHMgc3RyZWFtXzEuRHVwbGV4IHtcbiAgICBjb25zdHJ1Y3RvcihvYnNTdG9yZSkge1xuICAgICAgICBzdXBlcih7XG4gICAgICAgICAgICAvLyBwYXNzIHZhbHVlcywgbm90IHNlcmlhbGl6YXRpb25zXG4gICAgICAgICAgICBvYmplY3RNb2RlOiB0cnVlLFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gZG9udCBidWZmZXIgb3V0Z29pbmcgdXBkYXRlc1xuICAgICAgICB0aGlzLnJlc3VtZSgpO1xuICAgICAgICAvLyBzYXZlIGhhbmRsZXIgc28gd2UgY2FuIHVuc3Vic2NyaWJlIGxhdGVyXG4gICAgICAgIHRoaXMuaGFuZGxlciA9IChzdGF0ZSkgPT4gdGhpcy5wdXNoKHN0YXRlKTtcbiAgICAgICAgLy8gc3Vic2NyaWJlIHRvIG9ic1N0b3JlIGNoYW5nZXNcbiAgICAgICAgdGhpcy5vYnNTdG9yZSA9IG9ic1N0b3JlO1xuICAgICAgICB0aGlzLm9ic1N0b3JlLnN1YnNjcmliZSh0aGlzLmhhbmRsZXIpO1xuICAgIH1cbiAgICAvLyBlbWl0IGN1cnJlbnQgc3RhdGUgb24gbmV3IGRlc3RpbmF0aW9uXG4gICAgcGlwZShkZXN0LCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHN1cGVyLnBpcGUoZGVzdCwgb3B0aW9ucyk7XG4gICAgICAgIGRlc3Qud3JpdGUodGhpcy5vYnNTdG9yZS5nZXRTdGF0ZSgpKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLy8gd3JpdGUgZnJvbSBpbmNvbWluZyBzdHJlYW0gdG8gc3RhdGVcbiAgICBfd3JpdGUoY2h1bmssIF9lbmNvZGluZywgY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5vYnNTdG9yZS5wdXRTdGF0ZShjaHVuayk7XG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgfVxuICAgIC8vIG5vb3AgLSBvdXRnb2luZyBzdHJlYW0gaXMgYXNraW5nIHVzIGlmIHdlIGhhdmUgZGF0YSB3ZSBhcmVudCBnaXZpbmcgaXRcbiAgICBfcmVhZChfc2l6ZSkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvLyB1bnN1YnNjcmliZSBmcm9tIGV2ZW50IGVtaXR0ZXJcbiAgICBfZGVzdHJveShlcnIsIGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMub2JzU3RvcmUudW5zdWJzY3JpYmUodGhpcy5oYW5kbGVyKTtcbiAgICAgICAgc3VwZXIuX2Rlc3Ryb3koZXJyLCBjYWxsYmFjayk7XG4gICAgfVxufVxuZnVuY3Rpb24gc3RvcmVBc1N0cmVhbShvYnNTdG9yZSkge1xuICAgIHJldHVybiBuZXcgT2JzZXJ2YWJsZVN0b3JlU3RyZWFtKG9ic1N0b3JlKTtcbn1cbmV4cG9ydHMuc3RvcmVBc1N0cmVhbSA9IHN0b3JlQXNTdHJlYW07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hc1N0cmVhbS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@metamask/obs-store/dist/asStream.js\n");

/***/ }),

/***/ "./node_modules/@metamask/obs-store/dist/index.js":
/*!********************************************************!*\
  !*** ./node_modules/@metamask/obs-store/dist/index.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./asStream */ \"./node_modules/@metamask/obs-store/dist/asStream.js\"), exports);\n__exportStar(__webpack_require__(/*! ./ComposedStore */ \"./node_modules/@metamask/obs-store/dist/ComposedStore.js\"), exports);\n__exportStar(__webpack_require__(/*! ./MergedStore */ \"./node_modules/@metamask/obs-store/dist/MergedStore.js\"), exports);\n__exportStar(__webpack_require__(/*! ./ObservableStore */ \"./node_modules/@metamask/obs-store/dist/ObservableStore.js\"), exports);\n__exportStar(__webpack_require__(/*! ./transform */ \"./node_modules/@metamask/obs-store/dist/transform.js\"), exports);\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL29icy1zdG9yZS9kaXN0L2luZGV4LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBLG1DQUFtQyxvQ0FBb0MsZ0JBQWdCO0FBQ3ZGLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxhQUFhLG1CQUFPLENBQUMsdUVBQVk7QUFDakMsYUFBYSxtQkFBTyxDQUFDLGlGQUFpQjtBQUN0QyxhQUFhLG1CQUFPLENBQUMsNkVBQWU7QUFDcEMsYUFBYSxtQkFBTyxDQUFDLHFGQUFtQjtBQUN4QyxhQUFhLG1CQUFPLENBQUMseUVBQWE7QUFDbEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9vYnMtc3RvcmUvZGlzdC9pbmRleC5qcz9lNzNiIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH0pO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vYXNTdHJlYW1cIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL0NvbXBvc2VkU3RvcmVcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL01lcmdlZFN0b3JlXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9PYnNlcnZhYmxlU3RvcmVcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3RyYW5zZm9ybVwiKSwgZXhwb3J0cyk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@metamask/obs-store/dist/index.js\n");

/***/ }),

/***/ "./node_modules/@metamask/obs-store/dist/transform.js":
/*!************************************************************!*\
  !*** ./node_modules/@metamask/obs-store/dist/transform.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.storeTransformStream = void 0;\nconst through2_1 = __webpack_require__(/*! through2 */ \"./node_modules/through2/through2.js\");\nfunction storeTransformStream(syncTransformFn) {\n    return through2_1.obj((state, _encoding, cb) => {\n        try {\n            const newState = syncTransformFn(state);\n            cb(null, newState);\n            return undefined;\n        }\n        catch (err) {\n            cb(err);\n            return undefined;\n        }\n    });\n}\nexports.storeTransformStream = storeTransformStream;\n//# sourceMappingURL=transform.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL29icy1zdG9yZS9kaXN0L3RyYW5zZm9ybS5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCw0QkFBNEI7QUFDNUIsbUJBQW1CLG1CQUFPLENBQUMscURBQVU7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLDRCQUE0QjtBQUM1QiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL29icy1zdG9yZS9kaXN0L3RyYW5zZm9ybS5qcz8xNTcxIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5zdG9yZVRyYW5zZm9ybVN0cmVhbSA9IHZvaWQgMDtcbmNvbnN0IHRocm91Z2gyXzEgPSByZXF1aXJlKFwidGhyb3VnaDJcIik7XG5mdW5jdGlvbiBzdG9yZVRyYW5zZm9ybVN0cmVhbShzeW5jVHJhbnNmb3JtRm4pIHtcbiAgICByZXR1cm4gdGhyb3VnaDJfMS5vYmooKHN0YXRlLCBfZW5jb2RpbmcsIGNiKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBuZXdTdGF0ZSA9IHN5bmNUcmFuc2Zvcm1GbihzdGF0ZSk7XG4gICAgICAgICAgICBjYihudWxsLCBuZXdTdGF0ZSk7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGNiKGVycik7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5leHBvcnRzLnN0b3JlVHJhbnNmb3JtU3RyZWFtID0gc3RvcmVUcmFuc2Zvcm1TdHJlYW07XG4vLyMgc291cmNlTWFwcGluZ1VSTD10cmFuc2Zvcm0uanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@metamask/obs-store/dist/transform.js\n");

/***/ }),

/***/ "./node_modules/@toruslabs/torus-embed/dist/torus.esm.js":
/*!***************************************************************!*\
  !*** ./node_modules/@toruslabs/torus-embed/dist/torus.esm.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"BUTTON_POSITION\": function() { return /* binding */ BUTTON_POSITION; },\n/* harmony export */   \"LOGIN_PROVIDER\": function() { return /* binding */ LOGIN_PROVIDER; },\n/* harmony export */   \"PAYMENT_PROVIDER\": function() { return /* binding */ PAYMENT_PROVIDER; },\n/* harmony export */   \"SUPPORTED_PAYMENT_NETWORK\": function() { return /* binding */ SUPPORTED_PAYMENT_NETWORK; },\n/* harmony export */   \"TORUS_BUILD_ENV\": function() { return /* binding */ TORUS_BUILD_ENV; },\n/* harmony export */   \"TorusInpageProvider\": function() { return /* binding */ TorusInpageProvider; },\n/* harmony export */   \"WALLET_OPENLOGIN_VERIFIER_MAP\": function() { return /* binding */ WALLET_OPENLOGIN_VERIFIER_MAP; },\n/* harmony export */   \"WALLET_VERIFIERS\": function() { return /* binding */ WALLET_VERIFIERS; },\n/* harmony export */   \"default\": function() { return /* binding */ Torus; }\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/objectWithoutProperties */ \"./node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\");\n/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ \"./node_modules/@babel/runtime/helpers/esm/defineProperty.js\");\n/* harmony import */ var _toruslabs_http_helpers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @toruslabs/http-helpers */ \"./node_modules/@toruslabs/http-helpers/dist/httpHelpers.esm.js\");\n/* harmony import */ var _toruslabs_openlogin_jrpc__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @toruslabs/openlogin-jrpc */ \"./node_modules/@toruslabs/openlogin-jrpc/dist/openloginJrpc.esm.js\");\n/* harmony import */ var lodash_merge__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! lodash.merge */ \"./node_modules/lodash.merge/index.js\");\n/* harmony import */ var lodash_merge__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(lodash_merge__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _metamask_obs_store__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @metamask/obs-store */ \"./node_modules/@metamask/obs-store/dist/index.js\");\n/* harmony import */ var _metamask_obs_store__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_metamask_obs_store__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var eth_rpc_errors__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! eth-rpc-errors */ \"./node_modules/eth-rpc-errors/dist/index.js\");\n/* harmony import */ var fast_deep_equal__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! fast-deep-equal */ \"./node_modules/fast-deep-equal/index.js\");\n/* harmony import */ var fast_deep_equal__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(fast_deep_equal__WEBPACK_IMPORTED_MODULE_7__);\n/* harmony import */ var is_stream__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! is-stream */ \"./node_modules/is-stream/index.js\");\n/* harmony import */ var is_stream__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(is_stream__WEBPACK_IMPORTED_MODULE_8__);\n/* harmony import */ var pump__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! pump */ \"./node_modules/pump/index.js\");\n/* harmony import */ var pump__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(pump__WEBPACK_IMPORTED_MODULE_9__);\n/* harmony import */ var loglevel__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! loglevel */ \"./node_modules/loglevel/lib/loglevel.js\");\n/* harmony import */ var loglevel__WEBPACK_IMPORTED_MODULE_10___default = /*#__PURE__*/__webpack_require__.n(loglevel__WEBPACK_IMPORTED_MODULE_10__);\n/* harmony import */ var create_hash__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! create-hash */ \"./node_modules/create-hash/browser.js\");\n/* harmony import */ var create_hash__WEBPACK_IMPORTED_MODULE_11___default = /*#__PURE__*/__webpack_require__.n(create_hash__WEBPACK_IMPORTED_MODULE_11__);\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! events */ \"./node_modules/events/events.js\");\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_12___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_12__);\n/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\")[\"Buffer\"];\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst LOGIN_PROVIDER = {\n  GOOGLE: \"google\",\n  FACEBOOK: \"facebook\",\n  TWITCH: \"twitch\",\n  REDDIT: \"reddit\",\n  DISCORD: \"discord\"\n};\nconst WALLET_VERIFIERS = {\n  GOOGLE: \"google\",\n  FACEBOOK: \"facebook\",\n  TWITCH: \"twitch\",\n  REDDIT: \"reddit\",\n  DISCORD: \"discord\",\n  EMAIL_PASSWORDLESS: \"torus-auth0-email-passwordless\"\n};\nconst WALLET_OPENLOGIN_VERIFIER_MAP = {\n  [WALLET_VERIFIERS.GOOGLE]: \"tkey-google\",\n  [WALLET_VERIFIERS.FACEBOOK]: \"tkey-facebook\",\n  [WALLET_VERIFIERS.TWITCH]: \"tkey-twitch\",\n  [WALLET_VERIFIERS.REDDIT]: \"tkey-reddit\",\n  [WALLET_VERIFIERS.DISCORD]: \"tkey-discord\",\n  [WALLET_VERIFIERS.EMAIL_PASSWORDLESS]: \"tkey-auth0-email-passwordless\"\n};\nconst PAYMENT_PROVIDER = {\n  MOONPAY: \"moonpay\",\n  WYRE: \"wyre\",\n  RAMPNETWORK: \"rampnetwork\",\n  XANPOOL: \"xanpool\",\n  MERCURYO: \"mercuryo\",\n  TRANSAK: \"transak\",\n  BANXA: \"banxa\"\n};\nconst SUPPORTED_PAYMENT_NETWORK = {\n  MAINNET: \"mainnet\",\n  MATIC: \"matic\",\n  BSC_MAINNET: \"bsc_mainnet\",\n  AVALANCHE_MAINNET: \"avalanche_mainnet\",\n  XDAI: \"xdai\"\n};\nconst TORUS_BUILD_ENV = {\n  PRODUCTION: \"production\",\n  DEVELOPMENT: \"development\",\n  BINANCE: \"binance\",\n  TESTING: \"testing\",\n  LRC: \"lrc\",\n  BETA: \"beta\",\n  BNB: \"bnb\",\n  POLYGON: \"polygon\"\n};\nconst BUTTON_POSITION = {\n  BOTTOM_LEFT: \"bottom-left\",\n  TOP_LEFT: \"top-left\",\n  BOTTOM_RIGHT: \"bottom-right\",\n  TOP_RIGHT: \"top-right\"\n};\n\n/**\n * From https://min-api.cryptocompare.com/data/v2/pair/mapping/fsym?fsym=BTC&extraParams=YourSite\n * GET https://min-api.cryptocompare.com/data/v2/pair/mapping/fsym?fsym=BTC\n * Then map over returned entries, picking tsym\n *\n * Last updated: Date of commit\n */\n\nconst CRYPTO_COMPARE_CURRENCIES = [\"ETH\", \"USDT\", \"USDC\", \"TUSD\", \"EOSDT\", \"USD\", \"DAI\", \"GUSD\", \"DKKT\", \"PAX\", \"ILS\", \"RUB\", \"BYN\", \"EUR\", \"GBP\", \"JPY\", \"KRW\", \"PLN\", \"MXN\", \"AUD\", \"BRL\", \"CAD\", \"CHF\", \"KPW\", \"LAK\", \"LBP\", \"LKR\", \"XOF\", \"CNHT\", \"DOGE\", \"UAH\", \"TRY\", \"HKD\", \"XJP\", \"SGD\", \"USC\", \"NZD\", \"NGN\", \"RUR\", \"COP\", \"GHS\", \"EGP\", \"IDR\", \"BHD\", \"CRC\", \"PEN\", \"AED\", \"DOP\", \"PKR\", \"HUF\", \"VND\", \"XAR\", \"LTC\", \"RON\", \"OMR\", \"MYR\", \"DKK\", \"UGX\", \"ZMW\", \"SAR\", \"SEK\", \"GEL\", \"RWF\", \"IRR\", \"TZS\", \"CNY\", \"VEF\", \"BDT\", \"HRK\", \"CLP\", \"THB\", \"XAF\", \"ARS\", \"UYU\", \"SZL\", \"KZT\", \"NOK\", \"KES\", \"PAB\", \"INR\", \"CZK\", \"MAD\", \"TWD\", \"PHP\", \"ZAR\", \"BOB\", \"CDF\", \"DASH\", \"VES\", \"ISK\", \"MWK\", \"BAM\", \"TTD\", \"XRP\", \"JOD\", \"RSD\", \"HNL\", \"BGN\", \"GTQ\", \"BWP\", \"XMR\", \"MMK\", \"QAR\", \"AOA\", \"KWD\", \"MUR\", \"WUSD\", \"WEUR\", \"WAVES\", \"WTRY\", \"LRD\", \"LSL\", \"LYD\", \"AWG\", \"MDL\", \"BTO\", \"EURS\", \"CHFT\", \"MKD\", \"MNT\", \"MOP\", \"MRO\", \"MVR\", \"VOLLAR\", \"CKUSD\", \"KHR\", \"VUV\", \"BITCNY\", \"QC\", \"BBD\", \"NAD\", \"NPR\", \"PGK\", \"PYG\", \"BIF\", \"BMD\", \"BND\", \"XLM\", \"BNB\", \"SCR\", \"BAT\", \"CRO\", \"HT\", \"KCS\", \"LEO\", \"LINK\", \"MKR\", \"NPXS\", \"OMG\", \"REP\", \"ZB\", \"ZIL\", \"ZRX\", \"BCH\", \"BZD\", \"CUP\", \"CVE\", \"DJF\", \"DZD\", \"ERN\", \"ETB\", \"FJD\", \"FKP\", \"BUSD\", \"ANCT\", \"ALL\", \"AMD\", \"ANG\", \"CNYX\", \"IQD\", \"UZS\", \"TND\", \"GGP\", \"XAU\", \"KGS\", \"GIP\", \"JMD\", \"ZEC\", \"USDP\", \"BSV\", \"EMC2\", \"SNT\", \"GTO\", \"POWR\", \"EUSD\", \"EURT\", \"BCY\", \"BTS\", \"ATM\", \"BLOCKPAY\", \"ARDR\", \"AMP\", \"B2X\", \"BITGOLD\", \"BITEUR\", \"ATB\", \"BITUSD\", \"AGRS\", \"DFXT\", \"HIKEN\", \"BIX\", \"KNC\", \"EOS\", \"COB\", \"COSS\", \"BMH\", \"NANO\", \"BDG\", \"BNT\", \"XVG\", \"LKK1Y\", \"LKK\", \"USDK\", \"EURN\", \"NZDT\", \"JSE\", \"GMD\", \"GNF\", \"GYD\", \"YER\", \"XPF\", \"HTG\", \"SLL\", \"SOS\", \"WST\", \"SVC\", \"SYP\", \"NEO\", \"KMF\", \"JUMP\", \"AYA\", \"BLAST\", \"WGR\", \"BCN\", \"BTG\", \"URALS\", \"INN\", \"USDQ\", \"CNH\", \"HUSD\", \"BKRW\", \"NZDX\", \"EURX\", \"CADX\", \"USDEX\", \"JPYX\", \"AUDX\", \"VNDC\", \"EON\", \"GBPX\", \"CHFX\", \"USDJ\", \"IDRT\", \"USDS\", \"USDN\", \"BIDR\", \"IDK\", \"BSD\", \"BTN\", \"KYD\", \"NIO\", \"SBD\", \"SDG\", \"SHP\", \"TOP\", \"XCD\", \"XCHF\", \"CNYT\", \"GYEN\", \"ZUSD\", \"GOLD\", \"TRX\", \"TRYB\", \"PLATC\", \"STRAX\", \"UST\", \"GLM\", \"VAI\", \"BRZ\", \"DDRST\", \"XAUT\", \"MIM\"];\n/**\n * currencies supported by the payment provider\n * Last updated: Date of commit\n */\n\nconst PROVIDER_SUPPORTED_FIAT_CURRENCIES = {\n  // https://integrations.simplex.com/supported_currencies\n  // https://support.moonpay.com/hc/en-gb/articles/360011931457-Which-fiat-currencies-are-supported-\n  [PAYMENT_PROVIDER.MOONPAY]: [\"AUD\", \"BGN\", \"BRL\", \"CAD\", \"CHF\", \"CNY\", \"COP\", \"CZK\", \"DKK\", \"DOP\", \"EGP\", \"EUR\", \"GBP\", \"HKD\", \"HRK\", \"IDR\", \"ILS\", \"JPY\", \"JOD\", \"KES\", \"KRW\", \"KWD\", \"LKR\", \"MAD\", \"MXN\", \"MYR\", \"NGN\", \"NOK\", \"NZD\", \"OMR\", \"PEN\", \"PKR\", \"PLN\", \"RON\", \"RUB\", \"SEK\", \"SGD\", \"THB\", \"TRY\", \"TWD\", \"USD\", \"VND\", \"ZAR\"],\n\n  /**\n   * https://docs.sendwyre.com/docs/supported-currencies#fiat\n   * The ones where credit card is supported\n   */\n  [PAYMENT_PROVIDER.WYRE]: [\"USD\", \"EUR\", \"GBP\", \"AUD\", \"CAD\", \"NZD\", \"ARS\", \"BRL\", \"CHF\", \"CLP\", \"COP\", \"CZK\", \"DKK\", \"HKD\", \"ILS\", \"INR\", \"ISK\", \"JPY\", \"KRW\", \"MXN\", \"MYR\", \"NOK\", \"PHP\", \"PLN\", \"SEK\", \"THB\", \"VND\", \"ZAR\"],\n  // https://support.ramp.network/en/articles/471-why-am-i-paying-in-usd-eur-gbp\n  [PAYMENT_PROVIDER.RAMPNETWORK]: [\"USD\", \"EUR\", \"GBP\"],\n  // From https://xanpool.com/ fiat select dropdown\n  [PAYMENT_PROVIDER.XANPOOL]: [\"SGD\", \"HKD\", \"THB\", \"PHP\", \"INR\", \"IDR\", \"MYR\", \"AUD\", \"NZD\", \"KRW\"],\n  // https://support.aax.com/en/articles/5295762-mercuryo\n  // RUB / UAH currently not supported\n  [PAYMENT_PROVIDER.MERCURYO]: [\"EUR\", \"USD\", \"GBP\", \"TRY\", \"JPY\", \"BRL\", \"NGN\", \"VND\", \"MXN\", \"KRW\"],\n\n  /**\n   * https://support.transak.com/hc/en-us/articles/360020615578-Credit-and-Debit-Card-Payments-through-Transak\n   * or\n   * https://transak.stoplight.io/docs/transak-docs/b3A6OTk1ODQ0-2-get-fiat-currencies\n   */\n  [PAYMENT_PROVIDER.TRANSAK]: [\"ARS\", \"AUD\", \"BBD\", \"BGN\", \"BMD\", \"BRL\", \"CAD\", \"CHF\", \"CLP\", \"CRC\", \"CZK\", \"DKK\", \"DOP\", \"EUR\", \"FJD\", \"FKP\", \"GBP\", \"GIP\", \"HRK\", \"HUF\", \"IDR\", \"ILS\", \"ISK\", \"JMD\", \"JPY\", \"KES\", \"KRW\", \"MDL\", \"MXN\", \"MYR\", \"NOK\", \"NZD\", \"PEN\", \"PHP\", \"PLN\", \"PYG\", \"RON\", \"SEK\", \"SGD\", \"THB\", \"TRY\", \"TZS\", \"USD\", \"ZAR\"],\n  [PAYMENT_PROVIDER.BANXA]: [\"EUR\", \"GBP\", \"USD\"]\n};\nconst cryptoCompareCurrenciesSet = new Set(CRYPTO_COMPARE_CURRENCIES);\n/**\n * Fiat currencies that we support\n */\n\nfunction supportedFiatCurrencies(provider) {\n  const providerSupportedFiatCurrencies = PROVIDER_SUPPORTED_FIAT_CURRENCIES[provider];\n  return providerSupportedFiatCurrencies.filter(currency => cryptoCompareCurrenciesSet.has(currency));\n}\n\nconst paymentProviders$1 = {\n  [PAYMENT_PROVIDER.MOONPAY]: {\n    line1: \"Credit/ Debit Card/ Apple Pay\",\n    line2: \"4.5% or 5 USD\",\n    line3: \"2,000€/day, 10,000€/mo\",\n    supportPage: \"https://help.moonpay.io/en/\",\n    minOrderValue: 24.99,\n    maxOrderValue: 50000,\n    validCurrencies: supportedFiatCurrencies(PAYMENT_PROVIDER.MOONPAY),\n    validCryptoCurrenciesByChain: {\n      [SUPPORTED_PAYMENT_NETWORK.MAINNET]: [{\n        value: \"aave\",\n        display: \"AAVE\"\n      }, {\n        value: \"bat\",\n        display: \"BAT\"\n      }, {\n        value: \"dai\",\n        display: \"DAI\"\n      }, {\n        value: \"eth\",\n        display: \"ETH\"\n      }, {\n        value: \"mkr\",\n        display: \"MKR\"\n      }, {\n        value: \"matic\",\n        display: \"MATIC\"\n      }, {\n        value: \"usdt\",\n        display: \"USDT\"\n      }, {\n        value: \"usdc\",\n        display: \"USDC\"\n      }],\n      [SUPPORTED_PAYMENT_NETWORK.MATIC]: [{\n        value: \"eth_polygon\",\n        display: \"ETH\"\n      }, {\n        value: \"matic_polygon\",\n        display: \"MATIC\"\n      }, {\n        value: \"usdc_polygon\",\n        display: \"USDC\"\n      }],\n      [SUPPORTED_PAYMENT_NETWORK.BSC_MAINNET]: [{\n        value: \"bnb_bsc\",\n        display: \"BNB\"\n      }, {\n        value: \"busd_bsc\",\n        display: \"BUSD\"\n      }],\n      [SUPPORTED_PAYMENT_NETWORK.AVALANCHE_MAINNET]: [{\n        value: \"avax_cchain\",\n        display: \"AVAX\"\n      }]\n    },\n    includeFees: true,\n    api: true,\n    enforceMax: false\n  },\n  [PAYMENT_PROVIDER.WYRE]: {\n    line1: \"Apple Pay/ Debit/ Credit Card\",\n    line2: \"4.9% + 30¢ or 5 USD\",\n    line3: \"$250/day\",\n    supportPage: \"https://support.sendwyre.com/en/\",\n    minOrderValue: 5,\n    maxOrderValue: 500,\n    validCurrencies: supportedFiatCurrencies(PAYMENT_PROVIDER.WYRE),\n    validCryptoCurrenciesByChain: {\n      [SUPPORTED_PAYMENT_NETWORK.MAINNET]: [{\n        value: \"AAVE\",\n        display: \"AAVE\"\n      }, {\n        value: \"BAT\",\n        display: \"BAT\"\n      }, {\n        value: \"BUSD\",\n        display: \"BUSD\"\n      }, {\n        value: \"DAI\",\n        display: \"DAI\"\n      }, {\n        value: \"ETH\",\n        display: \"ETH\"\n      }, {\n        value: \"MKR\",\n        display: \"MKR\"\n      }, {\n        value: \"UNI\",\n        display: \"UNI\"\n      }, {\n        value: \"USDC\",\n        display: \"USDC\"\n      }, {\n        value: \"USDT\",\n        display: \"USDT\"\n      }],\n      [SUPPORTED_PAYMENT_NETWORK.MATIC]: [{\n        value: \"MUSDC\",\n        display: \"USDC\"\n      }],\n      // AVAXC? or AVAX?\n      [SUPPORTED_PAYMENT_NETWORK.AVALANCHE_MAINNET]: [{\n        value: \"AVAXC\",\n        display: \"AVAXC\"\n      }]\n    },\n    includeFees: false,\n    api: true,\n    enforceMax: false\n  },\n  [PAYMENT_PROVIDER.RAMPNETWORK]: {\n    line1: \"Debit Card/ <br>Apple Pay/ Bank transfer\",\n    line2: \"0.49% - 2.9%\",\n    line3: \"5,000€/purchase, 20,000€/mo\",\n    supportPage: \"https://instant.ramp.network/\",\n    minOrderValue: 50,\n    maxOrderValue: 20000,\n    validCurrencies: supportedFiatCurrencies(PAYMENT_PROVIDER.RAMPNETWORK),\n    validCryptoCurrenciesByChain: {\n      [SUPPORTED_PAYMENT_NETWORK.MAINNET]: [{\n        value: \"ETH\",\n        display: \"ETH\"\n      }, {\n        value: \"DAI\",\n        display: \"DAI\"\n      }, {\n        value: \"USDC\",\n        display: \"USDC\"\n      }, {\n        value: \"USDT\",\n        display: \"USDT\"\n      }],\n      [SUPPORTED_PAYMENT_NETWORK.MATIC]: [{\n        value: \"MATIC_DAI\",\n        display: \"DAI\"\n      }, {\n        value: \"MATIC_MATIC\",\n        display: \"MATIC\"\n      }, {\n        value: \"MATIC_USDC\",\n        display: \"USDC\"\n      }],\n      // what about AVAXC?\n      [SUPPORTED_PAYMENT_NETWORK.AVALANCHE_MAINNET]: [{\n        value: \"AVAX\",\n        display: \"AVAX\"\n      }] // Temporary unavailable\n      // [SUPPORTED_PAYMENT_NETWORK.XDAI]: [{ value: 'XDAI_XDAI', display: 'XDAI' }],\n\n    },\n    includeFees: true,\n    api: true,\n    receiveHint: \"walletTopUp.receiveHintRamp\",\n    enforceMax: false\n  },\n  [PAYMENT_PROVIDER.XANPOOL]: {\n    line1: \"PayNow/ InstaPay/ FPS/ GoJekPay/ UPI/ PromptPay/ <br>ViettelPay/ DuitNow\",\n    line2: \"2.5% buying, 3% selling\",\n    line3: \"$2,500 / day\",\n    supportPage: \"mailto:support@xanpool.com\",\n    minOrderValue: 100,\n    maxOrderValue: 2500,\n    validCurrencies: supportedFiatCurrencies(PAYMENT_PROVIDER.XANPOOL),\n    validCryptoCurrenciesByChain: {\n      [SUPPORTED_PAYMENT_NETWORK.MAINNET]: [{\n        value: \"ETH\",\n        display: \"ETH\"\n      }, {\n        value: \"USDT\",\n        display: \"USDT\"\n      }]\n    },\n    includeFees: true,\n    api: true,\n    sell: true,\n    enforceMax: false\n  },\n  [PAYMENT_PROVIDER.MERCURYO]: {\n    line1: \"Credit/ Debit Card/ Apple Pay\",\n    line2: \"3.95% or 4 USD\",\n    line3: \"10,000€/day, 25,000€/mo\",\n    supportPage: \"mailto:support@mercuryo.io\",\n    minOrderValue: 30,\n    maxOrderValue: 5000,\n    validCurrencies: supportedFiatCurrencies(PAYMENT_PROVIDER.MERCURYO),\n    validCryptoCurrenciesByChain: {\n      [SUPPORTED_PAYMENT_NETWORK.MAINNET]: [{\n        value: \"ETH\",\n        display: \"ETH\"\n      }, {\n        value: \"BAT\",\n        display: \"BAT\"\n      }, {\n        value: \"USDT\",\n        display: \"USDT\"\n      }, {\n        value: \"DAI\",\n        display: \"DAI\"\n      }],\n      [SUPPORTED_PAYMENT_NETWORK.BSC_MAINNET]: [{\n        value: \"BNB\",\n        display: \"BNB\"\n      }, {\n        value: \"BUSD\",\n        display: \"BUSD\"\n      }, {\n        value: \"1INCH\",\n        display: \"1INCH\"\n      }]\n    },\n    includeFees: true,\n    api: true,\n    enforceMax: false\n  },\n  [PAYMENT_PROVIDER.TRANSAK]: {\n    line1: \"Apple & Google Pay / Credit/Debit Card<br/>Bangkok Bank Mobile & iPay<br/>Bank Transfer (sepa/gbp) / SCB Mobile & Easy\",\n    line2: \"0.99% - 5.5% or 5 USD\",\n    line3: \"$5,000/day, $28,000/mo\",\n    supportPage: \"https://support.transak.com/hc/en-US\",\n    minOrderValue: 30,\n    maxOrderValue: 500,\n    validCurrencies: supportedFiatCurrencies(PAYMENT_PROVIDER.TRANSAK),\n    validCryptoCurrenciesByChain: {\n      [SUPPORTED_PAYMENT_NETWORK.MAINNET]: [{\n        value: \"AAVE\",\n        display: \"AAVE\"\n      }, {\n        value: \"DAI\",\n        display: \"DAI\"\n      }, {\n        value: \"ETH\",\n        display: \"ETH\"\n      }, {\n        value: \"USDC\",\n        display: \"USDC\"\n      }, {\n        value: \"USDT\",\n        display: \"USDT\"\n      }],\n      [SUPPORTED_PAYMENT_NETWORK.MATIC]: [{\n        value: \"AAVE\",\n        display: \"AAVE\"\n      }, {\n        value: \"DAI\",\n        display: \"DAI\"\n      }, {\n        value: \"MATIC\",\n        display: \"MATIC\"\n      }, {\n        value: \"USDC\",\n        display: \"USDC\"\n      }, {\n        value: \"USDT\",\n        display: \"USDT\"\n      }, {\n        value: \"WETH\",\n        display: \"WETH\"\n      }],\n      [SUPPORTED_PAYMENT_NETWORK.BSC_MAINNET]: [{\n        value: \"BNB\",\n        display: \"BNB\"\n      }, {\n        value: \"BUSD\",\n        display: \"BUSD\"\n      }],\n      [SUPPORTED_PAYMENT_NETWORK.AVALANCHE_MAINNET]: [{\n        value: \"AVAX\",\n        display: \"AVAX\"\n      }]\n    },\n    includeFees: true,\n    enforceMax: true\n  },\n  [PAYMENT_PROVIDER.BANXA]: {\n    line1: \"Debit Card/ <br>Apple Pay/ Bank transfer\",\n    line2: \"0.49% - 2.9%\",\n    line3: \"5,000€/purchase, 20,000€/mo\",\n    supportPage: \"https://support.banxa.com\",\n    minOrderValue: 20,\n    maxOrderValue: 15000,\n    validCurrencies: supportedFiatCurrencies(PAYMENT_PROVIDER.BANXA),\n    validCryptoCurrenciesByChain: {\n      [SUPPORTED_PAYMENT_NETWORK.MAINNET]: [{\n        value: \"ETH\",\n        display: \"ETH\"\n      }, {\n        value: \"USDT\",\n        display: \"USDT\"\n      }, {\n        value: \"BUSD\",\n        display: \"BUSD\"\n      }, {\n        value: \"LINK\",\n        display: \"LINK\"\n      }, {\n        value: \"USDC\",\n        display: \"USDC\"\n      }, {\n        value: \"CHZ\",\n        display: \"CHZ\"\n      }, {\n        value: \"BAT\",\n        display: \"BAT\"\n      }, {\n        value: \"MANA\",\n        display: \"MANA\"\n      }, {\n        value: \"AAVE\",\n        display: \"AAVE\"\n      }, {\n        value: \"COMP\",\n        display: \"COMP\"\n      }, {\n        value: \"ENJ\",\n        display: \"ENJ\"\n      }],\n      [SUPPORTED_PAYMENT_NETWORK.MATIC]: [{\n        value: \"MATIC\",\n        display: \"MATIC\"\n      }] // [SUPPORTED_PAYMENT_NETWORK.BSC_MAINNET]: [{ value: \"BNB\", display: \"BNB\" }],\n\n    },\n    includeFees: true,\n    enforceMax: true\n  }\n};\nconst translations = {\n  en: {\n    embed: {\n      continue: \"Continue\",\n      actionRequired: \"Authorization required\",\n      pendingAction: \"Click continue to proceed with your request in a popup\",\n      cookiesRequired: \"Cookies Required\",\n      enableCookies: \"Please enable cookies in your browser preferences to access Torus\",\n      clickHere: \"More Info\"\n    }\n  },\n  de: {\n    embed: {\n      continue: \"Fortsetzen\",\n      actionRequired: \"Autorisierung erforderlich\",\n      pendingAction: \"Klicken Sie in einem Popup auf Weiter, um mit Ihrer Anfrage fortzufahren\",\n      cookiesRequired: \"Cookies benötigt\",\n      enableCookies: \"Bitte aktivieren Sie Cookies in Ihren Browsereinstellungen, um auf Torus zuzugreifen\",\n      clickHere: \"Mehr Info\"\n    }\n  },\n  ja: {\n    embed: {\n      continue: \"継続する\",\n      actionRequired: \"認証が必要です\",\n      pendingAction: \"続行をクリックして、ポップアップでリクエストを続行します\",\n      cookiesRequired: \"必要なクッキー\",\n      enableCookies: \"Torusにアクセスするには、ブラウザの設定でCookieを有効にしてください。\",\n      clickHere: \"詳しくは\"\n    }\n  },\n  ko: {\n    embed: {\n      continue: \"계속하다\",\n      actionRequired: \"승인 필요\",\n      pendingAction: \"팝업에서 요청을 진행하려면 계속을 클릭하십시오.\",\n      cookiesRequired: \"쿠키 필요\",\n      enableCookies: \"브라우저 환경 설정에서 쿠키를 활성화하여 Torus에 액세스하십시오.\",\n      clickHere: \"더 많은 정보\"\n    }\n  },\n  zh: {\n    embed: {\n      continue: \"继续\",\n      actionRequired: \"需要授权\",\n      pendingAction: \"单击继续以在弹出窗口中继续您的请求\",\n      cookiesRequired: \"必填Cookie\",\n      enableCookies: \"请在您的浏览器首选项中启用cookie以访问Torus。\",\n      clickHere: \"更多信息\"\n    }\n  }\n};\nvar configuration = {\n  supportedVerifierList: Object.values(WALLET_VERIFIERS),\n  paymentProviders: paymentProviders$1,\n  api: \"https://api.tor.us\",\n  translations,\n  prodTorusUrl: \"\",\n  localStorageKeyPrefix: `torus-`\n};\n\nconst runOnLoad = fn => new Promise((resolve, reject) => {\n  if (window.document.body != null) {\n    Promise.resolve(fn()).then(resolve).catch(reject);\n  } else {\n    window.document.addEventListener(\"DOMContentLoaded\", () => {\n      Promise.resolve(fn()).then(resolve).catch(reject);\n    });\n  }\n});\nconst htmlToElement = html => {\n  const template = window.document.createElement(\"template\");\n  const trimmedHtml = html.trim(); // Never return a text node of whitespace as the result\n\n  template.innerHTML = trimmedHtml;\n  return template.content.firstChild;\n};\nconst handleEvent = function (handle, eventName, handler) {\n  for (var _len = arguments.length, handlerArgs = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {\n    handlerArgs[_key - 3] = arguments[_key];\n  }\n\n  const handlerWrapper = () => {\n    handler(...handlerArgs);\n    handle.removeEventListener(eventName, handlerWrapper);\n  };\n\n  handle.addEventListener(eventName, handlerWrapper);\n};\nconst handleStream = (handle, eventName, handler) => {\n  const handlerWrapper = chunk => {\n    handler(chunk);\n    handle.removeListener(eventName, handlerWrapper);\n  };\n\n  handle.on(eventName, handlerWrapper);\n};\nasync function documentReady() {\n  return new Promise(resolve => {\n    if (document.readyState !== \"loading\") {\n      resolve();\n    } else {\n      handleEvent(document, \"DOMContentLoaded\", resolve);\n    }\n  });\n}\n\nvar log = loglevel__WEBPACK_IMPORTED_MODULE_10___default().getLogger(\"torus-embed\");\n\nvar messages = {\n  errors: {\n    disconnected: () => \"Torus: Lost connection to Torus.\",\n    permanentlyDisconnected: () => \"Torus: Disconnected from iframe. Page reload required.\",\n    sendSiteMetadata: () => \"Torus: Failed to send site metadata. This is an internal error, please report this bug.\",\n    unsupportedSync: method => `Torus: The Torus Ethereum provider does not support synchronous methods like ${method} without a callback parameter.`,\n    invalidDuplexStream: () => \"Must provide a Node.js-style duplex stream.\",\n    invalidOptions: (maxEventListeners, shouldSendMetadata) => `Invalid options. Received: { maxEventListeners: ${maxEventListeners}, shouldSendMetadata: ${shouldSendMetadata} }`,\n    invalidRequestArgs: () => `Expected a single, non-array, object argument.`,\n    invalidRequestMethod: () => `'args.method' must be a non-empty string.`,\n    invalidRequestParams: () => `'args.params' must be an object or array if provided.`,\n    invalidLoggerObject: () => `'args.logger' must be an object if provided.`,\n    invalidLoggerMethod: method => `'args.logger' must include required method '${method}'.`\n  },\n  info: {\n    connected: chainId => `Torus: Connected to chain with ID \"${chainId}\".`\n  },\n  warnings: {\n    // deprecated methods\n    enableDeprecation: 'Torus: \"\"ethereum.enable()\" is deprecated and may be removed in the future. ' + 'Please use \"ethereum.send(\"eth_requestAccounts\")\" instead. For more information, see: https://eips.ethereum.org/EIPS/eip-1102',\n    sendDeprecation: 'Torus: \"ethereum.send(...)\" is deprecated and may be removed in the future.' + ' Please use \"ethereum.sendAsync(...)\" or \"ethereum.request(...)\" instead.\\nFor more information, see: https://eips.ethereum.org/EIPS/eip-1193',\n    events: {\n      close: 'Torus: The event \"close\" is deprecated and may be removed in the future. Please use \"disconnect\" instead.' + \"\\nFor more information, see: https://eips.ethereum.org/EIPS/eip-1193\",\n      data: 'Torus: The event \"data\" is deprecated and will be removed in the future.' + 'Use \"message\" instead.\\nFor more information, see: https://eips.ethereum.org/EIPS/eip-1193#message',\n      networkChanged: 'Torus: The event \"networkChanged\" is deprecated and may be removed in the future.' + ' Please use \"chainChanged\" instead.\\nFor more information, see: https://eips.ethereum.org/EIPS/eip-1193',\n      notification: 'Torus: The event \"notification\" is deprecated and may be removed in the future. ' + 'Please use \"message\" instead.\\nFor more information, see: https://eips.ethereum.org/EIPS/eip-1193'\n    },\n    publicConfigStore: 'Torus: The property \"publicConfigStore\" is deprecated and WILL be removed in the future.'\n  }\n};\n\nconst {\n  paymentProviders\n} = configuration;\nconst validatePaymentProvider = (provider, params) => {\n  const errors = {};\n\n  if (!provider) {\n    return {\n      errors,\n      isValid: true\n    };\n  }\n\n  if (provider && !paymentProviders[provider]) {\n    errors.provider = \"Invalid Provider\";\n    return {\n      errors,\n      isValid: Object.keys(errors).length === 0\n    };\n  }\n\n  const selectedProvider = paymentProviders[provider];\n  const selectedParams = params || {}; // set default values\n  // if (!selectedParams.selectedCurrency) [selectedParams.selectedCurrency] = selectedProvider.validCurrencies\n  // if (!selectedParams.fiatValue) selectedParams.fiatValue = selectedProvider.minOrderValue\n  // if (!selectedParams.selectedCryptoCurrency) [selectedParams.selectedCryptoCurrency] = selectedProvider.validCryptoCurrencies\n  // validations\n\n  if (selectedParams.fiatValue) {\n    const requestedOrderAmount = +parseFloat(selectedParams.fiatValue.toString()) || 0;\n    if (requestedOrderAmount < selectedProvider.minOrderValue) errors.fiatValue = \"Requested amount is lower than supported\";\n    if (requestedOrderAmount > selectedProvider.maxOrderValue && selectedProvider.enforceMax) errors.fiatValue = \"Requested amount is higher than supported\";\n  }\n\n  if (selectedParams.selectedCurrency && !selectedProvider.validCurrencies.includes(selectedParams.selectedCurrency)) {\n    errors.selectedCurrency = \"Unsupported currency\";\n  }\n\n  if (selectedParams.selectedCryptoCurrency) {\n    const validCryptoCurrenciesByChain = Object.values(selectedProvider.validCryptoCurrenciesByChain).flat().map(currency => currency.value);\n    const finalCryptoCurrency = provider === PAYMENT_PROVIDER.MOONPAY ? selectedParams.selectedCryptoCurrency.toLowerCase() : selectedParams.selectedCryptoCurrency;\n    if (validCryptoCurrenciesByChain && !validCryptoCurrenciesByChain.includes(finalCryptoCurrency)) errors.selectedCryptoCurrency = \"Unsupported cryptoCurrency\";\n  }\n\n  return {\n    errors,\n    isValid: Object.keys(errors).length === 0\n  };\n}; // utility functions\n\n/**\n * json-rpc-engine middleware that logs RPC errors and and validates req.method.\n *\n * @param log - The logging API to use.\n * @returns  json-rpc-engine middleware function\n */\n\nfunction createErrorMiddleware() {\n  return (req, res, next) => {\n    // json-rpc-engine will terminate the request when it notices this error\n    if (typeof req.method !== \"string\" || !req.method) {\n      res.error = eth_rpc_errors__WEBPACK_IMPORTED_MODULE_6__.ethErrors.rpc.invalidRequest({\n        message: `The request 'method' must be a non-empty string.`,\n        data: req\n      });\n    }\n\n    next(done => {\n      const {\n        error\n      } = res;\n\n      if (!error) {\n        return done();\n      }\n\n      log.error(`MetaMask - RPC Error: ${error.message}`, error);\n      return done();\n    });\n  };\n} // resolve response.result or response, reject errors\n/**\n * Logs a stream disconnection error. Emits an 'error' if given an\n * EventEmitter that has listeners for the 'error' event.\n *\n * @param log - The logging API to use.\n * @param remoteLabel - The label of the disconnected stream.\n * @param error - The associated error to log.\n * @param emitter - The logging API to use.\n */\n\nfunction logStreamDisconnectWarning(remoteLabel, error, emitter) {\n  let warningMsg = `MetaMask: Lost connection to \"${remoteLabel}\".`;\n\n  if (error !== null && error !== void 0 && error.stack) {\n    warningMsg += `\\n${error.stack}`;\n  }\n\n  log.warn(warningMsg);\n\n  if (emitter && emitter.listenerCount(\"error\") > 0) {\n    emitter.emit(\"error\", warningMsg);\n  }\n}\nconst getPreopenInstanceId = () => Math.random().toString(36).slice(2);\nconst getTorusUrl = async (buildEnv, integrity) => {\n  let torusUrl;\n  let logLevel; // Do not change this line\n\n  const version = \"1.38.3\";\n  let versionUsed = integrity.version || version;\n\n  try {\n    if ((buildEnv === \"binance\" || buildEnv === \"production\") && !integrity.version) {\n      let response;\n      if (!configuration.prodTorusUrl) response = await (0,_toruslabs_http_helpers__WEBPACK_IMPORTED_MODULE_2__.get)(`${configuration.api}/latestversion?name=@toruslabs/torus-embed&version=${version}`, {}, {\n        useAPIKey: true\n      });else response = {\n        data: configuration.prodTorusUrl\n      };\n      versionUsed = response.data; // eslint-disable-next-line require-atomic-updates\n\n      configuration.prodTorusUrl = response.data;\n    }\n  } catch (error) {\n    log.error(error, \"unable to fetch latest version\");\n  }\n\n  log.info(\"version used: \", versionUsed);\n\n  switch (buildEnv) {\n    case \"binance\":\n      torusUrl = `https://binance.tor.us/v${versionUsed}`;\n      logLevel = \"info\";\n      break;\n\n    case \"testing\":\n      torusUrl = \"https://testing.tor.us\";\n      logLevel = \"debug\";\n      break;\n\n    case \"bnb\":\n      torusUrl = \"https://bnb.tor.us\";\n      logLevel = \"error\";\n      break;\n\n    case \"polygon\":\n      torusUrl = \"https://polygon.tor.us\";\n      logLevel = \"error\";\n      break;\n\n    case \"lrc\":\n      torusUrl = \"https://lrc.tor.us\";\n      logLevel = \"debug\";\n      break;\n\n    case \"beta\":\n      torusUrl = \"https://beta.tor.us\";\n      logLevel = \"debug\";\n      break;\n\n    case \"development\":\n      torusUrl = \"http://localhost:4050\";\n      logLevel = \"debug\";\n      break;\n\n    default:\n      torusUrl = `https://app.tor.us/v${versionUsed}`;\n      logLevel = \"error\";\n      break;\n  }\n\n  return {\n    torusUrl,\n    logLevel\n  };\n};\nconst getUserLanguage = () => {\n  let userLanguage = window.navigator.language || \"en-US\";\n  const userLanguages = userLanguage.split(\"-\");\n  userLanguage = Object.prototype.hasOwnProperty.call(configuration.translations, userLanguages[0]) ? userLanguages[0] : \"en\";\n  return userLanguage;\n};\nconst EMITTED_NOTIFICATIONS = [\"eth_subscription\" // per eth-json-rpc-filters/subscriptionManager\n];\nconst NOOP = () => {// empty function\n};\nconst FEATURES_PROVIDER_CHANGE_WINDOW = \"directories=0,titlebar=0,toolbar=0,status=0,location=0,menubar=0,height=660,width=375\";\nconst FEATURES_DEFAULT_WALLET_WINDOW = \"directories=0,titlebar=0,toolbar=0,status=0,location=0,menubar=0,height=740,width=1315\";\nconst FEATURES_CONFIRM_WINDOW = \"directories=0,titlebar=0,toolbar=0,status=0,location=0,menubar=0,height=700,width=450\";\nfunction getPopupFeatures() {\n  // Fixes dual-screen position                             Most browsers      Firefox\n  const dualScreenLeft = window.screenLeft !== undefined ? window.screenLeft : window.screenX;\n  const dualScreenTop = window.screenTop !== undefined ? window.screenTop : window.screenY;\n  const w = 1200;\n  const h = 700;\n  const width = window.innerWidth ? window.innerWidth : document.documentElement.clientWidth ? document.documentElement.clientWidth : window.screen.width;\n  const height = window.innerHeight ? window.innerHeight : document.documentElement.clientHeight ? document.documentElement.clientHeight : window.screen.height;\n  const systemZoom = 1; // No reliable estimate\n\n  const left = Math.abs((width - w) / 2 / systemZoom + dualScreenLeft);\n  const top = Math.abs((height - h) / 2 / systemZoom + dualScreenTop);\n  const features = `titlebar=0,toolbar=0,status=0,location=0,menubar=0,height=${h / systemZoom},width=${w / systemZoom},top=${top},left=${left}`;\n  return features;\n}\n\nfunction ownKeys$1(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread$1(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$1(Object(source), !0).forEach(function (key) { (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n_toruslabs_openlogin_jrpc__WEBPACK_IMPORTED_MODULE_3__.SafeEventEmitter.defaultMaxListeners = 100; // resolve response.result, reject errors\n\nconst getRpcPromiseCallback = function (resolve, reject) {\n  let unwrapResult = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  return (error, response) => {\n    if (error || response.error) {\n      return reject(error || response.error);\n    }\n\n    return !unwrapResult || Array.isArray(response) ? resolve(response) : resolve(response.result);\n  };\n};\n\nclass TorusInpageProvider extends _toruslabs_openlogin_jrpc__WEBPACK_IMPORTED_MODULE_3__.SafeEventEmitter {\n  /**\n   * The chain ID of the currently connected Ethereum chain.\n   * See [chainId.network]{@link https://chainid.network} for more information.\n   */\n\n  /**\n   * The user's currently selected Ethereum address.\n   * If null, MetaMask is either locked or the user has not permitted any\n   * addresses to be viewed.\n   */\n\n  /**\n   * Indicating that this provider is a MetaMask provider.\n   */\n  constructor(connectionStream) {\n    let {\n      maxEventListeners = 100,\n      shouldSendMetadata = true,\n      jsonRpcStreamName = \"provider\"\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    super();\n\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(this, \"chainId\", void 0);\n\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(this, \"selectedAddress\", void 0);\n\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(this, \"_rpcEngine\", void 0);\n\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(this, \"networkVersion\", void 0);\n\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(this, \"shouldSendMetadata\", void 0);\n\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(this, \"isTorus\", void 0);\n\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(this, \"_publicConfigStore\", void 0);\n\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(this, \"tryPreopenHandle\", void 0);\n\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(this, \"enable\", void 0);\n\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(this, \"_state\", void 0);\n\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(this, \"_jsonRpcConnection\", void 0);\n\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(this, \"_sentWarnings\", {\n      // methods\n      enable: false,\n      experimentalMethods: false,\n      send: false,\n      publicConfigStore: false,\n      // events\n      events: {\n        close: false,\n        data: false,\n        networkChanged: false,\n        notification: false\n      }\n    });\n\n    if (!(0,is_stream__WEBPACK_IMPORTED_MODULE_8__.duplex)(connectionStream)) {\n      throw new Error(messages.errors.invalidDuplexStream());\n    }\n\n    this.isTorus = true;\n    this.setMaxListeners(maxEventListeners); // private state\n\n    this._state = _objectSpread$1({}, TorusInpageProvider._defaultState); // public state\n\n    this.selectedAddress = null;\n    this.networkVersion = null;\n    this.chainId = null;\n    this.shouldSendMetadata = shouldSendMetadata; // bind functions (to prevent e.g. web3@1.x from making unbound calls)\n\n    this._handleAccountsChanged = this._handleAccountsChanged.bind(this);\n    this._handleChainChanged = this._handleChainChanged.bind(this);\n    this._handleUnlockStateChanged = this._handleUnlockStateChanged.bind(this);\n    this._handleConnect = this._handleConnect.bind(this);\n    this._handleDisconnect = this._handleDisconnect.bind(this);\n    this._handleStreamDisconnect = this._handleStreamDisconnect.bind(this);\n    this._sendSync = this._sendSync.bind(this);\n    this._rpcRequest = this._rpcRequest.bind(this);\n    this._warnOfDeprecation = this._warnOfDeprecation.bind(this);\n    this._initializeState = this._initializeState.bind(this);\n    this.request = this.request.bind(this);\n    this.send = this.send.bind(this);\n    this.sendAsync = this.sendAsync.bind(this); // this.enable = this.enable.bind(this);\n    // setup connectionStream multiplexing\n\n    const mux = new _toruslabs_openlogin_jrpc__WEBPACK_IMPORTED_MODULE_3__.ObjectMultiplex();\n    pump__WEBPACK_IMPORTED_MODULE_9___default()(connectionStream, mux, connectionStream, this._handleStreamDisconnect.bind(this, \"MetaMask\")); // subscribe to metamask public config (one-way)\n\n    this._publicConfigStore = new _metamask_obs_store__WEBPACK_IMPORTED_MODULE_5__.ObservableStore({\n      storageKey: \"Metamask-Config\"\n    }); // handle isUnlocked changes, and chainChanged and networkChanged events\n    // this._publicConfigStore.subscribe((stringifiedState) => {\n    //   // This is because we are using store as string\n    //   const state = JSON.parse(stringifiedState as unknown as string);\n    //   if (\"isUnlocked\" in state && state.isUnlocked !== this._state.isUnlocked) {\n    //     this._state.isUnlocked = state.isUnlocked;\n    //     if (!this._state.isUnlocked) {\n    //       // accounts are never exposed when the extension is locked\n    //       this._handleAccountsChanged([]);\n    //     } else {\n    //       // this will get the exposed accounts, if any\n    //       try {\n    //         this._rpcRequest(\n    //           { method: \"eth_accounts\", params: [] },\n    //           NOOP,\n    //           true // indicating that eth_accounts _should_ update accounts\n    //         );\n    //       } catch (_) {\n    //         // Swallow error\n    //       }\n    //     }\n    //   }\n    //   if (\"selectedAddress\" in state && this.selectedAddress !== state.selectedAddress) {\n    //     try {\n    //       this._rpcRequest(\n    //         { method: \"eth_accounts\", params: [] },\n    //         NOOP,\n    //         true // indicating that eth_accounts _should_ update accounts\n    //       );\n    //     } catch (_) {\n    //       // Swallow error\n    //     }\n    //   }\n    //   // Emit chainChanged event on chain change\n    //   if (\"chainId\" in state && state.chainId !== this.chainId) {\n    //     this.chainId = state.chainId || null;\n    //     this.emit(\"chainChanged\", this.chainId);\n    //     // indicate that we've connected, for EIP-1193 compliance\n    //     // we do this here so that iframe can initialize\n    //     if (!this._state.hasEmittedConnection) {\n    //       this._handleConnect(this.chainId);\n    //       this._state.hasEmittedConnection = true;\n    //     }\n    //   }\n    //   // Emit networkChanged event on network change\n    //   if (\"networkVersion\" in state && state.networkVersion !== this.networkVersion) {\n    //     this.networkVersion = state.networkVersion || null;\n    //     this.emit(\"networkChanged\", this.networkVersion);\n    //   }\n    // });\n\n    pump__WEBPACK_IMPORTED_MODULE_9___default()(mux.createStream(\"publicConfig\"), (0,_metamask_obs_store__WEBPACK_IMPORTED_MODULE_5__.storeAsStream)(this._publicConfigStore), // RPC requests should still work if only this stream fails\n    logStreamDisconnectWarning.bind(this, \"MetaMask PublicConfigStore\")); // ignore phishing warning message (handled elsewhere)\n\n    mux.ignoreStream(\"phishing\"); // setup own event listeners\n    // EIP-1193 connect\n\n    this.on(\"connect\", () => {\n      this._state.isConnected = true;\n    }); // connect to async provider\n\n    const jsonRpcConnection = (0,_toruslabs_openlogin_jrpc__WEBPACK_IMPORTED_MODULE_3__.createStreamMiddleware)();\n    pump__WEBPACK_IMPORTED_MODULE_9___default()(jsonRpcConnection.stream, mux.createStream(jsonRpcStreamName), jsonRpcConnection.stream, this._handleStreamDisconnect.bind(this, \"MetaMask RpcProvider\")); // handle RPC requests via dapp-side rpc engine\n\n    const rpcEngine = new _toruslabs_openlogin_jrpc__WEBPACK_IMPORTED_MODULE_3__.JRPCEngine();\n    rpcEngine.push((0,_toruslabs_openlogin_jrpc__WEBPACK_IMPORTED_MODULE_3__.createIdRemapMiddleware)());\n    rpcEngine.push(createErrorMiddleware());\n    rpcEngine.push(jsonRpcConnection.middleware);\n    this._rpcEngine = rpcEngine; // json rpc notification listener\n\n    jsonRpcConnection.events.on(\"notification\", payload => {\n      const {\n        method,\n        params\n      } = payload;\n\n      if (method === \"wallet_accountsChanged\") {\n        this._handleAccountsChanged(params);\n      } else if (method === \"wallet_unlockStateChanged\") {\n        this._handleUnlockStateChanged(params);\n      } else if (method === \"wallet_chainChanged\") {\n        this._handleChainChanged(params);\n      } else if (EMITTED_NOTIFICATIONS.includes(payload.method)) {\n        // EIP 1193 subscriptions, per eth-json-rpc-filters/subscriptionManager\n        this.emit(\"data\", payload); // deprecated\n\n        this.emit(\"notification\", params.result);\n        this.emit(\"message\", {\n          type: method,\n          data: params\n        });\n      } // Backward compatibility for older non EIP 1193 subscriptions\n      // this.emit('data', null, payload)\n\n    });\n  }\n\n  get publicConfigStore() {\n    if (!this._sentWarnings.publicConfigStore) {\n      log.warn(messages.warnings.publicConfigStore);\n      this._sentWarnings.publicConfigStore = true;\n    }\n\n    return this._publicConfigStore;\n  }\n  /**\n   * Returns whether the inpage provider is connected to Torus.\n   */\n\n\n  isConnected() {\n    return this._state.isConnected;\n  }\n  /**\n   * Submits an RPC request for the given method, with the given params.\n   * Resolves with the result of the method call, or rejects on error.\n   *\n   * @param args - The RPC request arguments.\n   * @returns A Promise that resolves with the result of the RPC method,\n   * or rejects if an error is encountered.\n   */\n\n\n  async request(args) {\n    if (!args || typeof args !== \"object\" || Array.isArray(args)) {\n      throw eth_rpc_errors__WEBPACK_IMPORTED_MODULE_6__.ethErrors.rpc.invalidRequest({\n        message: messages.errors.invalidRequestArgs(),\n        data: args\n      });\n    }\n\n    const {\n      method,\n      params\n    } = args;\n\n    if (typeof method !== \"string\" || method.length === 0) {\n      throw eth_rpc_errors__WEBPACK_IMPORTED_MODULE_6__.ethErrors.rpc.invalidRequest({\n        message: messages.errors.invalidRequestMethod(),\n        data: args\n      });\n    }\n\n    if (params !== undefined && !Array.isArray(params) && (typeof params !== \"object\" || params === null)) {\n      throw eth_rpc_errors__WEBPACK_IMPORTED_MODULE_6__.ethErrors.rpc.invalidRequest({\n        message: messages.errors.invalidRequestParams(),\n        data: args\n      });\n    }\n\n    return new Promise((resolve, reject) => {\n      this._rpcRequest({\n        method,\n        params\n      }, getRpcPromiseCallback(resolve, reject));\n    });\n  }\n  /**\n   * Submits an RPC request per the given JSON-RPC request object.\n   *\n   * @param payload - The RPC request object.\n   * @param cb - The callback function.\n   */\n\n\n  sendAsync(payload, callback) {\n    this._rpcRequest(payload, callback);\n  }\n  /**\n   * We override the following event methods so that we can warn consumers\n   * about deprecated events:\n   *   addListener, on, once, prependListener, prependOnceListener\n   */\n\n\n  addListener(eventName, listener) {\n    this._warnOfDeprecation(eventName);\n\n    return super.addListener(eventName, listener);\n  }\n\n  on(eventName, listener) {\n    this._warnOfDeprecation(eventName);\n\n    return super.on(eventName, listener);\n  }\n\n  once(eventName, listener) {\n    this._warnOfDeprecation(eventName);\n\n    return super.once(eventName, listener);\n  }\n\n  prependListener(eventName, listener) {\n    this._warnOfDeprecation(eventName);\n\n    return super.prependListener(eventName, listener);\n  }\n\n  prependOnceListener(eventName, listener) {\n    this._warnOfDeprecation(eventName);\n\n    return super.prependOnceListener(eventName, listener);\n  } // Private Methods\n  //= ===================\n\n  /**\n   * Constructor helper.\n   * Populates initial state by calling 'wallet_getProviderState' and emits\n   * necessary events.\n   */\n\n\n  async _initializeState() {\n    try {\n      const {\n        accounts,\n        chainId,\n        isUnlocked,\n        networkVersion\n      } = await this.request({\n        method: \"wallet_getProviderState\"\n      }); // indicate that we've connected, for EIP-1193 compliance\n\n      this.emit(\"connect\", {\n        chainId\n      });\n\n      this._handleChainChanged({\n        chainId,\n        networkVersion\n      });\n\n      this._handleUnlockStateChanged({\n        accounts,\n        isUnlocked\n      });\n\n      this._handleAccountsChanged(accounts);\n    } catch (error) {\n      log.error(\"MetaMask: Failed to get initial state. Please report this bug.\", error);\n    } finally {\n      log.info(\"initialized state\");\n      this._state.initialized = true;\n      this.emit(\"_initialized\");\n    }\n  }\n  /**\n   * Internal RPC method. Forwards requests to background via the RPC engine.\n   * Also remap ids inbound and outbound.\n   *\n   * @param payload - The RPC request object.\n   * @param callback - The consumer's callback.\n   * @param isInternal - false - Whether the request is internal.\n   */\n\n\n  _rpcRequest(payload, callback) {\n    let isInternal = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    let cb = callback;\n    const _payload = payload;\n\n    if (!Array.isArray(_payload)) {\n      if (!_payload.jsonrpc) {\n        _payload.jsonrpc = \"2.0\";\n      }\n\n      if (_payload.method === \"eth_accounts\" || _payload.method === \"eth_requestAccounts\") {\n        // handle accounts changing\n        cb = (err, res) => {\n          this._handleAccountsChanged(res.result || [], _payload.method === \"eth_accounts\", isInternal);\n\n          callback(err, res);\n        };\n      } else if (_payload.method === \"wallet_getProviderState\") {\n        this._rpcEngine.handle(payload, cb);\n\n        return;\n      }\n    }\n\n    this.tryPreopenHandle(_payload, cb);\n  }\n\n  send(methodOrPayload, callbackOrArgs) {\n    if (!this._sentWarnings.send) {\n      log.warn(messages.warnings.sendDeprecation);\n      this._sentWarnings.send = true;\n    }\n\n    if (typeof methodOrPayload === \"string\" && (!callbackOrArgs || Array.isArray(callbackOrArgs))) {\n      return new Promise((resolve, reject) => {\n        try {\n          this._rpcRequest({\n            method: methodOrPayload,\n            params: callbackOrArgs\n          }, getRpcPromiseCallback(resolve, reject, false));\n        } catch (error) {\n          reject(error);\n        }\n      });\n    }\n\n    if (methodOrPayload && typeof methodOrPayload === \"object\" && typeof callbackOrArgs === \"function\") {\n      return this._rpcRequest(methodOrPayload, callbackOrArgs);\n    }\n\n    return this._sendSync(methodOrPayload);\n  }\n  /**\n   * DEPRECATED.\n   * Internal backwards compatibility method, used in send.\n   */\n\n\n  _sendSync(payload) {\n    let result;\n\n    switch (payload.method) {\n      case \"eth_accounts\":\n        result = this.selectedAddress ? [this.selectedAddress] : [];\n        break;\n\n      case \"eth_coinbase\":\n        result = this.selectedAddress || null;\n        break;\n\n      case \"eth_uninstallFilter\":\n        this._rpcRequest(payload, NOOP);\n\n        result = true;\n        break;\n\n      case \"net_version\":\n        result = this.networkVersion || null;\n        break;\n\n      default:\n        throw new Error(messages.errors.unsupportedSync(payload.method));\n    }\n\n    return {\n      id: payload.id,\n      jsonrpc: payload.jsonrpc,\n      result\n    };\n  }\n  /**\n   * When the provider becomes connected, updates internal state and emits\n   * required events. Idempotent.\n   *\n   * @param chainId - The ID of the newly connected chain.\n   * emits MetaMaskInpageProvider#connect\n   */\n\n\n  _handleConnect(chainId) {\n    if (!this._state.isConnected) {\n      this._state.isConnected = true;\n      this.emit(\"connect\", {\n        chainId\n      });\n      log.debug(messages.info.connected(chainId));\n    }\n  }\n  /**\n   * When the provider becomes disconnected, updates internal state and emits\n   * required events. Idempotent with respect to the isRecoverable parameter.\n   *\n   * Error codes per the CloseEvent status codes as required by EIP-1193:\n   * https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent#Status_codes\n   *\n   * @param isRecoverable - Whether the disconnection is recoverable.\n   * @param errorMessage - A custom error message.\n   * emits MetaMaskInpageProvider#disconnect\n   */\n\n\n  _handleDisconnect(isRecoverable, errorMessage) {\n    if (this._state.isConnected || !this._state.isPermanentlyDisconnected && !isRecoverable) {\n      this._state.isConnected = false;\n      let error;\n\n      if (isRecoverable) {\n        error = new eth_rpc_errors__WEBPACK_IMPORTED_MODULE_6__.EthereumRpcError(1013, // Try again later\n        errorMessage || messages.errors.disconnected());\n        log.debug(error);\n      } else {\n        error = new eth_rpc_errors__WEBPACK_IMPORTED_MODULE_6__.EthereumRpcError(1011, // Internal error\n        errorMessage || messages.errors.permanentlyDisconnected());\n        log.error(error);\n        this.chainId = null;\n        this._state.accounts = null;\n        this.selectedAddress = null;\n        this._state.isUnlocked = false;\n        this._state.isPermanentlyDisconnected = true;\n      }\n\n      this.emit(\"disconnect\", error);\n    }\n  }\n  /**\n   * Called when connection is lost to critical streams.\n   *\n   * emits MetamaskInpageProvider#disconnect\n   */\n\n\n  _handleStreamDisconnect(streamName, error) {\n    logStreamDisconnectWarning(streamName, error, this);\n\n    this._handleDisconnect(false, error ? error.message : undefined);\n  }\n  /**\n   * Called when accounts may have changed.\n   */\n\n\n  _handleAccountsChanged(accounts) {\n    let isEthAccounts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    let isInternal = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    // defensive programming\n    let finalAccounts = accounts;\n\n    if (!Array.isArray(finalAccounts)) {\n      log.error(\"MetaMask: Received non-array accounts parameter. Please report this bug.\", finalAccounts);\n      finalAccounts = [];\n    }\n\n    for (const account of accounts) {\n      if (typeof account !== \"string\") {\n        log.error(\"MetaMask: Received non-string account. Please report this bug.\", accounts);\n        finalAccounts = [];\n        break;\n      }\n    } // emit accountsChanged if anything about the accounts array has changed\n\n\n    if (!fast_deep_equal__WEBPACK_IMPORTED_MODULE_7___default()(this._state.accounts, finalAccounts)) {\n      // we should always have the correct accounts even before eth_accounts\n      // returns, except in cases where isInternal is true\n      if (isEthAccounts && Array.isArray(this._state.accounts) && this._state.accounts.length > 0 && !isInternal) {\n        log.error('MetaMask: \"eth_accounts\" unexpectedly updated accounts. Please report this bug.', finalAccounts);\n      }\n\n      this._state.accounts = finalAccounts;\n      this.emit(\"accountsChanged\", finalAccounts);\n    } // handle selectedAddress\n\n\n    if (this.selectedAddress !== finalAccounts[0]) {\n      this.selectedAddress = finalAccounts[0] || null;\n    }\n  }\n  /**\n   * Upon receipt of a new chainId and networkVersion, emits corresponding\n   * events and sets relevant public state.\n   * Does nothing if neither the chainId nor the networkVersion are different\n   * from existing values.\n   *\n   * emits MetamaskInpageProvider#chainChanged\n   * @param networkInfo - An object with network info.\n   */\n\n\n  _handleChainChanged() {\n    let {\n      chainId,\n      networkVersion\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    if (!chainId || !networkVersion) {\n      log.error(\"MetaMask: Received invalid network parameters. Please report this bug.\", {\n        chainId,\n        networkVersion\n      });\n      return;\n    }\n\n    if (networkVersion === \"loading\") {\n      this._handleDisconnect(true);\n    } else {\n      this._handleConnect(chainId);\n\n      if (chainId !== this.chainId) {\n        this.chainId = chainId;\n\n        if (this._state.initialized) {\n          this.emit(\"chainChanged\", this.chainId);\n        }\n      }\n    }\n  }\n  /**\n   * Upon receipt of a new isUnlocked state, sets relevant public state.\n   * Calls the accounts changed handler with the received accounts, or an empty\n   * array.\n   *\n   * Does nothing if the received value is equal to the existing value.\n   * There are no lock/unlock events.\n   *\n   * @param opts - Options bag.\n   */\n\n\n  _handleUnlockStateChanged() {\n    let {\n      accounts,\n      isUnlocked\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    if (typeof isUnlocked !== \"boolean\") {\n      log.error(\"MetaMask: Received invalid isUnlocked parameter. Please report this bug.\", {\n        isUnlocked\n      });\n      return;\n    }\n\n    if (isUnlocked !== this._state.isUnlocked) {\n      this._state.isUnlocked = isUnlocked;\n\n      this._handleAccountsChanged(accounts || []);\n    }\n  }\n  /**\n   * Warns of deprecation for the given event, if applicable.\n   */\n\n\n  _warnOfDeprecation(eventName) {\n    if (this._sentWarnings.events[eventName] === false) {\n      log.warn(messages.warnings.events[eventName]);\n      this._sentWarnings.events[eventName] = true;\n    }\n  }\n\n}\n\n(0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(TorusInpageProvider, \"_defaultState\", {\n  accounts: null,\n  isConnected: false,\n  isUnlocked: false,\n  initialized: false,\n  isPermanentlyDisconnected: false,\n  hasEmittedConnection: false\n});\n\nconst defaults = options => ({\n  algorithms: options.algorithms || [\"sha256\"],\n  delimiter: options.delimiter || \" \",\n  full: options.full || false\n}); // Generate list of hashes\n\n\nconst hashes = (options, data) => {\n  const internalHashes = {};\n  options.algorithms.forEach(algorithm => {\n    internalHashes[algorithm] = create_hash__WEBPACK_IMPORTED_MODULE_11___default()(algorithm).update(data, \"utf8\").digest(\"base64\");\n  });\n  return internalHashes;\n}; // Build an integrity string\n\n\nconst integrity = (options, sri) => {\n  let output = \"\"; // Hash list\n\n  output += Object.keys(sri.hashes).map(algorithm => `${algorithm}-${sri.hashes[algorithm]}`).join(options.delimiter);\n  return output;\n};\n\nconst main = (options, data) => {\n  // Defaults\n  const finalOptions = defaults(options);\n  const sri = {\n    hashes: hashes(finalOptions, data),\n    integrity: undefined\n  };\n  sri.integrity = integrity(finalOptions, sri);\n  return finalOptions.full ? sri : sri.integrity;\n};\n\nclass PopupHandler extends events__WEBPACK_IMPORTED_MODULE_12__.EventEmitter {\n  constructor(_ref) {\n    let {\n      url,\n      target,\n      features\n    } = _ref;\n    super();\n\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(this, \"url\", void 0);\n\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(this, \"target\", void 0);\n\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(this, \"features\", void 0);\n\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(this, \"window\", void 0);\n\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(this, \"windowTimer\", void 0);\n\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(this, \"iClosedWindow\", void 0);\n\n    this.url = url;\n    this.target = target || \"_blank\";\n    this.features = features || getPopupFeatures();\n    this.window = undefined;\n    this.windowTimer = undefined;\n    this.iClosedWindow = false;\n\n    this._setupTimer();\n  }\n\n  _setupTimer() {\n    this.windowTimer = Number(setInterval(() => {\n      if (this.window && this.window.closed) {\n        clearInterval(this.windowTimer);\n\n        if (!this.iClosedWindow) {\n          this.emit(\"close\");\n        }\n\n        this.iClosedWindow = false;\n        this.window = undefined;\n      }\n\n      if (this.window === undefined) clearInterval(this.windowTimer);\n    }, 500));\n  }\n\n  open() {\n    var _this$window;\n\n    this.window = window.open(this.url.href, this.target, this.features);\n    if ((_this$window = this.window) !== null && _this$window !== void 0 && _this$window.focus) this.window.focus();\n    return Promise.resolve();\n  }\n\n  close() {\n    this.iClosedWindow = true;\n    if (this.window) this.window.close();\n  }\n\n  redirect(locationReplaceOnRedirect) {\n    if (locationReplaceOnRedirect) {\n      window.location.replace(this.url.href);\n    } else {\n      window.location.href = this.url.href;\n    }\n  }\n\n}\n\n/**\n * Returns whether the given image URL exists\n * @param url - the url of the image\n * @returns - whether the image exists\n */\n\nfunction imgExists(url) {\n  return new Promise((resolve, reject) => {\n    try {\n      const img = document.createElement(\"img\");\n\n      img.onload = () => resolve(true);\n\n      img.onerror = () => resolve(false);\n\n      img.src = url;\n    } catch (e) {\n      reject(e);\n    }\n  });\n}\n/**\n * Extracts a name for the site from the DOM\n */\n\n\nconst getSiteName = window => {\n  const {\n    document\n  } = window;\n  const siteName = document.querySelector('head > meta[property=\"og:site_name\"]');\n\n  if (siteName) {\n    return siteName.content;\n  }\n\n  const metaTitle = document.querySelector('head > meta[name=\"title\"]');\n\n  if (metaTitle) {\n    return metaTitle.content;\n  }\n\n  if (document.title && document.title.length > 0) {\n    return document.title;\n  }\n\n  return window.location.hostname;\n};\n/**\n * Extracts an icon for the site from the DOM\n */\n\n\nasync function getSiteIcon(window) {\n  const {\n    document\n  } = window; // Use the site's favicon if it exists\n\n  let icon = document.querySelector('head > link[rel=\"shortcut icon\"]');\n\n  if (icon && (await imgExists(icon.href))) {\n    return icon.href;\n  } // Search through available icons in no particular order\n\n\n  icon = Array.from(document.querySelectorAll('head > link[rel=\"icon\"]')).find(_icon => Boolean(_icon.href));\n\n  if (icon && (await imgExists(icon.href))) {\n    return icon.href;\n  }\n\n  return null;\n}\n/**\n * Gets site metadata and returns it\n *\n */\n\n\nconst getSiteMetadata = async () => ({\n  name: getSiteName(window),\n  icon: await getSiteIcon(window)\n});\n/**\n * Sends site metadata over an RPC request.\n */\n\n\nasync function sendSiteMetadata(engine) {\n  try {\n    const domainMetadata = await getSiteMetadata(); // call engine.handle directly to avoid normal RPC request handling\n\n    engine.handle({\n      jsonrpc: \"2.0\",\n      id: getPreopenInstanceId(),\n      method: \"wallet_sendDomainMetadata\",\n      params: domainMetadata\n    }, NOOP);\n  } catch (error) {\n    log.error({\n      message: messages.errors.sendSiteMetadata(),\n      originalError: error\n    });\n  }\n}\n\nconst _excluded = [\"host\", \"chainId\", \"networkName\"];\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nconst defaultVerifiers = {\n  [LOGIN_PROVIDER.GOOGLE]: true,\n  [LOGIN_PROVIDER.FACEBOOK]: true,\n  [LOGIN_PROVIDER.REDDIT]: true,\n  [LOGIN_PROVIDER.TWITCH]: true,\n  [LOGIN_PROVIDER.DISCORD]: true\n};\nconst iframeIntegrity = \"sha384-gBoLisZoICU+G5W0Fuuawddb4Ye/F7ZtmRPRdzUnPXC/PqK9E5nbGY7WXv2uJwY0\";\nconst expectedCacheControlHeader = \"max-age=3600\";\nconst UNSAFE_METHODS = [\"eth_sendTransaction\", \"eth_signTypedData\", \"eth_signTypedData_v3\", \"eth_signTypedData_v4\", \"personal_sign\", \"eth_getEncryptionPublicKey\", \"eth_decrypt\"]; // preload for iframe doesn't work https://bugs.chromium.org/p/chromium/issues/detail?id=593267\n\n(async function preLoadIframe() {\n  try {\n    if (typeof document === \"undefined\") return;\n    const torusIframeHtml = document.createElement(\"link\");\n    const {\n      torusUrl\n    } = await getTorusUrl(\"production\", {\n      check: false,\n      hash: iframeIntegrity,\n      version: \"\"\n    });\n    torusIframeHtml.href = `${torusUrl}/popup`;\n    torusIframeHtml.crossOrigin = \"anonymous\";\n    torusIframeHtml.type = \"text/html\";\n    torusIframeHtml.rel = \"prefetch\";\n\n    if (torusIframeHtml.relList && torusIframeHtml.relList.supports) {\n      if (torusIframeHtml.relList.supports(\"prefetch\")) {\n        document.head.appendChild(torusIframeHtml);\n      }\n    }\n  } catch (error) {\n    log.warn(error);\n  }\n})();\n\nclass Torus {\n  constructor() {\n    let {\n      buttonPosition = BUTTON_POSITION.BOTTOM_LEFT,\n      buttonSize = 56,\n      modalZIndex = 99999,\n      apiKey = \"torus-default\"\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(this, \"buttonPosition\", BUTTON_POSITION.BOTTOM_LEFT);\n\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(this, \"buttonSize\", void 0);\n\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(this, \"torusUrl\", void 0);\n\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(this, \"torusIframe\", void 0);\n\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(this, \"styleLink\", void 0);\n\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(this, \"isLoggedIn\", void 0);\n\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(this, \"isInitialized\", void 0);\n\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(this, \"torusWidgetVisibility\", void 0);\n\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(this, \"torusAlert\", void 0);\n\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(this, \"apiKey\", void 0);\n\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(this, \"modalZIndex\", void 0);\n\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(this, \"alertZIndex\", void 0);\n\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(this, \"torusAlertContainer\", void 0);\n\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(this, \"isIframeFullScreen\", void 0);\n\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(this, \"whiteLabel\", void 0);\n\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(this, \"requestedVerifier\", void 0);\n\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(this, \"currentVerifier\", void 0);\n\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(this, \"embedTranslations\", void 0);\n\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(this, \"ethereum\", void 0);\n\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(this, \"provider\", void 0);\n\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(this, \"communicationMux\", void 0);\n\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(this, \"isLoginCallback\", void 0);\n\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(this, \"paymentProviders\", configuration.paymentProviders);\n\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(this, \"loginHint\", \"\");\n\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(this, \"useWalletConnect\", void 0);\n\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(this, \"isCustomLogin\", false);\n\n    this.buttonPosition = buttonPosition;\n    this.buttonSize = buttonSize;\n    this.torusUrl = \"\";\n    this.isLoggedIn = false; // ethereum.enable working\n\n    this.isInitialized = false; // init done\n\n    this.torusWidgetVisibility = true;\n    this.requestedVerifier = \"\";\n    this.currentVerifier = \"\"; // this.nodeDetailManager = new NodeDetailManager();\n    // this.torusJs = new TorusJs({\n    //   metadataHost: \"https://metadata.tor.us\",\n    //   allowHost: \"https://signer.tor.us/api/allow\",\n    //   network: \"mainnet\",\n    // });\n\n    this.apiKey = apiKey;\n    (0,_toruslabs_http_helpers__WEBPACK_IMPORTED_MODULE_2__.setAPIKey)(apiKey);\n    this.modalZIndex = modalZIndex;\n    this.alertZIndex = modalZIndex + 1000;\n    this.isIframeFullScreen = false;\n  }\n\n  async init() {\n    let {\n      buildEnv = TORUS_BUILD_ENV.PRODUCTION,\n      enableLogging = false,\n      // deprecated: use loginConfig instead\n      enabledVerifiers = defaultVerifiers,\n      network = {\n        host: \"mainnet\",\n        chainId: null,\n        networkName: \"\",\n        blockExplorer: \"\",\n        ticker: \"\",\n        tickerName: \"\"\n      },\n      loginConfig = {},\n      showTorusButton = true,\n      integrity = {\n        check: false,\n        hash: iframeIntegrity,\n        version: \"\"\n      },\n      whiteLabel,\n      skipTKey = false,\n      useWalletConnect = false,\n      mfaLevel = \"default\"\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    if (this.isInitialized) throw new Error(\"Already initialized\");\n    const {\n      torusUrl,\n      logLevel\n    } = await getTorusUrl(buildEnv, integrity);\n    log.info(torusUrl, \"url loaded\");\n    this.torusUrl = torusUrl;\n    this.whiteLabel = whiteLabel;\n    this.useWalletConnect = useWalletConnect;\n    this.isCustomLogin = !!(loginConfig && Object.keys(loginConfig).length > 0) || !!(whiteLabel && Object.keys(whiteLabel).length > 0);\n    log.setDefaultLevel(logLevel);\n    if (enableLogging) log.enableAll();else log.disableAll();\n    this.torusWidgetVisibility = showTorusButton;\n    const torusIframeUrl = new URL(torusUrl);\n    if (torusIframeUrl.pathname.endsWith(\"/\")) torusIframeUrl.pathname += \"popup\";else torusIframeUrl.pathname += \"/popup\";\n    torusIframeUrl.hash = `#isCustomLogin=${this.isCustomLogin}`; // Iframe code\n\n    this.torusIframe = htmlToElement(`<iframe\n        id=\"torusIframe\"\n        allow=${useWalletConnect ? \"camera\" : \"\"}\n        class=\"torusIframe\"\n        src=\"${torusIframeUrl.href}\"\n        style=\"display: none; position: fixed; top: 0; right: 0; width: 100%; color-scheme: none;\n        height: 100%; border: none; border-radius: 0; z-index: ${this.modalZIndex}\"\n      ></iframe>`);\n    this.torusAlertContainer = htmlToElement('<div id=\"torusAlertContainer\"></div>');\n    this.torusAlertContainer.style.display = \"none\";\n    this.torusAlertContainer.style.setProperty(\"z-index\", this.alertZIndex.toString());\n    const link = window.document.createElement(\"link\");\n    link.setAttribute(\"rel\", \"stylesheet\");\n    link.setAttribute(\"type\", \"text/css\");\n    link.setAttribute(\"href\", `${torusUrl}/css/widget.css`);\n    this.styleLink = link;\n    const {\n      defaultLanguage = getUserLanguage(),\n      customTranslations = {}\n    } = this.whiteLabel || {};\n    const mergedTranslations = lodash_merge__WEBPACK_IMPORTED_MODULE_4___default()(configuration.translations, customTranslations);\n    const languageTranslations = mergedTranslations[defaultLanguage] || configuration.translations[getUserLanguage()];\n    this.embedTranslations = languageTranslations.embed;\n\n    const handleSetup = async () => {\n      await documentReady();\n      return new Promise((resolve, reject) => {\n        this.torusIframe.onload = async () => {\n          // only do this if iframe is not full screen\n          this._setupWeb3();\n\n          const initStream = this.communicationMux.getStream(\"init_stream\");\n          initStream.on(\"data\", chunk => {\n            const {\n              name,\n              data,\n              error\n            } = chunk;\n\n            if (name === \"init_complete\" && data.success) {\n              // resolve promise\n              this.isInitialized = true;\n\n              this._displayIframe(this.isIframeFullScreen);\n\n              resolve(undefined);\n            } else if (error) {\n              reject(new Error(error));\n            }\n          });\n          initStream.write({\n            name: \"init_stream\",\n            data: {\n              enabledVerifiers,\n              loginConfig,\n              whiteLabel: this.whiteLabel,\n              buttonPosition: this.buttonPosition,\n              buttonSize: this.buttonSize,\n              torusWidgetVisibility: this.torusWidgetVisibility,\n              apiKey: this.apiKey,\n              skipTKey,\n              network,\n              mfaLevel\n            }\n          });\n        };\n\n        window.document.head.appendChild(this.styleLink);\n        window.document.body.appendChild(this.torusIframe);\n        window.document.body.appendChild(this.torusAlertContainer);\n      });\n    };\n\n    if (buildEnv === \"production\" && integrity.check) {\n      // hacky solution to check for iframe integrity\n      const fetchUrl = `${torusUrl}/popup`;\n      const resp = await fetch(fetchUrl, {\n        cache: \"reload\"\n      });\n\n      if (resp.headers.get(\"Cache-Control\") !== expectedCacheControlHeader) {\n        throw new Error(`Unexpected Cache-Control headers, got ${resp.headers.get(\"Cache-Control\")}`);\n      }\n\n      const response = await resp.text();\n      const calculatedIntegrity = main({\n        algorithms: [\"sha384\"]\n      }, response);\n      log.info(calculatedIntegrity, \"integrity\");\n\n      if (calculatedIntegrity === integrity.hash) {\n        await handleSetup();\n      } else {\n        this.clearInit();\n        throw new Error(\"Integrity check failed\");\n      }\n    } else {\n      await handleSetup();\n    }\n\n    return undefined;\n  }\n\n  login() {\n    let {\n      verifier = \"\",\n      login_hint: loginHint = \"\"\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    if (!this.isInitialized) throw new Error(\"Call init() first\");\n    this.requestedVerifier = verifier;\n    this.loginHint = loginHint;\n    return this.ethereum.enable();\n  }\n\n  logout() {\n    return new Promise((resolve, reject) => {\n      if (!this.isLoggedIn) {\n        reject(new Error(\"User has not logged in yet\"));\n        return;\n      }\n\n      const logOutStream = this.communicationMux.getStream(\"logout\");\n      logOutStream.write({\n        name: \"logOut\"\n      });\n      const statusStream = this.communicationMux.getStream(\"status\");\n\n      const statusStreamHandler = status => {\n        if (!status.loggedIn) {\n          this.isLoggedIn = false;\n          this.currentVerifier = \"\";\n          this.requestedVerifier = \"\";\n          resolve();\n        } else reject(new Error(\"Some Error Occured\"));\n      };\n\n      handleStream(statusStream, \"data\", statusStreamHandler);\n    });\n  }\n\n  async cleanUp() {\n    if (this.isLoggedIn) {\n      await this.logout();\n    }\n\n    this.clearInit();\n  }\n\n  clearInit() {\n    function isElement(element) {\n      return element instanceof Element || element instanceof HTMLDocument;\n    }\n\n    if (isElement(this.styleLink) && window.document.body.contains(this.styleLink)) {\n      this.styleLink.remove();\n      this.styleLink = undefined;\n    }\n\n    if (isElement(this.torusIframe) && window.document.body.contains(this.torusIframe)) {\n      this.torusIframe.remove();\n      this.torusIframe = undefined;\n    }\n\n    if (isElement(this.torusAlertContainer) && window.document.body.contains(this.torusAlertContainer)) {\n      this.torusAlert = undefined;\n      this.torusAlertContainer.remove();\n      this.torusAlertContainer = undefined;\n    }\n\n    this.isInitialized = false;\n  }\n\n  hideTorusButton() {\n    this.torusWidgetVisibility = false;\n\n    this._sendWidgetVisibilityStatus(false);\n\n    this._displayIframe();\n  }\n\n  showTorusButton() {\n    this.torusWidgetVisibility = true;\n\n    this._sendWidgetVisibilityStatus(true);\n\n    this._displayIframe();\n  }\n\n  setProvider(_ref) {\n    let {\n      host = \"mainnet\",\n      chainId = null,\n      networkName = \"\"\n    } = _ref,\n        rest = (0,_babel_runtime_helpers_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(_ref, _excluded);\n\n    return new Promise((resolve, reject) => {\n      const providerChangeStream = this.communicationMux.getStream(\"provider_change\");\n\n      const handler = chunk => {\n        const {\n          err,\n          success\n        } = chunk.data;\n        log.info(chunk);\n\n        if (err) {\n          reject(err);\n        } else if (success) {\n          resolve();\n        } else reject(new Error(\"some error occured\"));\n      };\n\n      handleStream(providerChangeStream, \"data\", handler);\n      const preopenInstanceId = getPreopenInstanceId();\n\n      this._handleWindow(preopenInstanceId, {\n        target: \"_blank\",\n        features: FEATURES_PROVIDER_CHANGE_WINDOW\n      });\n\n      providerChangeStream.write({\n        name: \"show_provider_change\",\n        data: {\n          network: _objectSpread({\n            host,\n            chainId,\n            networkName\n          }, rest),\n          preopenInstanceId,\n          override: false\n        }\n      });\n    });\n  }\n\n  showWallet(path) {\n    let params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const showWalletStream = this.communicationMux.getStream(\"show_wallet\");\n    const finalPath = path ? `/${path}` : \"\";\n    showWalletStream.write({\n      name: \"show_wallet\",\n      data: {\n        path: finalPath\n      }\n    });\n\n    const showWalletHandler = chunk => {\n      if (chunk.name === \"show_wallet_instance\") {\n        // Let the error propogate up (hence, no try catch)\n        const {\n          instanceId\n        } = chunk.data;\n        const finalUrl = new URL(`${this.torusUrl}/wallet${finalPath}`); // Using URL constructor to prevent js injection and allow parameter validation.!\n\n        finalUrl.searchParams.append(\"integrity\", \"true\");\n        finalUrl.searchParams.append(\"instanceId\", instanceId);\n        Object.keys(params).forEach(x => {\n          finalUrl.searchParams.append(x, params[x]);\n        });\n        finalUrl.hash = `#isCustomLogin=${this.isCustomLogin}`;\n        const walletWindow = new PopupHandler({\n          url: finalUrl,\n          features: FEATURES_DEFAULT_WALLET_WINDOW\n        });\n        walletWindow.open();\n      }\n    };\n\n    handleStream(showWalletStream, \"data\", showWalletHandler);\n  }\n\n  async getPublicAddress(_ref2) {\n    let {\n      verifier,\n      verifierId,\n      isExtended = false\n    } = _ref2;\n    if (!configuration.supportedVerifierList.includes(verifier) || !WALLET_OPENLOGIN_VERIFIER_MAP[verifier]) throw new Error(\"Unsupported verifier\");\n    const walletVerifier = verifier;\n    const openloginVerifier = WALLET_OPENLOGIN_VERIFIER_MAP[verifier];\n    const url = new URL(`https://api.tor.us/lookup/torus`);\n    url.searchParams.append(\"verifier\", openloginVerifier);\n    url.searchParams.append(\"verifierId\", verifierId);\n    url.searchParams.append(\"walletVerifier\", walletVerifier);\n    url.searchParams.append(\"network\", \"mainnet\");\n    url.searchParams.append(\"isExtended\", isExtended.toString());\n    return (0,_toruslabs_http_helpers__WEBPACK_IMPORTED_MODULE_2__.get)(url.href, {\n      headers: {\n        \"Content-Type\": \"application/json; charset=utf-8\"\n      }\n    }, {\n      useAPIKey: true\n    });\n  }\n\n  getUserInfo(message) {\n    return new Promise((resolve, reject) => {\n      if (this.isLoggedIn) {\n        const userInfoAccessStream = this.communicationMux.getStream(\"user_info_access\");\n        userInfoAccessStream.write({\n          name: \"user_info_access_request\"\n        });\n\n        const userInfoAccessHandler = chunk => {\n          const {\n            name,\n            data: {\n              approved,\n              payload,\n              rejected,\n              newRequest\n            }\n          } = chunk;\n\n          if (name === \"user_info_access_response\") {\n            if (approved) {\n              resolve(payload);\n            } else if (rejected) {\n              reject(new Error(\"User rejected the request\"));\n            } else if (newRequest) {\n              const userInfoStream = this.communicationMux.getStream(\"user_info\");\n\n              const userInfoHandler = handlerChunk => {\n                if (handlerChunk.name === \"user_info_response\") {\n                  if (handlerChunk.data.approved) {\n                    resolve(handlerChunk.data.payload);\n                  } else {\n                    reject(new Error(\"User rejected the request\"));\n                  }\n                }\n              };\n\n              handleStream(userInfoStream, \"data\", userInfoHandler);\n              const preopenInstanceId = getPreopenInstanceId();\n\n              this._handleWindow(preopenInstanceId, {\n                target: \"_blank\",\n                features: FEATURES_PROVIDER_CHANGE_WINDOW\n              });\n\n              userInfoStream.write({\n                name: \"user_info_request\",\n                data: {\n                  message,\n                  preopenInstanceId\n                }\n              });\n            }\n          }\n        };\n\n        handleStream(userInfoAccessStream, \"data\", userInfoAccessHandler);\n      } else reject(new Error(\"User has not logged in yet\"));\n    });\n  }\n\n  initiateTopup(provider, params) {\n    return new Promise((resolve, reject) => {\n      if (this.isInitialized) {\n        const {\n          errors,\n          isValid\n        } = validatePaymentProvider(provider, params);\n\n        if (!isValid) {\n          reject(new Error(JSON.stringify(errors)));\n          return;\n        }\n\n        const topupStream = this.communicationMux.getStream(\"topup\");\n\n        const topupHandler = chunk => {\n          if (chunk.name === \"topup_response\") {\n            if (chunk.data.success) {\n              resolve(chunk.data.success);\n            } else {\n              reject(new Error(chunk.data.error));\n            }\n          }\n        };\n\n        handleStream(topupStream, \"data\", topupHandler);\n        const preopenInstanceId = getPreopenInstanceId();\n\n        this._handleWindow(preopenInstanceId);\n\n        topupStream.write({\n          name: \"topup_request\",\n          data: {\n            provider,\n            params,\n            preopenInstanceId\n          }\n        });\n      } else reject(new Error(\"Torus is not initialized yet\"));\n    });\n  }\n\n  async loginWithPrivateKey(loginParams) {\n    const {\n      privateKey,\n      userInfo\n    } = loginParams;\n    return new Promise((resolve, reject) => {\n      if (this.isInitialized) {\n        if (Buffer.from(privateKey, \"hex\").length !== 32) {\n          reject(new Error(\"Invalid private key, Please provide a 32 byte valid secp25k1 private key\"));\n          return;\n        }\n\n        const loginPrivKeyStream = this.communicationMux.getStream(\"login_with_private_key\");\n\n        const loginHandler = chunk => {\n          if (chunk.name === \"login_with_private_key_response\") {\n            if (chunk.data.success) {\n              resolve(chunk.data.success);\n            } else {\n              reject(new Error(chunk.data.error));\n            }\n          }\n        };\n\n        handleStream(loginPrivKeyStream, \"data\", loginHandler);\n        loginPrivKeyStream.write({\n          name: \"login_with_private_key_request\",\n          data: {\n            privateKey,\n            userInfo\n          }\n        });\n      } else reject(new Error(\"Torus is not initialized yet\"));\n    });\n  }\n\n  async showWalletConnectScanner() {\n    if (!this.useWalletConnect) throw new Error(\"Set `useWalletConnect` as true in init function options to use wallet connect scanner\");\n    return new Promise((resolve, reject) => {\n      if (this.isLoggedIn) {\n        const walletConnectStream = this.communicationMux.getStream(\"wallet_connect_stream\");\n\n        const walletConnectHandler = chunk => {\n          if (chunk.name === \"wallet_connect_stream_res\") {\n            if (chunk.data.success) {\n              resolve(chunk.data.success);\n            } else {\n              reject(new Error(chunk.data.error));\n            }\n\n            this._displayIframe();\n          }\n        };\n\n        handleStream(walletConnectStream, \"data\", walletConnectHandler);\n        walletConnectStream.write({\n          name: \"wallet_connect_stream_req\"\n        });\n\n        this._displayIframe(true);\n      } else reject(new Error(\"User has not logged in yet\"));\n    });\n  }\n\n  _handleWindow(preopenInstanceId) {\n    let {\n      url,\n      target,\n      features\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (preopenInstanceId) {\n      const windowStream = this.communicationMux.getStream(\"window\");\n      const finalUrl = new URL(url || `${this.torusUrl}/redirect?preopenInstanceId=${preopenInstanceId}`);\n      if (finalUrl.hash) finalUrl.hash += `&isCustomLogin=${this.isCustomLogin}`;else finalUrl.hash = `#isCustomLogin=${this.isCustomLogin}`;\n      const handledWindow = new PopupHandler({\n        url: finalUrl,\n        target,\n        features\n      });\n      handledWindow.open();\n\n      if (!handledWindow.window) {\n        this._createPopupBlockAlert(preopenInstanceId, finalUrl.href);\n\n        return;\n      }\n\n      windowStream.write({\n        name: \"opened_window\",\n        data: {\n          preopenInstanceId\n        }\n      });\n\n      const closeHandler = _ref3 => {\n        let {\n          preopenInstanceId: receivedId,\n          close\n        } = _ref3;\n\n        if (receivedId === preopenInstanceId && close) {\n          handledWindow.close();\n          windowStream.removeListener(\"data\", closeHandler);\n        }\n      };\n\n      windowStream.on(\"data\", closeHandler);\n      handledWindow.once(\"close\", () => {\n        windowStream.write({\n          data: {\n            preopenInstanceId,\n            closed: true\n          }\n        });\n        windowStream.removeListener(\"data\", closeHandler);\n      });\n    }\n  }\n\n  _setEmbedWhiteLabel(element) {\n    // Set whitelabel\n    const {\n      theme\n    } = this.whiteLabel || {};\n\n    if (theme) {\n      const {\n        isDark = false,\n        colors = {}\n      } = theme;\n      if (isDark) element.classList.add(\"torus-dark\");\n      if (colors.torusBrand1) element.style.setProperty(\"--torus-brand-1\", colors.torusBrand1);\n      if (colors.torusGray2) element.style.setProperty(\"--torus-gray-2\", colors.torusGray2);\n    }\n  }\n\n  _getLogoUrl() {\n    var _this$whiteLabel, _this$whiteLabel$them;\n\n    let logoUrl = `${this.torusUrl}/images/torus_icon-blue.svg`;\n\n    if ((_this$whiteLabel = this.whiteLabel) !== null && _this$whiteLabel !== void 0 && (_this$whiteLabel$them = _this$whiteLabel.theme) !== null && _this$whiteLabel$them !== void 0 && _this$whiteLabel$them.isDark) {\n      var _this$whiteLabel2;\n\n      logoUrl = ((_this$whiteLabel2 = this.whiteLabel) === null || _this$whiteLabel2 === void 0 ? void 0 : _this$whiteLabel2.logoLight) || logoUrl;\n    } else {\n      var _this$whiteLabel3;\n\n      logoUrl = ((_this$whiteLabel3 = this.whiteLabel) === null || _this$whiteLabel3 === void 0 ? void 0 : _this$whiteLabel3.logoDark) || logoUrl;\n    }\n\n    return logoUrl;\n  }\n\n  _sendWidgetVisibilityStatus(status) {\n    const torusWidgetVisibilityStream = this.communicationMux.getStream(\"torus-widget-visibility\");\n    torusWidgetVisibilityStream.write({\n      data: status\n    });\n  }\n\n  _displayIframe() {\n    let isFull = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    const style = {};\n    const size = this.buttonSize + 14; // 15px padding\n    // set phase\n\n    if (!isFull) {\n      style.display = this.torusWidgetVisibility ? \"block\" : \"none\";\n      style.height = `${size}px`;\n      style.width = `${size}px`;\n\n      switch (this.buttonPosition) {\n        case BUTTON_POSITION.TOP_LEFT:\n          style.top = \"0px\";\n          style.left = \"0px\";\n          style.right = \"auto\";\n          style.bottom = \"auto\";\n          break;\n\n        case BUTTON_POSITION.TOP_RIGHT:\n          style.top = \"0px\";\n          style.right = \"0px\";\n          style.left = \"auto\";\n          style.bottom = \"auto\";\n          break;\n\n        case BUTTON_POSITION.BOTTOM_RIGHT:\n          style.bottom = \"0px\";\n          style.right = \"0px\";\n          style.top = \"auto\";\n          style.left = \"auto\";\n          break;\n\n        case BUTTON_POSITION.BOTTOM_LEFT:\n        default:\n          style.bottom = \"0px\";\n          style.left = \"0px\";\n          style.top = \"auto\";\n          style.right = \"auto\";\n          break;\n      }\n    } else {\n      style.display = \"block\";\n      style.width = \"100%\";\n      style.height = \"100%\";\n      style.top = \"0px\";\n      style.right = \"0px\";\n      style.left = \"0px\";\n      style.bottom = \"0px\";\n    }\n\n    Object.assign(this.torusIframe.style, style);\n    this.isIframeFullScreen = isFull;\n  }\n\n  _setupWeb3() {\n    log.info(\"setupWeb3 running\"); // setup background connection\n\n    const metamaskStream = new _toruslabs_openlogin_jrpc__WEBPACK_IMPORTED_MODULE_3__.BasePostMessageStream({\n      name: \"embed_metamask\",\n      target: \"iframe_metamask\",\n      targetWindow: this.torusIframe.contentWindow,\n      targetOrigin: new URL(this.torusUrl).origin\n    }); // Due to compatibility reasons, we should not set up multiplexing on window.metamaskstream\n    // because the MetamaskInpageProvider also attempts to do so.\n    // We create another LocalMessageDuplexStream for communication between dapp <> iframe\n\n    const communicationStream = new _toruslabs_openlogin_jrpc__WEBPACK_IMPORTED_MODULE_3__.BasePostMessageStream({\n      name: \"embed_comm\",\n      target: \"iframe_comm\",\n      targetWindow: this.torusIframe.contentWindow,\n      targetOrigin: new URL(this.torusUrl).origin\n    }); // Backward compatibility with Gotchi :)\n    // window.metamaskStream = this.communicationStream\n    // compose the inpage provider\n\n    const inpageProvider = new TorusInpageProvider(metamaskStream); // detect eth_requestAccounts and pipe to enable for now\n\n    const detectAccountRequestPrototypeModifier = m => {\n      const originalMethod = inpageProvider[m];\n\n      inpageProvider[m] = function providerFunc(method) {\n        if (method && method === \"eth_requestAccounts\") {\n          return inpageProvider.enable();\n        }\n\n        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n          args[_key - 1] = arguments[_key];\n        }\n\n        return originalMethod.apply(this, [method, ...args]);\n      };\n    };\n\n    detectAccountRequestPrototypeModifier(\"send\");\n    detectAccountRequestPrototypeModifier(\"sendAsync\");\n\n    inpageProvider.enable = () => {\n      return new Promise((resolve, reject) => {\n        // If user is already logged in, we assume they have given access to the website\n        inpageProvider.sendAsync({\n          jsonrpc: \"2.0\",\n          id: getPreopenInstanceId(),\n          method: \"eth_requestAccounts\",\n          params: []\n        }, (err, response) => {\n          const {\n            result: res\n          } = response || {};\n\n          if (err) {\n            setTimeout(() => {\n              reject(err);\n            }, 50);\n          } else if (Array.isArray(res) && res.length > 0) {\n            // If user is already rehydrated, resolve this\n            // else wait for something to be written to status stream\n            const handleLoginCb = () => {\n              if (this.requestedVerifier !== \"\" && this.currentVerifier !== this.requestedVerifier) {\n                const {\n                  requestedVerifier\n                } = this; // eslint-disable-next-line promise/no-promise-in-callback\n\n                this.logout() // eslint-disable-next-line promise/always-return\n                .then(_ => {\n                  this.requestedVerifier = requestedVerifier;\n\n                  this._showLoginPopup(true, resolve, reject);\n                }).catch(error => reject(error));\n              } else {\n                resolve(res);\n              }\n            };\n\n            if (this.isLoggedIn) {\n              handleLoginCb();\n            } else {\n              this.isLoginCallback = handleLoginCb;\n            }\n          } else {\n            // set up listener for login\n            this._showLoginPopup(true, resolve, reject);\n          }\n        });\n      });\n    };\n\n    inpageProvider.tryPreopenHandle = (payload, cb) => {\n      const _payload = payload;\n\n      if (!Array.isArray(_payload) && UNSAFE_METHODS.includes(_payload.method)) {\n        const preopenInstanceId = getPreopenInstanceId();\n\n        this._handleWindow(preopenInstanceId, {\n          target: \"_blank\",\n          features: FEATURES_CONFIRM_WINDOW\n        });\n\n        _payload.preopenInstanceId = preopenInstanceId;\n      }\n\n      inpageProvider._rpcEngine.handle(_payload, cb);\n    }; // Work around for web3@1.0 deleting the bound `sendAsync` but not the unbound\n    // `sendAsync` method on the prototype, causing `this` reference issues with drizzle\n\n\n    const proxiedInpageProvider = new Proxy(inpageProvider, {\n      // straight up lie that we deleted the property so that it doesnt\n      // throw an error in strict mode\n      deleteProperty: () => true\n    });\n    this.ethereum = proxiedInpageProvider;\n    const communicationMux = (0,_toruslabs_openlogin_jrpc__WEBPACK_IMPORTED_MODULE_3__.setupMultiplex)(communicationStream);\n    this.communicationMux = communicationMux;\n    const windowStream = communicationMux.getStream(\"window\");\n    windowStream.on(\"data\", chunk => {\n      if (chunk.name === \"create_window\") {\n        // url is the url we need to open\n        // we can pass the final url upfront so that it removes the step of redirecting to /redirect and waiting for finalUrl\n        this._createPopupBlockAlert(chunk.data.preopenInstanceId, chunk.data.url);\n      }\n    }); // show torus widget if button clicked\n\n    const widgetStream = communicationMux.getStream(\"widget\");\n    widgetStream.on(\"data\", chunk => {\n      const {\n        data\n      } = chunk;\n\n      this._displayIframe(data);\n    }); // Show torus button if wallet has been hydrated/detected\n\n    const statusStream = communicationMux.getStream(\"status\");\n    statusStream.on(\"data\", status => {\n      // login\n      if (status.loggedIn) {\n        this.isLoggedIn = status.loggedIn;\n        this.currentVerifier = status.verifier;\n      } // logout\n      else this._displayIframe();\n\n      if (this.isLoginCallback) {\n        this.isLoginCallback();\n        delete this.isLoginCallback;\n      }\n    });\n    this.provider = proxiedInpageProvider;\n    if (this.provider.shouldSendMetadata) sendSiteMetadata(this.provider._rpcEngine);\n\n    inpageProvider._initializeState();\n\n    log.debug(\"Torus - injected provider\");\n  }\n\n  _showLoginPopup(calledFromEmbed, resolve, reject) {\n    const loginHandler = data => {\n      const {\n        err,\n        selectedAddress\n      } = data;\n\n      if (err) {\n        log.error(err);\n        if (reject) reject(err);\n      } // returns an array (cause accounts expects it)\n      else if (resolve) resolve([selectedAddress]);\n\n      if (this.isIframeFullScreen) this._displayIframe();\n    };\n\n    const oauthStream = this.communicationMux.getStream(\"oauth\");\n\n    if (!this.requestedVerifier) {\n      this._displayIframe(true);\n\n      handleStream(oauthStream, \"data\", loginHandler);\n      oauthStream.write({\n        name: \"oauth_modal\",\n        data: {\n          calledFromEmbed\n        }\n      });\n    } else {\n      handleStream(oauthStream, \"data\", loginHandler);\n      const preopenInstanceId = getPreopenInstanceId();\n\n      this._handleWindow(preopenInstanceId);\n\n      oauthStream.write({\n        name: \"oauth\",\n        data: {\n          calledFromEmbed,\n          verifier: this.requestedVerifier,\n          preopenInstanceId,\n          login_hint: this.loginHint\n        }\n      });\n    }\n  }\n\n  _createPopupBlockAlert(preopenInstanceId, url) {\n    const logoUrl = this._getLogoUrl();\n\n    const torusAlert = htmlToElement('<div id=\"torusAlert\" class=\"torus-alert--v2\">' + `<div id=\"torusAlert__logo\"><img src=\"${logoUrl}\" /></div>` + \"<div>\" + `<h1 id=\"torusAlert__title\">${this.embedTranslations.actionRequired}</h1>` + `<p id=\"torusAlert__desc\">${this.embedTranslations.pendingAction}</p>` + \"</div>\" + \"</div>\");\n    const successAlert = htmlToElement(`<div><a id=\"torusAlert__btn\">${this.embedTranslations.continue}</a></div>`);\n    const btnContainer = htmlToElement('<div id=\"torusAlert__btn-container\"></div>');\n    btnContainer.appendChild(successAlert);\n    torusAlert.appendChild(btnContainer);\n\n    const bindOnLoad = () => {\n      successAlert.addEventListener(\"click\", () => {\n        this._handleWindow(preopenInstanceId, {\n          url,\n          target: \"_blank\",\n          features: FEATURES_CONFIRM_WINDOW\n        });\n\n        torusAlert.remove();\n        if (this.torusAlertContainer.children.length === 0) this.torusAlertContainer.style.display = \"none\";\n      });\n    };\n\n    this._setEmbedWhiteLabel(torusAlert);\n\n    const attachOnLoad = () => {\n      this.torusAlertContainer.style.display = \"block\";\n      this.torusAlertContainer.appendChild(torusAlert);\n    };\n\n    runOnLoad(attachOnLoad);\n    runOnLoad(bindOnLoad);\n  }\n\n}\n\n\n//# sourceMappingURL=torus.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHRvcnVzbGFicy90b3J1cy1lbWJlZC9kaXN0L3RvcnVzLmVzbS5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXNGO0FBQ2xCO0FBQ1g7QUFDeUg7QUFDN0k7QUFDZ0M7QUFDUjtBQUN4QjtBQUNGO0FBQ1g7QUFDUTtBQUNLO0FBQ0M7O0FBRXRDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCw4Q0FBOEMscUNBQXFDOztBQUVuRixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTyxpREFBaUQsOEJBQThCOztBQUV0RixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsbUNBQW1DOztBQUVuQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGdHQUFnRyxhQUFhO0FBQzdHO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUEsVUFBVSwwREFBa0I7O0FBRTVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrR0FBK0csUUFBUTtBQUN2SDtBQUNBLDZGQUE2RixxQkFBcUIsa0JBQWtCLHdCQUF3QixxQkFBcUI7QUFDakw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRkFBa0YsT0FBTztBQUN6RixHQUFHO0FBQ0g7QUFDQSxnRUFBZ0UsUUFBUTtBQUN4RSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQix3RUFBNEI7QUFDOUM7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFROztBQUVSO0FBQ0E7QUFDQTs7QUFFQSx5Q0FBeUMsY0FBYztBQUN2RDtBQUNBLEtBQUs7QUFDTDtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvREFBb0QsWUFBWTs7QUFFaEU7QUFDQSx1QkFBdUIsWUFBWTtBQUNuQzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjs7QUFFaEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsNERBQUcsSUFBSSxrQkFBa0IscURBQXFELFFBQVEsS0FBSztBQUNuSjtBQUNBLE9BQU8sRUFBRTtBQUNUO0FBQ0E7QUFDQSxtQ0FBbUM7O0FBRW5DO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsNENBQTRDLFlBQVk7QUFDeEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdDQUF3QyxZQUFZO0FBQ3BEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7O0FBRXhCO0FBQ0E7QUFDQSxnRkFBZ0YsZUFBZSxTQUFTLGVBQWUsT0FBTyxJQUFJLFFBQVEsS0FBSztBQUMvSTtBQUNBOztBQUVBLDZDQUE2QyxnQ0FBZ0Msb0NBQW9DLG9EQUFvRCw2REFBNkQsaUVBQWlFLHNDQUFzQzs7QUFFelUsbUNBQW1DLGdCQUFnQixzQkFBc0IsT0FBTyx1REFBdUQsK0RBQStELGlGQUFlLDZCQUE2QixzS0FBc0ssbUZBQW1GLEtBQUs7QUFDaGYsMkZBQW9DLFFBQVE7O0FBRTVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsa0NBQWtDLHVFQUFnQjtBQUNsRDtBQUNBO0FBQ0EsMkJBQTJCLCtCQUErQjtBQUMxRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUEsSUFBSSxpRkFBZTs7QUFFbkIsSUFBSSxpRkFBZTs7QUFFbkIsSUFBSSxpRkFBZTs7QUFFbkIsSUFBSSxpRkFBZTs7QUFFbkIsSUFBSSxpRkFBZTs7QUFFbkIsSUFBSSxpRkFBZTs7QUFFbkIsSUFBSSxpRkFBZTs7QUFFbkIsSUFBSSxpRkFBZTs7QUFFbkIsSUFBSSxpRkFBZTs7QUFFbkIsSUFBSSxpRkFBZTs7QUFFbkIsSUFBSSxpRkFBZTs7QUFFbkIsSUFBSSxpRkFBZTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMLFNBQVMsaURBQU07QUFDZjtBQUNBOztBQUVBO0FBQ0EsNkNBQTZDOztBQUU3QyxvQ0FBb0Msc0NBQXNDOztBQUUxRTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7O0FBRWxEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDs7QUFFQSxvQkFBb0Isc0VBQWU7QUFDbkMsSUFBSSwyQ0FBSSxnR0FBZ0c7O0FBRXhHLGtDQUFrQyxnRUFBZTtBQUNqRDtBQUNBLEtBQUssR0FBRztBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG9DQUFvQztBQUN2RDtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsb0NBQW9DO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7O0FBRVIsSUFBSSwyQ0FBSSxtQ0FBbUMsa0VBQWE7QUFDeEQsMEVBQTBFOztBQUUxRSxrQ0FBa0M7QUFDbEM7O0FBRUE7QUFDQTtBQUNBLEtBQUssR0FBRzs7QUFFUiw4QkFBOEIsaUZBQXNCO0FBQ3BELElBQUksMkNBQUksNEpBQTRKOztBQUVwSywwQkFBMEIsaUVBQVU7QUFDcEMsbUJBQW1CLGtGQUF1QjtBQUMxQztBQUNBO0FBQ0EsaUNBQWlDOztBQUVqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7O0FBRVI7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLG9DQUFvQzs7QUFFcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSOztBQUVBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxZQUFZLHdFQUE0QjtBQUN4QztBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQSxZQUFZLHdFQUE0QjtBQUN4QztBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0EsWUFBWSx3RUFBNEI7QUFDeEM7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsT0FBTyxHQUFHOztBQUVWO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQiw0REFBZ0I7QUFDcEM7QUFDQTtBQUNBLFFBQVE7QUFDUixvQkFBb0IsNERBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07OztBQUdOLFNBQVMsc0RBQU07QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxpRkFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEdBQUc7OztBQUdKO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxtREFBVTtBQUMxQyxHQUFHO0FBQ0g7QUFDQSxHQUFHOzs7QUFHSDtBQUNBLG1CQUFtQjs7QUFFbkIsd0RBQXdELFVBQVUsR0FBRyxzQkFBc0I7QUFDM0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkIsaURBQVk7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQSxJQUFJLGlGQUFlOztBQUVuQixJQUFJLGlGQUFlOztBQUVuQixJQUFJLGlGQUFlOztBQUVuQixJQUFJLGlGQUFlOztBQUVuQixJQUFJLGlGQUFlOztBQUVuQixJQUFJLGlGQUFlOztBQUVuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLFVBQVU7O0FBRWQ7O0FBRUE7QUFDQTtBQUNBLElBQUk7OztBQUdKOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxvREFBb0Q7O0FBRXBEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBOztBQUVBLDJDQUEyQyxnQ0FBZ0Msb0NBQW9DLG9EQUFvRCw2REFBNkQsaUVBQWlFLHNDQUFzQzs7QUFFdlUsaUNBQWlDLGdCQUFnQixzQkFBc0IsT0FBTyx1REFBdUQsNkRBQTZELGlGQUFlLDZCQUE2QixvS0FBb0ssbUZBQW1GLEtBQUs7QUFDMWU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUxBQW1MOztBQUVuTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLDhCQUE4QixTQUFTO0FBQ3ZDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTixJQUFJLGlGQUFlOztBQUVuQixJQUFJLGlGQUFlOztBQUVuQixJQUFJLGlGQUFlOztBQUVuQixJQUFJLGlGQUFlOztBQUVuQixJQUFJLGlGQUFlOztBQUVuQixJQUFJLGlGQUFlOztBQUVuQixJQUFJLGlGQUFlOztBQUVuQixJQUFJLGlGQUFlOztBQUVuQixJQUFJLGlGQUFlOztBQUVuQixJQUFJLGlGQUFlOztBQUVuQixJQUFJLGlGQUFlOztBQUVuQixJQUFJLGlGQUFlOztBQUVuQixJQUFJLGlGQUFlOztBQUVuQixJQUFJLGlGQUFlOztBQUVuQixJQUFJLGlGQUFlOztBQUVuQixJQUFJLGlGQUFlOztBQUVuQixJQUFJLGlGQUFlOztBQUVuQixJQUFJLGlGQUFlOztBQUVuQixJQUFJLGlGQUFlOztBQUVuQixJQUFJLGlGQUFlOztBQUVuQixJQUFJLGlGQUFlOztBQUVuQixJQUFJLGlGQUFlOztBQUVuQixJQUFJLGlGQUFlOztBQUVuQixJQUFJLGlGQUFlOztBQUVuQixJQUFJLGlGQUFlOztBQUVuQixJQUFJLGlGQUFlOztBQUVuQjtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7O0FBRTdCLGdDQUFnQzs7QUFFaEM7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7O0FBRVI7QUFDQSxJQUFJLGtFQUFTO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1Asc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQSxrRkFBa0Y7QUFDbEYsNENBQTRDLG1CQUFtQixHQUFHOztBQUVsRTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0EsZUFBZSxvQkFBb0I7QUFDbkMsOEJBQThCLGlCQUFpQixRQUFRLFVBQVUsYUFBYTtBQUM5RSxzQkFBc0IsY0FBYyxrQkFBa0IsV0FBVyxpQkFBaUI7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsU0FBUztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTiwrQkFBK0IsbURBQVM7QUFDeEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYzs7QUFFZDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0EsMEJBQTBCLFNBQVM7QUFDbkM7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQSxpRUFBaUUsa0NBQWtDO0FBQ25HOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjs7QUFFQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sZUFBZSwwRkFBd0I7O0FBRXZDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsS0FBSztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLG9DQUFvQyxjQUFjLFNBQVMsVUFBVSxJQUFJOztBQUV6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCwwQ0FBMEMsbUJBQW1CO0FBQzdEO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsNERBQUc7QUFDZDtBQUNBLDJDQUEyQztBQUMzQztBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7O0FBRVo7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZTs7QUFFZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUTtBQUNSLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVOztBQUVWO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1IsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBLFFBQVE7QUFDUixLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBLHlDQUF5QyxjQUFjLDhCQUE4QixrQkFBa0I7QUFDdkcsNERBQTRELG1CQUFtQixFQUFFLHVDQUF1QyxtQkFBbUI7QUFDM0k7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTs7QUFFVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxxQkFBcUIsY0FBYzs7QUFFbkM7QUFDQTs7QUFFQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDOztBQUVBO0FBQ0E7QUFDQSx3QkFBd0IsS0FBSztBQUM3Qix1QkFBdUIsS0FBSzs7QUFFNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUNBQW1DOztBQUVuQywrQkFBK0IsNEVBQXFCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxHQUFHO0FBQ1I7QUFDQTs7QUFFQSxvQ0FBb0MsNEVBQXFCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxHQUFHO0FBQ1I7QUFDQTs7QUFFQSxvRUFBb0U7O0FBRXBFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsK0ZBQStGLGFBQWE7QUFDNUc7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxZQUFZOztBQUVaO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFFBQVE7O0FBRTFCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQjtBQUNqQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsNkJBQTZCLHlFQUFjO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLEdBQUc7O0FBRVI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFROztBQUVSO0FBQ0EsS0FBSyxHQUFHOztBQUVSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7O0FBRVI7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsK0hBQStILFFBQVEsc0RBQXNELHNDQUFzQyxxQ0FBcUMscUNBQXFDO0FBQzdTLHVFQUF1RSxnQ0FBZ0M7QUFDdkc7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRWlNO0FBQ2pNIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AdG9ydXNsYWJzL3RvcnVzLWVtYmVkL2Rpc3QvdG9ydXMuZXNtLmpzPzFiMjgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyBmcm9tICdAYmFiZWwvcnVudGltZS9oZWxwZXJzL29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzJztcbmltcG9ydCBfZGVmaW5lUHJvcGVydHkgZnJvbSAnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9kZWZpbmVQcm9wZXJ0eSc7XG5pbXBvcnQgeyBnZXQsIHNldEFQSUtleSB9IGZyb20gJ0B0b3J1c2xhYnMvaHR0cC1oZWxwZXJzJztcbmltcG9ydCB7IFNhZmVFdmVudEVtaXR0ZXIsIE9iamVjdE11bHRpcGxleCwgY3JlYXRlU3RyZWFtTWlkZGxld2FyZSwgSlJQQ0VuZ2luZSwgY3JlYXRlSWRSZW1hcE1pZGRsZXdhcmUsIEJhc2VQb3N0TWVzc2FnZVN0cmVhbSwgc2V0dXBNdWx0aXBsZXggfSBmcm9tICdAdG9ydXNsYWJzL29wZW5sb2dpbi1qcnBjJztcbmltcG9ydCBkZWVwbWVyZ2UgZnJvbSAnbG9kYXNoLm1lcmdlJztcbmltcG9ydCB7IE9ic2VydmFibGVTdG9yZSwgc3RvcmVBc1N0cmVhbSB9IGZyb20gJ0BtZXRhbWFzay9vYnMtc3RvcmUnO1xuaW1wb3J0IHsgZXRoRXJyb3JzLCBFdGhlcmV1bVJwY0Vycm9yIH0gZnJvbSAnZXRoLXJwYy1lcnJvcnMnO1xuaW1wb3J0IGRlcXVhbCBmcm9tICdmYXN0LWRlZXAtZXF1YWwnO1xuaW1wb3J0IHsgZHVwbGV4IH0gZnJvbSAnaXMtc3RyZWFtJztcbmltcG9ydCBwdW1wIGZyb20gJ3B1bXAnO1xuaW1wb3J0IGxvZ2xldmVsIGZyb20gJ2xvZ2xldmVsJztcbmltcG9ydCBjcmVhdGVIYXNoIGZyb20gJ2NyZWF0ZS1oYXNoJztcbmltcG9ydCB7IEV2ZW50RW1pdHRlciB9IGZyb20gJ2V2ZW50cyc7XG5cbmNvbnN0IExPR0lOX1BST1ZJREVSID0ge1xuICBHT09HTEU6IFwiZ29vZ2xlXCIsXG4gIEZBQ0VCT09LOiBcImZhY2Vib29rXCIsXG4gIFRXSVRDSDogXCJ0d2l0Y2hcIixcbiAgUkVERElUOiBcInJlZGRpdFwiLFxuICBESVNDT1JEOiBcImRpc2NvcmRcIlxufTtcbmNvbnN0IFdBTExFVF9WRVJJRklFUlMgPSB7XG4gIEdPT0dMRTogXCJnb29nbGVcIixcbiAgRkFDRUJPT0s6IFwiZmFjZWJvb2tcIixcbiAgVFdJVENIOiBcInR3aXRjaFwiLFxuICBSRURESVQ6IFwicmVkZGl0XCIsXG4gIERJU0NPUkQ6IFwiZGlzY29yZFwiLFxuICBFTUFJTF9QQVNTV09SRExFU1M6IFwidG9ydXMtYXV0aDAtZW1haWwtcGFzc3dvcmRsZXNzXCJcbn07XG5jb25zdCBXQUxMRVRfT1BFTkxPR0lOX1ZFUklGSUVSX01BUCA9IHtcbiAgW1dBTExFVF9WRVJJRklFUlMuR09PR0xFXTogXCJ0a2V5LWdvb2dsZVwiLFxuICBbV0FMTEVUX1ZFUklGSUVSUy5GQUNFQk9PS106IFwidGtleS1mYWNlYm9va1wiLFxuICBbV0FMTEVUX1ZFUklGSUVSUy5UV0lUQ0hdOiBcInRrZXktdHdpdGNoXCIsXG4gIFtXQUxMRVRfVkVSSUZJRVJTLlJFRERJVF06IFwidGtleS1yZWRkaXRcIixcbiAgW1dBTExFVF9WRVJJRklFUlMuRElTQ09SRF06IFwidGtleS1kaXNjb3JkXCIsXG4gIFtXQUxMRVRfVkVSSUZJRVJTLkVNQUlMX1BBU1NXT1JETEVTU106IFwidGtleS1hdXRoMC1lbWFpbC1wYXNzd29yZGxlc3NcIlxufTtcbmNvbnN0IFBBWU1FTlRfUFJPVklERVIgPSB7XG4gIE1PT05QQVk6IFwibW9vbnBheVwiLFxuICBXWVJFOiBcInd5cmVcIixcbiAgUkFNUE5FVFdPUks6IFwicmFtcG5ldHdvcmtcIixcbiAgWEFOUE9PTDogXCJ4YW5wb29sXCIsXG4gIE1FUkNVUllPOiBcIm1lcmN1cnlvXCIsXG4gIFRSQU5TQUs6IFwidHJhbnNha1wiLFxuICBCQU5YQTogXCJiYW54YVwiXG59O1xuY29uc3QgU1VQUE9SVEVEX1BBWU1FTlRfTkVUV09SSyA9IHtcbiAgTUFJTk5FVDogXCJtYWlubmV0XCIsXG4gIE1BVElDOiBcIm1hdGljXCIsXG4gIEJTQ19NQUlOTkVUOiBcImJzY19tYWlubmV0XCIsXG4gIEFWQUxBTkNIRV9NQUlOTkVUOiBcImF2YWxhbmNoZV9tYWlubmV0XCIsXG4gIFhEQUk6IFwieGRhaVwiXG59O1xuY29uc3QgVE9SVVNfQlVJTERfRU5WID0ge1xuICBQUk9EVUNUSU9OOiBcInByb2R1Y3Rpb25cIixcbiAgREVWRUxPUE1FTlQ6IFwiZGV2ZWxvcG1lbnRcIixcbiAgQklOQU5DRTogXCJiaW5hbmNlXCIsXG4gIFRFU1RJTkc6IFwidGVzdGluZ1wiLFxuICBMUkM6IFwibHJjXCIsXG4gIEJFVEE6IFwiYmV0YVwiLFxuICBCTkI6IFwiYm5iXCIsXG4gIFBPTFlHT046IFwicG9seWdvblwiXG59O1xuY29uc3QgQlVUVE9OX1BPU0lUSU9OID0ge1xuICBCT1RUT01fTEVGVDogXCJib3R0b20tbGVmdFwiLFxuICBUT1BfTEVGVDogXCJ0b3AtbGVmdFwiLFxuICBCT1RUT01fUklHSFQ6IFwiYm90dG9tLXJpZ2h0XCIsXG4gIFRPUF9SSUdIVDogXCJ0b3AtcmlnaHRcIlxufTtcblxuLyoqXG4gKiBGcm9tIGh0dHBzOi8vbWluLWFwaS5jcnlwdG9jb21wYXJlLmNvbS9kYXRhL3YyL3BhaXIvbWFwcGluZy9mc3ltP2ZzeW09QlRDJmV4dHJhUGFyYW1zPVlvdXJTaXRlXG4gKiBHRVQgaHR0cHM6Ly9taW4tYXBpLmNyeXB0b2NvbXBhcmUuY29tL2RhdGEvdjIvcGFpci9tYXBwaW5nL2ZzeW0/ZnN5bT1CVENcbiAqIFRoZW4gbWFwIG92ZXIgcmV0dXJuZWQgZW50cmllcywgcGlja2luZyB0c3ltXG4gKlxuICogTGFzdCB1cGRhdGVkOiBEYXRlIG9mIGNvbW1pdFxuICovXG5cbmNvbnN0IENSWVBUT19DT01QQVJFX0NVUlJFTkNJRVMgPSBbXCJFVEhcIiwgXCJVU0RUXCIsIFwiVVNEQ1wiLCBcIlRVU0RcIiwgXCJFT1NEVFwiLCBcIlVTRFwiLCBcIkRBSVwiLCBcIkdVU0RcIiwgXCJES0tUXCIsIFwiUEFYXCIsIFwiSUxTXCIsIFwiUlVCXCIsIFwiQllOXCIsIFwiRVVSXCIsIFwiR0JQXCIsIFwiSlBZXCIsIFwiS1JXXCIsIFwiUExOXCIsIFwiTVhOXCIsIFwiQVVEXCIsIFwiQlJMXCIsIFwiQ0FEXCIsIFwiQ0hGXCIsIFwiS1BXXCIsIFwiTEFLXCIsIFwiTEJQXCIsIFwiTEtSXCIsIFwiWE9GXCIsIFwiQ05IVFwiLCBcIkRPR0VcIiwgXCJVQUhcIiwgXCJUUllcIiwgXCJIS0RcIiwgXCJYSlBcIiwgXCJTR0RcIiwgXCJVU0NcIiwgXCJOWkRcIiwgXCJOR05cIiwgXCJSVVJcIiwgXCJDT1BcIiwgXCJHSFNcIiwgXCJFR1BcIiwgXCJJRFJcIiwgXCJCSERcIiwgXCJDUkNcIiwgXCJQRU5cIiwgXCJBRURcIiwgXCJET1BcIiwgXCJQS1JcIiwgXCJIVUZcIiwgXCJWTkRcIiwgXCJYQVJcIiwgXCJMVENcIiwgXCJST05cIiwgXCJPTVJcIiwgXCJNWVJcIiwgXCJES0tcIiwgXCJVR1hcIiwgXCJaTVdcIiwgXCJTQVJcIiwgXCJTRUtcIiwgXCJHRUxcIiwgXCJSV0ZcIiwgXCJJUlJcIiwgXCJUWlNcIiwgXCJDTllcIiwgXCJWRUZcIiwgXCJCRFRcIiwgXCJIUktcIiwgXCJDTFBcIiwgXCJUSEJcIiwgXCJYQUZcIiwgXCJBUlNcIiwgXCJVWVVcIiwgXCJTWkxcIiwgXCJLWlRcIiwgXCJOT0tcIiwgXCJLRVNcIiwgXCJQQUJcIiwgXCJJTlJcIiwgXCJDWktcIiwgXCJNQURcIiwgXCJUV0RcIiwgXCJQSFBcIiwgXCJaQVJcIiwgXCJCT0JcIiwgXCJDREZcIiwgXCJEQVNIXCIsIFwiVkVTXCIsIFwiSVNLXCIsIFwiTVdLXCIsIFwiQkFNXCIsIFwiVFREXCIsIFwiWFJQXCIsIFwiSk9EXCIsIFwiUlNEXCIsIFwiSE5MXCIsIFwiQkdOXCIsIFwiR1RRXCIsIFwiQldQXCIsIFwiWE1SXCIsIFwiTU1LXCIsIFwiUUFSXCIsIFwiQU9BXCIsIFwiS1dEXCIsIFwiTVVSXCIsIFwiV1VTRFwiLCBcIldFVVJcIiwgXCJXQVZFU1wiLCBcIldUUllcIiwgXCJMUkRcIiwgXCJMU0xcIiwgXCJMWURcIiwgXCJBV0dcIiwgXCJNRExcIiwgXCJCVE9cIiwgXCJFVVJTXCIsIFwiQ0hGVFwiLCBcIk1LRFwiLCBcIk1OVFwiLCBcIk1PUFwiLCBcIk1ST1wiLCBcIk1WUlwiLCBcIlZPTExBUlwiLCBcIkNLVVNEXCIsIFwiS0hSXCIsIFwiVlVWXCIsIFwiQklUQ05ZXCIsIFwiUUNcIiwgXCJCQkRcIiwgXCJOQURcIiwgXCJOUFJcIiwgXCJQR0tcIiwgXCJQWUdcIiwgXCJCSUZcIiwgXCJCTURcIiwgXCJCTkRcIiwgXCJYTE1cIiwgXCJCTkJcIiwgXCJTQ1JcIiwgXCJCQVRcIiwgXCJDUk9cIiwgXCJIVFwiLCBcIktDU1wiLCBcIkxFT1wiLCBcIkxJTktcIiwgXCJNS1JcIiwgXCJOUFhTXCIsIFwiT01HXCIsIFwiUkVQXCIsIFwiWkJcIiwgXCJaSUxcIiwgXCJaUlhcIiwgXCJCQ0hcIiwgXCJCWkRcIiwgXCJDVVBcIiwgXCJDVkVcIiwgXCJESkZcIiwgXCJEWkRcIiwgXCJFUk5cIiwgXCJFVEJcIiwgXCJGSkRcIiwgXCJGS1BcIiwgXCJCVVNEXCIsIFwiQU5DVFwiLCBcIkFMTFwiLCBcIkFNRFwiLCBcIkFOR1wiLCBcIkNOWVhcIiwgXCJJUURcIiwgXCJVWlNcIiwgXCJUTkRcIiwgXCJHR1BcIiwgXCJYQVVcIiwgXCJLR1NcIiwgXCJHSVBcIiwgXCJKTURcIiwgXCJaRUNcIiwgXCJVU0RQXCIsIFwiQlNWXCIsIFwiRU1DMlwiLCBcIlNOVFwiLCBcIkdUT1wiLCBcIlBPV1JcIiwgXCJFVVNEXCIsIFwiRVVSVFwiLCBcIkJDWVwiLCBcIkJUU1wiLCBcIkFUTVwiLCBcIkJMT0NLUEFZXCIsIFwiQVJEUlwiLCBcIkFNUFwiLCBcIkIyWFwiLCBcIkJJVEdPTERcIiwgXCJCSVRFVVJcIiwgXCJBVEJcIiwgXCJCSVRVU0RcIiwgXCJBR1JTXCIsIFwiREZYVFwiLCBcIkhJS0VOXCIsIFwiQklYXCIsIFwiS05DXCIsIFwiRU9TXCIsIFwiQ09CXCIsIFwiQ09TU1wiLCBcIkJNSFwiLCBcIk5BTk9cIiwgXCJCREdcIiwgXCJCTlRcIiwgXCJYVkdcIiwgXCJMS0sxWVwiLCBcIkxLS1wiLCBcIlVTREtcIiwgXCJFVVJOXCIsIFwiTlpEVFwiLCBcIkpTRVwiLCBcIkdNRFwiLCBcIkdORlwiLCBcIkdZRFwiLCBcIllFUlwiLCBcIlhQRlwiLCBcIkhUR1wiLCBcIlNMTFwiLCBcIlNPU1wiLCBcIldTVFwiLCBcIlNWQ1wiLCBcIlNZUFwiLCBcIk5FT1wiLCBcIktNRlwiLCBcIkpVTVBcIiwgXCJBWUFcIiwgXCJCTEFTVFwiLCBcIldHUlwiLCBcIkJDTlwiLCBcIkJUR1wiLCBcIlVSQUxTXCIsIFwiSU5OXCIsIFwiVVNEUVwiLCBcIkNOSFwiLCBcIkhVU0RcIiwgXCJCS1JXXCIsIFwiTlpEWFwiLCBcIkVVUlhcIiwgXCJDQURYXCIsIFwiVVNERVhcIiwgXCJKUFlYXCIsIFwiQVVEWFwiLCBcIlZORENcIiwgXCJFT05cIiwgXCJHQlBYXCIsIFwiQ0hGWFwiLCBcIlVTREpcIiwgXCJJRFJUXCIsIFwiVVNEU1wiLCBcIlVTRE5cIiwgXCJCSURSXCIsIFwiSURLXCIsIFwiQlNEXCIsIFwiQlROXCIsIFwiS1lEXCIsIFwiTklPXCIsIFwiU0JEXCIsIFwiU0RHXCIsIFwiU0hQXCIsIFwiVE9QXCIsIFwiWENEXCIsIFwiWENIRlwiLCBcIkNOWVRcIiwgXCJHWUVOXCIsIFwiWlVTRFwiLCBcIkdPTERcIiwgXCJUUlhcIiwgXCJUUllCXCIsIFwiUExBVENcIiwgXCJTVFJBWFwiLCBcIlVTVFwiLCBcIkdMTVwiLCBcIlZBSVwiLCBcIkJSWlwiLCBcIkREUlNUXCIsIFwiWEFVVFwiLCBcIk1JTVwiXTtcbi8qKlxuICogY3VycmVuY2llcyBzdXBwb3J0ZWQgYnkgdGhlIHBheW1lbnQgcHJvdmlkZXJcbiAqIExhc3QgdXBkYXRlZDogRGF0ZSBvZiBjb21taXRcbiAqL1xuXG5jb25zdCBQUk9WSURFUl9TVVBQT1JURURfRklBVF9DVVJSRU5DSUVTID0ge1xuICAvLyBodHRwczovL2ludGVncmF0aW9ucy5zaW1wbGV4LmNvbS9zdXBwb3J0ZWRfY3VycmVuY2llc1xuICAvLyBodHRwczovL3N1cHBvcnQubW9vbnBheS5jb20vaGMvZW4tZ2IvYXJ0aWNsZXMvMzYwMDExOTMxNDU3LVdoaWNoLWZpYXQtY3VycmVuY2llcy1hcmUtc3VwcG9ydGVkLVxuICBbUEFZTUVOVF9QUk9WSURFUi5NT09OUEFZXTogW1wiQVVEXCIsIFwiQkdOXCIsIFwiQlJMXCIsIFwiQ0FEXCIsIFwiQ0hGXCIsIFwiQ05ZXCIsIFwiQ09QXCIsIFwiQ1pLXCIsIFwiREtLXCIsIFwiRE9QXCIsIFwiRUdQXCIsIFwiRVVSXCIsIFwiR0JQXCIsIFwiSEtEXCIsIFwiSFJLXCIsIFwiSURSXCIsIFwiSUxTXCIsIFwiSlBZXCIsIFwiSk9EXCIsIFwiS0VTXCIsIFwiS1JXXCIsIFwiS1dEXCIsIFwiTEtSXCIsIFwiTUFEXCIsIFwiTVhOXCIsIFwiTVlSXCIsIFwiTkdOXCIsIFwiTk9LXCIsIFwiTlpEXCIsIFwiT01SXCIsIFwiUEVOXCIsIFwiUEtSXCIsIFwiUExOXCIsIFwiUk9OXCIsIFwiUlVCXCIsIFwiU0VLXCIsIFwiU0dEXCIsIFwiVEhCXCIsIFwiVFJZXCIsIFwiVFdEXCIsIFwiVVNEXCIsIFwiVk5EXCIsIFwiWkFSXCJdLFxuXG4gIC8qKlxuICAgKiBodHRwczovL2RvY3Muc2VuZHd5cmUuY29tL2RvY3Mvc3VwcG9ydGVkLWN1cnJlbmNpZXMjZmlhdFxuICAgKiBUaGUgb25lcyB3aGVyZSBjcmVkaXQgY2FyZCBpcyBzdXBwb3J0ZWRcbiAgICovXG4gIFtQQVlNRU5UX1BST1ZJREVSLldZUkVdOiBbXCJVU0RcIiwgXCJFVVJcIiwgXCJHQlBcIiwgXCJBVURcIiwgXCJDQURcIiwgXCJOWkRcIiwgXCJBUlNcIiwgXCJCUkxcIiwgXCJDSEZcIiwgXCJDTFBcIiwgXCJDT1BcIiwgXCJDWktcIiwgXCJES0tcIiwgXCJIS0RcIiwgXCJJTFNcIiwgXCJJTlJcIiwgXCJJU0tcIiwgXCJKUFlcIiwgXCJLUldcIiwgXCJNWE5cIiwgXCJNWVJcIiwgXCJOT0tcIiwgXCJQSFBcIiwgXCJQTE5cIiwgXCJTRUtcIiwgXCJUSEJcIiwgXCJWTkRcIiwgXCJaQVJcIl0sXG4gIC8vIGh0dHBzOi8vc3VwcG9ydC5yYW1wLm5ldHdvcmsvZW4vYXJ0aWNsZXMvNDcxLXdoeS1hbS1pLXBheWluZy1pbi11c2QtZXVyLWdicFxuICBbUEFZTUVOVF9QUk9WSURFUi5SQU1QTkVUV09SS106IFtcIlVTRFwiLCBcIkVVUlwiLCBcIkdCUFwiXSxcbiAgLy8gRnJvbSBodHRwczovL3hhbnBvb2wuY29tLyBmaWF0IHNlbGVjdCBkcm9wZG93blxuICBbUEFZTUVOVF9QUk9WSURFUi5YQU5QT09MXTogW1wiU0dEXCIsIFwiSEtEXCIsIFwiVEhCXCIsIFwiUEhQXCIsIFwiSU5SXCIsIFwiSURSXCIsIFwiTVlSXCIsIFwiQVVEXCIsIFwiTlpEXCIsIFwiS1JXXCJdLFxuICAvLyBodHRwczovL3N1cHBvcnQuYWF4LmNvbS9lbi9hcnRpY2xlcy81Mjk1NzYyLW1lcmN1cnlvXG4gIC8vIFJVQiAvIFVBSCBjdXJyZW50bHkgbm90IHN1cHBvcnRlZFxuICBbUEFZTUVOVF9QUk9WSURFUi5NRVJDVVJZT106IFtcIkVVUlwiLCBcIlVTRFwiLCBcIkdCUFwiLCBcIlRSWVwiLCBcIkpQWVwiLCBcIkJSTFwiLCBcIk5HTlwiLCBcIlZORFwiLCBcIk1YTlwiLCBcIktSV1wiXSxcblxuICAvKipcbiAgICogaHR0cHM6Ly9zdXBwb3J0LnRyYW5zYWsuY29tL2hjL2VuLXVzL2FydGljbGVzLzM2MDAyMDYxNTU3OC1DcmVkaXQtYW5kLURlYml0LUNhcmQtUGF5bWVudHMtdGhyb3VnaC1UcmFuc2FrXG4gICAqIG9yXG4gICAqIGh0dHBzOi8vdHJhbnNhay5zdG9wbGlnaHQuaW8vZG9jcy90cmFuc2FrLWRvY3MvYjNBNk9UazFPRFEwLTItZ2V0LWZpYXQtY3VycmVuY2llc1xuICAgKi9cbiAgW1BBWU1FTlRfUFJPVklERVIuVFJBTlNBS106IFtcIkFSU1wiLCBcIkFVRFwiLCBcIkJCRFwiLCBcIkJHTlwiLCBcIkJNRFwiLCBcIkJSTFwiLCBcIkNBRFwiLCBcIkNIRlwiLCBcIkNMUFwiLCBcIkNSQ1wiLCBcIkNaS1wiLCBcIkRLS1wiLCBcIkRPUFwiLCBcIkVVUlwiLCBcIkZKRFwiLCBcIkZLUFwiLCBcIkdCUFwiLCBcIkdJUFwiLCBcIkhSS1wiLCBcIkhVRlwiLCBcIklEUlwiLCBcIklMU1wiLCBcIklTS1wiLCBcIkpNRFwiLCBcIkpQWVwiLCBcIktFU1wiLCBcIktSV1wiLCBcIk1ETFwiLCBcIk1YTlwiLCBcIk1ZUlwiLCBcIk5PS1wiLCBcIk5aRFwiLCBcIlBFTlwiLCBcIlBIUFwiLCBcIlBMTlwiLCBcIlBZR1wiLCBcIlJPTlwiLCBcIlNFS1wiLCBcIlNHRFwiLCBcIlRIQlwiLCBcIlRSWVwiLCBcIlRaU1wiLCBcIlVTRFwiLCBcIlpBUlwiXSxcbiAgW1BBWU1FTlRfUFJPVklERVIuQkFOWEFdOiBbXCJFVVJcIiwgXCJHQlBcIiwgXCJVU0RcIl1cbn07XG5jb25zdCBjcnlwdG9Db21wYXJlQ3VycmVuY2llc1NldCA9IG5ldyBTZXQoQ1JZUFRPX0NPTVBBUkVfQ1VSUkVOQ0lFUyk7XG4vKipcbiAqIEZpYXQgY3VycmVuY2llcyB0aGF0IHdlIHN1cHBvcnRcbiAqL1xuXG5mdW5jdGlvbiBzdXBwb3J0ZWRGaWF0Q3VycmVuY2llcyhwcm92aWRlcikge1xuICBjb25zdCBwcm92aWRlclN1cHBvcnRlZEZpYXRDdXJyZW5jaWVzID0gUFJPVklERVJfU1VQUE9SVEVEX0ZJQVRfQ1VSUkVOQ0lFU1twcm92aWRlcl07XG4gIHJldHVybiBwcm92aWRlclN1cHBvcnRlZEZpYXRDdXJyZW5jaWVzLmZpbHRlcihjdXJyZW5jeSA9PiBjcnlwdG9Db21wYXJlQ3VycmVuY2llc1NldC5oYXMoY3VycmVuY3kpKTtcbn1cblxuY29uc3QgcGF5bWVudFByb3ZpZGVycyQxID0ge1xuICBbUEFZTUVOVF9QUk9WSURFUi5NT09OUEFZXToge1xuICAgIGxpbmUxOiBcIkNyZWRpdC8gRGViaXQgQ2FyZC8gQXBwbGUgUGF5XCIsXG4gICAgbGluZTI6IFwiNC41JSBvciA1IFVTRFwiLFxuICAgIGxpbmUzOiBcIjIsMDAw4oKsL2RheSwgMTAsMDAw4oKsL21vXCIsXG4gICAgc3VwcG9ydFBhZ2U6IFwiaHR0cHM6Ly9oZWxwLm1vb25wYXkuaW8vZW4vXCIsXG4gICAgbWluT3JkZXJWYWx1ZTogMjQuOTksXG4gICAgbWF4T3JkZXJWYWx1ZTogNTAwMDAsXG4gICAgdmFsaWRDdXJyZW5jaWVzOiBzdXBwb3J0ZWRGaWF0Q3VycmVuY2llcyhQQVlNRU5UX1BST1ZJREVSLk1PT05QQVkpLFxuICAgIHZhbGlkQ3J5cHRvQ3VycmVuY2llc0J5Q2hhaW46IHtcbiAgICAgIFtTVVBQT1JURURfUEFZTUVOVF9ORVRXT1JLLk1BSU5ORVRdOiBbe1xuICAgICAgICB2YWx1ZTogXCJhYXZlXCIsXG4gICAgICAgIGRpc3BsYXk6IFwiQUFWRVwiXG4gICAgICB9LCB7XG4gICAgICAgIHZhbHVlOiBcImJhdFwiLFxuICAgICAgICBkaXNwbGF5OiBcIkJBVFwiXG4gICAgICB9LCB7XG4gICAgICAgIHZhbHVlOiBcImRhaVwiLFxuICAgICAgICBkaXNwbGF5OiBcIkRBSVwiXG4gICAgICB9LCB7XG4gICAgICAgIHZhbHVlOiBcImV0aFwiLFxuICAgICAgICBkaXNwbGF5OiBcIkVUSFwiXG4gICAgICB9LCB7XG4gICAgICAgIHZhbHVlOiBcIm1rclwiLFxuICAgICAgICBkaXNwbGF5OiBcIk1LUlwiXG4gICAgICB9LCB7XG4gICAgICAgIHZhbHVlOiBcIm1hdGljXCIsXG4gICAgICAgIGRpc3BsYXk6IFwiTUFUSUNcIlxuICAgICAgfSwge1xuICAgICAgICB2YWx1ZTogXCJ1c2R0XCIsXG4gICAgICAgIGRpc3BsYXk6IFwiVVNEVFwiXG4gICAgICB9LCB7XG4gICAgICAgIHZhbHVlOiBcInVzZGNcIixcbiAgICAgICAgZGlzcGxheTogXCJVU0RDXCJcbiAgICAgIH1dLFxuICAgICAgW1NVUFBPUlRFRF9QQVlNRU5UX05FVFdPUksuTUFUSUNdOiBbe1xuICAgICAgICB2YWx1ZTogXCJldGhfcG9seWdvblwiLFxuICAgICAgICBkaXNwbGF5OiBcIkVUSFwiXG4gICAgICB9LCB7XG4gICAgICAgIHZhbHVlOiBcIm1hdGljX3BvbHlnb25cIixcbiAgICAgICAgZGlzcGxheTogXCJNQVRJQ1wiXG4gICAgICB9LCB7XG4gICAgICAgIHZhbHVlOiBcInVzZGNfcG9seWdvblwiLFxuICAgICAgICBkaXNwbGF5OiBcIlVTRENcIlxuICAgICAgfV0sXG4gICAgICBbU1VQUE9SVEVEX1BBWU1FTlRfTkVUV09SSy5CU0NfTUFJTk5FVF06IFt7XG4gICAgICAgIHZhbHVlOiBcImJuYl9ic2NcIixcbiAgICAgICAgZGlzcGxheTogXCJCTkJcIlxuICAgICAgfSwge1xuICAgICAgICB2YWx1ZTogXCJidXNkX2JzY1wiLFxuICAgICAgICBkaXNwbGF5OiBcIkJVU0RcIlxuICAgICAgfV0sXG4gICAgICBbU1VQUE9SVEVEX1BBWU1FTlRfTkVUV09SSy5BVkFMQU5DSEVfTUFJTk5FVF06IFt7XG4gICAgICAgIHZhbHVlOiBcImF2YXhfY2NoYWluXCIsXG4gICAgICAgIGRpc3BsYXk6IFwiQVZBWFwiXG4gICAgICB9XVxuICAgIH0sXG4gICAgaW5jbHVkZUZlZXM6IHRydWUsXG4gICAgYXBpOiB0cnVlLFxuICAgIGVuZm9yY2VNYXg6IGZhbHNlXG4gIH0sXG4gIFtQQVlNRU5UX1BST1ZJREVSLldZUkVdOiB7XG4gICAgbGluZTE6IFwiQXBwbGUgUGF5LyBEZWJpdC8gQ3JlZGl0IENhcmRcIixcbiAgICBsaW5lMjogXCI0LjklICsgMzDCoiBvciA1IFVTRFwiLFxuICAgIGxpbmUzOiBcIiQyNTAvZGF5XCIsXG4gICAgc3VwcG9ydFBhZ2U6IFwiaHR0cHM6Ly9zdXBwb3J0LnNlbmR3eXJlLmNvbS9lbi9cIixcbiAgICBtaW5PcmRlclZhbHVlOiA1LFxuICAgIG1heE9yZGVyVmFsdWU6IDUwMCxcbiAgICB2YWxpZEN1cnJlbmNpZXM6IHN1cHBvcnRlZEZpYXRDdXJyZW5jaWVzKFBBWU1FTlRfUFJPVklERVIuV1lSRSksXG4gICAgdmFsaWRDcnlwdG9DdXJyZW5jaWVzQnlDaGFpbjoge1xuICAgICAgW1NVUFBPUlRFRF9QQVlNRU5UX05FVFdPUksuTUFJTk5FVF06IFt7XG4gICAgICAgIHZhbHVlOiBcIkFBVkVcIixcbiAgICAgICAgZGlzcGxheTogXCJBQVZFXCJcbiAgICAgIH0sIHtcbiAgICAgICAgdmFsdWU6IFwiQkFUXCIsXG4gICAgICAgIGRpc3BsYXk6IFwiQkFUXCJcbiAgICAgIH0sIHtcbiAgICAgICAgdmFsdWU6IFwiQlVTRFwiLFxuICAgICAgICBkaXNwbGF5OiBcIkJVU0RcIlxuICAgICAgfSwge1xuICAgICAgICB2YWx1ZTogXCJEQUlcIixcbiAgICAgICAgZGlzcGxheTogXCJEQUlcIlxuICAgICAgfSwge1xuICAgICAgICB2YWx1ZTogXCJFVEhcIixcbiAgICAgICAgZGlzcGxheTogXCJFVEhcIlxuICAgICAgfSwge1xuICAgICAgICB2YWx1ZTogXCJNS1JcIixcbiAgICAgICAgZGlzcGxheTogXCJNS1JcIlxuICAgICAgfSwge1xuICAgICAgICB2YWx1ZTogXCJVTklcIixcbiAgICAgICAgZGlzcGxheTogXCJVTklcIlxuICAgICAgfSwge1xuICAgICAgICB2YWx1ZTogXCJVU0RDXCIsXG4gICAgICAgIGRpc3BsYXk6IFwiVVNEQ1wiXG4gICAgICB9LCB7XG4gICAgICAgIHZhbHVlOiBcIlVTRFRcIixcbiAgICAgICAgZGlzcGxheTogXCJVU0RUXCJcbiAgICAgIH1dLFxuICAgICAgW1NVUFBPUlRFRF9QQVlNRU5UX05FVFdPUksuTUFUSUNdOiBbe1xuICAgICAgICB2YWx1ZTogXCJNVVNEQ1wiLFxuICAgICAgICBkaXNwbGF5OiBcIlVTRENcIlxuICAgICAgfV0sXG4gICAgICAvLyBBVkFYQz8gb3IgQVZBWD9cbiAgICAgIFtTVVBQT1JURURfUEFZTUVOVF9ORVRXT1JLLkFWQUxBTkNIRV9NQUlOTkVUXTogW3tcbiAgICAgICAgdmFsdWU6IFwiQVZBWENcIixcbiAgICAgICAgZGlzcGxheTogXCJBVkFYQ1wiXG4gICAgICB9XVxuICAgIH0sXG4gICAgaW5jbHVkZUZlZXM6IGZhbHNlLFxuICAgIGFwaTogdHJ1ZSxcbiAgICBlbmZvcmNlTWF4OiBmYWxzZVxuICB9LFxuICBbUEFZTUVOVF9QUk9WSURFUi5SQU1QTkVUV09SS106IHtcbiAgICBsaW5lMTogXCJEZWJpdCBDYXJkLyA8YnI+QXBwbGUgUGF5LyBCYW5rIHRyYW5zZmVyXCIsXG4gICAgbGluZTI6IFwiMC40OSUgLSAyLjklXCIsXG4gICAgbGluZTM6IFwiNSwwMDDigqwvcHVyY2hhc2UsIDIwLDAwMOKCrC9tb1wiLFxuICAgIHN1cHBvcnRQYWdlOiBcImh0dHBzOi8vaW5zdGFudC5yYW1wLm5ldHdvcmsvXCIsXG4gICAgbWluT3JkZXJWYWx1ZTogNTAsXG4gICAgbWF4T3JkZXJWYWx1ZTogMjAwMDAsXG4gICAgdmFsaWRDdXJyZW5jaWVzOiBzdXBwb3J0ZWRGaWF0Q3VycmVuY2llcyhQQVlNRU5UX1BST1ZJREVSLlJBTVBORVRXT1JLKSxcbiAgICB2YWxpZENyeXB0b0N1cnJlbmNpZXNCeUNoYWluOiB7XG4gICAgICBbU1VQUE9SVEVEX1BBWU1FTlRfTkVUV09SSy5NQUlOTkVUXTogW3tcbiAgICAgICAgdmFsdWU6IFwiRVRIXCIsXG4gICAgICAgIGRpc3BsYXk6IFwiRVRIXCJcbiAgICAgIH0sIHtcbiAgICAgICAgdmFsdWU6IFwiREFJXCIsXG4gICAgICAgIGRpc3BsYXk6IFwiREFJXCJcbiAgICAgIH0sIHtcbiAgICAgICAgdmFsdWU6IFwiVVNEQ1wiLFxuICAgICAgICBkaXNwbGF5OiBcIlVTRENcIlxuICAgICAgfSwge1xuICAgICAgICB2YWx1ZTogXCJVU0RUXCIsXG4gICAgICAgIGRpc3BsYXk6IFwiVVNEVFwiXG4gICAgICB9XSxcbiAgICAgIFtTVVBQT1JURURfUEFZTUVOVF9ORVRXT1JLLk1BVElDXTogW3tcbiAgICAgICAgdmFsdWU6IFwiTUFUSUNfREFJXCIsXG4gICAgICAgIGRpc3BsYXk6IFwiREFJXCJcbiAgICAgIH0sIHtcbiAgICAgICAgdmFsdWU6IFwiTUFUSUNfTUFUSUNcIixcbiAgICAgICAgZGlzcGxheTogXCJNQVRJQ1wiXG4gICAgICB9LCB7XG4gICAgICAgIHZhbHVlOiBcIk1BVElDX1VTRENcIixcbiAgICAgICAgZGlzcGxheTogXCJVU0RDXCJcbiAgICAgIH1dLFxuICAgICAgLy8gd2hhdCBhYm91dCBBVkFYQz9cbiAgICAgIFtTVVBQT1JURURfUEFZTUVOVF9ORVRXT1JLLkFWQUxBTkNIRV9NQUlOTkVUXTogW3tcbiAgICAgICAgdmFsdWU6IFwiQVZBWFwiLFxuICAgICAgICBkaXNwbGF5OiBcIkFWQVhcIlxuICAgICAgfV0gLy8gVGVtcG9yYXJ5IHVuYXZhaWxhYmxlXG4gICAgICAvLyBbU1VQUE9SVEVEX1BBWU1FTlRfTkVUV09SSy5YREFJXTogW3sgdmFsdWU6ICdYREFJX1hEQUknLCBkaXNwbGF5OiAnWERBSScgfV0sXG5cbiAgICB9LFxuICAgIGluY2x1ZGVGZWVzOiB0cnVlLFxuICAgIGFwaTogdHJ1ZSxcbiAgICByZWNlaXZlSGludDogXCJ3YWxsZXRUb3BVcC5yZWNlaXZlSGludFJhbXBcIixcbiAgICBlbmZvcmNlTWF4OiBmYWxzZVxuICB9LFxuICBbUEFZTUVOVF9QUk9WSURFUi5YQU5QT09MXToge1xuICAgIGxpbmUxOiBcIlBheU5vdy8gSW5zdGFQYXkvIEZQUy8gR29KZWtQYXkvIFVQSS8gUHJvbXB0UGF5LyA8YnI+VmlldHRlbFBheS8gRHVpdE5vd1wiLFxuICAgIGxpbmUyOiBcIjIuNSUgYnV5aW5nLCAzJSBzZWxsaW5nXCIsXG4gICAgbGluZTM6IFwiJDIsNTAwIC8gZGF5XCIsXG4gICAgc3VwcG9ydFBhZ2U6IFwibWFpbHRvOnN1cHBvcnRAeGFucG9vbC5jb21cIixcbiAgICBtaW5PcmRlclZhbHVlOiAxMDAsXG4gICAgbWF4T3JkZXJWYWx1ZTogMjUwMCxcbiAgICB2YWxpZEN1cnJlbmNpZXM6IHN1cHBvcnRlZEZpYXRDdXJyZW5jaWVzKFBBWU1FTlRfUFJPVklERVIuWEFOUE9PTCksXG4gICAgdmFsaWRDcnlwdG9DdXJyZW5jaWVzQnlDaGFpbjoge1xuICAgICAgW1NVUFBPUlRFRF9QQVlNRU5UX05FVFdPUksuTUFJTk5FVF06IFt7XG4gICAgICAgIHZhbHVlOiBcIkVUSFwiLFxuICAgICAgICBkaXNwbGF5OiBcIkVUSFwiXG4gICAgICB9LCB7XG4gICAgICAgIHZhbHVlOiBcIlVTRFRcIixcbiAgICAgICAgZGlzcGxheTogXCJVU0RUXCJcbiAgICAgIH1dXG4gICAgfSxcbiAgICBpbmNsdWRlRmVlczogdHJ1ZSxcbiAgICBhcGk6IHRydWUsXG4gICAgc2VsbDogdHJ1ZSxcbiAgICBlbmZvcmNlTWF4OiBmYWxzZVxuICB9LFxuICBbUEFZTUVOVF9QUk9WSURFUi5NRVJDVVJZT106IHtcbiAgICBsaW5lMTogXCJDcmVkaXQvIERlYml0IENhcmQvIEFwcGxlIFBheVwiLFxuICAgIGxpbmUyOiBcIjMuOTUlIG9yIDQgVVNEXCIsXG4gICAgbGluZTM6IFwiMTAsMDAw4oKsL2RheSwgMjUsMDAw4oKsL21vXCIsXG4gICAgc3VwcG9ydFBhZ2U6IFwibWFpbHRvOnN1cHBvcnRAbWVyY3VyeW8uaW9cIixcbiAgICBtaW5PcmRlclZhbHVlOiAzMCxcbiAgICBtYXhPcmRlclZhbHVlOiA1MDAwLFxuICAgIHZhbGlkQ3VycmVuY2llczogc3VwcG9ydGVkRmlhdEN1cnJlbmNpZXMoUEFZTUVOVF9QUk9WSURFUi5NRVJDVVJZTyksXG4gICAgdmFsaWRDcnlwdG9DdXJyZW5jaWVzQnlDaGFpbjoge1xuICAgICAgW1NVUFBPUlRFRF9QQVlNRU5UX05FVFdPUksuTUFJTk5FVF06IFt7XG4gICAgICAgIHZhbHVlOiBcIkVUSFwiLFxuICAgICAgICBkaXNwbGF5OiBcIkVUSFwiXG4gICAgICB9LCB7XG4gICAgICAgIHZhbHVlOiBcIkJBVFwiLFxuICAgICAgICBkaXNwbGF5OiBcIkJBVFwiXG4gICAgICB9LCB7XG4gICAgICAgIHZhbHVlOiBcIlVTRFRcIixcbiAgICAgICAgZGlzcGxheTogXCJVU0RUXCJcbiAgICAgIH0sIHtcbiAgICAgICAgdmFsdWU6IFwiREFJXCIsXG4gICAgICAgIGRpc3BsYXk6IFwiREFJXCJcbiAgICAgIH1dLFxuICAgICAgW1NVUFBPUlRFRF9QQVlNRU5UX05FVFdPUksuQlNDX01BSU5ORVRdOiBbe1xuICAgICAgICB2YWx1ZTogXCJCTkJcIixcbiAgICAgICAgZGlzcGxheTogXCJCTkJcIlxuICAgICAgfSwge1xuICAgICAgICB2YWx1ZTogXCJCVVNEXCIsXG4gICAgICAgIGRpc3BsYXk6IFwiQlVTRFwiXG4gICAgICB9LCB7XG4gICAgICAgIHZhbHVlOiBcIjFJTkNIXCIsXG4gICAgICAgIGRpc3BsYXk6IFwiMUlOQ0hcIlxuICAgICAgfV1cbiAgICB9LFxuICAgIGluY2x1ZGVGZWVzOiB0cnVlLFxuICAgIGFwaTogdHJ1ZSxcbiAgICBlbmZvcmNlTWF4OiBmYWxzZVxuICB9LFxuICBbUEFZTUVOVF9QUk9WSURFUi5UUkFOU0FLXToge1xuICAgIGxpbmUxOiBcIkFwcGxlICYgR29vZ2xlIFBheSAvIENyZWRpdC9EZWJpdCBDYXJkPGJyLz5CYW5na29rIEJhbmsgTW9iaWxlICYgaVBheTxici8+QmFuayBUcmFuc2ZlciAoc2VwYS9nYnApIC8gU0NCIE1vYmlsZSAmIEVhc3lcIixcbiAgICBsaW5lMjogXCIwLjk5JSAtIDUuNSUgb3IgNSBVU0RcIixcbiAgICBsaW5lMzogXCIkNSwwMDAvZGF5LCAkMjgsMDAwL21vXCIsXG4gICAgc3VwcG9ydFBhZ2U6IFwiaHR0cHM6Ly9zdXBwb3J0LnRyYW5zYWsuY29tL2hjL2VuLVVTXCIsXG4gICAgbWluT3JkZXJWYWx1ZTogMzAsXG4gICAgbWF4T3JkZXJWYWx1ZTogNTAwLFxuICAgIHZhbGlkQ3VycmVuY2llczogc3VwcG9ydGVkRmlhdEN1cnJlbmNpZXMoUEFZTUVOVF9QUk9WSURFUi5UUkFOU0FLKSxcbiAgICB2YWxpZENyeXB0b0N1cnJlbmNpZXNCeUNoYWluOiB7XG4gICAgICBbU1VQUE9SVEVEX1BBWU1FTlRfTkVUV09SSy5NQUlOTkVUXTogW3tcbiAgICAgICAgdmFsdWU6IFwiQUFWRVwiLFxuICAgICAgICBkaXNwbGF5OiBcIkFBVkVcIlxuICAgICAgfSwge1xuICAgICAgICB2YWx1ZTogXCJEQUlcIixcbiAgICAgICAgZGlzcGxheTogXCJEQUlcIlxuICAgICAgfSwge1xuICAgICAgICB2YWx1ZTogXCJFVEhcIixcbiAgICAgICAgZGlzcGxheTogXCJFVEhcIlxuICAgICAgfSwge1xuICAgICAgICB2YWx1ZTogXCJVU0RDXCIsXG4gICAgICAgIGRpc3BsYXk6IFwiVVNEQ1wiXG4gICAgICB9LCB7XG4gICAgICAgIHZhbHVlOiBcIlVTRFRcIixcbiAgICAgICAgZGlzcGxheTogXCJVU0RUXCJcbiAgICAgIH1dLFxuICAgICAgW1NVUFBPUlRFRF9QQVlNRU5UX05FVFdPUksuTUFUSUNdOiBbe1xuICAgICAgICB2YWx1ZTogXCJBQVZFXCIsXG4gICAgICAgIGRpc3BsYXk6IFwiQUFWRVwiXG4gICAgICB9LCB7XG4gICAgICAgIHZhbHVlOiBcIkRBSVwiLFxuICAgICAgICBkaXNwbGF5OiBcIkRBSVwiXG4gICAgICB9LCB7XG4gICAgICAgIHZhbHVlOiBcIk1BVElDXCIsXG4gICAgICAgIGRpc3BsYXk6IFwiTUFUSUNcIlxuICAgICAgfSwge1xuICAgICAgICB2YWx1ZTogXCJVU0RDXCIsXG4gICAgICAgIGRpc3BsYXk6IFwiVVNEQ1wiXG4gICAgICB9LCB7XG4gICAgICAgIHZhbHVlOiBcIlVTRFRcIixcbiAgICAgICAgZGlzcGxheTogXCJVU0RUXCJcbiAgICAgIH0sIHtcbiAgICAgICAgdmFsdWU6IFwiV0VUSFwiLFxuICAgICAgICBkaXNwbGF5OiBcIldFVEhcIlxuICAgICAgfV0sXG4gICAgICBbU1VQUE9SVEVEX1BBWU1FTlRfTkVUV09SSy5CU0NfTUFJTk5FVF06IFt7XG4gICAgICAgIHZhbHVlOiBcIkJOQlwiLFxuICAgICAgICBkaXNwbGF5OiBcIkJOQlwiXG4gICAgICB9LCB7XG4gICAgICAgIHZhbHVlOiBcIkJVU0RcIixcbiAgICAgICAgZGlzcGxheTogXCJCVVNEXCJcbiAgICAgIH1dLFxuICAgICAgW1NVUFBPUlRFRF9QQVlNRU5UX05FVFdPUksuQVZBTEFOQ0hFX01BSU5ORVRdOiBbe1xuICAgICAgICB2YWx1ZTogXCJBVkFYXCIsXG4gICAgICAgIGRpc3BsYXk6IFwiQVZBWFwiXG4gICAgICB9XVxuICAgIH0sXG4gICAgaW5jbHVkZUZlZXM6IHRydWUsXG4gICAgZW5mb3JjZU1heDogdHJ1ZVxuICB9LFxuICBbUEFZTUVOVF9QUk9WSURFUi5CQU5YQV06IHtcbiAgICBsaW5lMTogXCJEZWJpdCBDYXJkLyA8YnI+QXBwbGUgUGF5LyBCYW5rIHRyYW5zZmVyXCIsXG4gICAgbGluZTI6IFwiMC40OSUgLSAyLjklXCIsXG4gICAgbGluZTM6IFwiNSwwMDDigqwvcHVyY2hhc2UsIDIwLDAwMOKCrC9tb1wiLFxuICAgIHN1cHBvcnRQYWdlOiBcImh0dHBzOi8vc3VwcG9ydC5iYW54YS5jb21cIixcbiAgICBtaW5PcmRlclZhbHVlOiAyMCxcbiAgICBtYXhPcmRlclZhbHVlOiAxNTAwMCxcbiAgICB2YWxpZEN1cnJlbmNpZXM6IHN1cHBvcnRlZEZpYXRDdXJyZW5jaWVzKFBBWU1FTlRfUFJPVklERVIuQkFOWEEpLFxuICAgIHZhbGlkQ3J5cHRvQ3VycmVuY2llc0J5Q2hhaW46IHtcbiAgICAgIFtTVVBQT1JURURfUEFZTUVOVF9ORVRXT1JLLk1BSU5ORVRdOiBbe1xuICAgICAgICB2YWx1ZTogXCJFVEhcIixcbiAgICAgICAgZGlzcGxheTogXCJFVEhcIlxuICAgICAgfSwge1xuICAgICAgICB2YWx1ZTogXCJVU0RUXCIsXG4gICAgICAgIGRpc3BsYXk6IFwiVVNEVFwiXG4gICAgICB9LCB7XG4gICAgICAgIHZhbHVlOiBcIkJVU0RcIixcbiAgICAgICAgZGlzcGxheTogXCJCVVNEXCJcbiAgICAgIH0sIHtcbiAgICAgICAgdmFsdWU6IFwiTElOS1wiLFxuICAgICAgICBkaXNwbGF5OiBcIkxJTktcIlxuICAgICAgfSwge1xuICAgICAgICB2YWx1ZTogXCJVU0RDXCIsXG4gICAgICAgIGRpc3BsYXk6IFwiVVNEQ1wiXG4gICAgICB9LCB7XG4gICAgICAgIHZhbHVlOiBcIkNIWlwiLFxuICAgICAgICBkaXNwbGF5OiBcIkNIWlwiXG4gICAgICB9LCB7XG4gICAgICAgIHZhbHVlOiBcIkJBVFwiLFxuICAgICAgICBkaXNwbGF5OiBcIkJBVFwiXG4gICAgICB9LCB7XG4gICAgICAgIHZhbHVlOiBcIk1BTkFcIixcbiAgICAgICAgZGlzcGxheTogXCJNQU5BXCJcbiAgICAgIH0sIHtcbiAgICAgICAgdmFsdWU6IFwiQUFWRVwiLFxuICAgICAgICBkaXNwbGF5OiBcIkFBVkVcIlxuICAgICAgfSwge1xuICAgICAgICB2YWx1ZTogXCJDT01QXCIsXG4gICAgICAgIGRpc3BsYXk6IFwiQ09NUFwiXG4gICAgICB9LCB7XG4gICAgICAgIHZhbHVlOiBcIkVOSlwiLFxuICAgICAgICBkaXNwbGF5OiBcIkVOSlwiXG4gICAgICB9XSxcbiAgICAgIFtTVVBQT1JURURfUEFZTUVOVF9ORVRXT1JLLk1BVElDXTogW3tcbiAgICAgICAgdmFsdWU6IFwiTUFUSUNcIixcbiAgICAgICAgZGlzcGxheTogXCJNQVRJQ1wiXG4gICAgICB9XSAvLyBbU1VQUE9SVEVEX1BBWU1FTlRfTkVUV09SSy5CU0NfTUFJTk5FVF06IFt7IHZhbHVlOiBcIkJOQlwiLCBkaXNwbGF5OiBcIkJOQlwiIH1dLFxuXG4gICAgfSxcbiAgICBpbmNsdWRlRmVlczogdHJ1ZSxcbiAgICBlbmZvcmNlTWF4OiB0cnVlXG4gIH1cbn07XG5jb25zdCB0cmFuc2xhdGlvbnMgPSB7XG4gIGVuOiB7XG4gICAgZW1iZWQ6IHtcbiAgICAgIGNvbnRpbnVlOiBcIkNvbnRpbnVlXCIsXG4gICAgICBhY3Rpb25SZXF1aXJlZDogXCJBdXRob3JpemF0aW9uIHJlcXVpcmVkXCIsXG4gICAgICBwZW5kaW5nQWN0aW9uOiBcIkNsaWNrIGNvbnRpbnVlIHRvIHByb2NlZWQgd2l0aCB5b3VyIHJlcXVlc3QgaW4gYSBwb3B1cFwiLFxuICAgICAgY29va2llc1JlcXVpcmVkOiBcIkNvb2tpZXMgUmVxdWlyZWRcIixcbiAgICAgIGVuYWJsZUNvb2tpZXM6IFwiUGxlYXNlIGVuYWJsZSBjb29raWVzIGluIHlvdXIgYnJvd3NlciBwcmVmZXJlbmNlcyB0byBhY2Nlc3MgVG9ydXNcIixcbiAgICAgIGNsaWNrSGVyZTogXCJNb3JlIEluZm9cIlxuICAgIH1cbiAgfSxcbiAgZGU6IHtcbiAgICBlbWJlZDoge1xuICAgICAgY29udGludWU6IFwiRm9ydHNldHplblwiLFxuICAgICAgYWN0aW9uUmVxdWlyZWQ6IFwiQXV0b3Jpc2llcnVuZyBlcmZvcmRlcmxpY2hcIixcbiAgICAgIHBlbmRpbmdBY3Rpb246IFwiS2xpY2tlbiBTaWUgaW4gZWluZW0gUG9wdXAgYXVmIFdlaXRlciwgdW0gbWl0IElocmVyIEFuZnJhZ2UgZm9ydHp1ZmFocmVuXCIsXG4gICAgICBjb29raWVzUmVxdWlyZWQ6IFwiQ29va2llcyBiZW7DtnRpZ3RcIixcbiAgICAgIGVuYWJsZUNvb2tpZXM6IFwiQml0dGUgYWt0aXZpZXJlbiBTaWUgQ29va2llcyBpbiBJaHJlbiBCcm93c2VyZWluc3RlbGx1bmdlbiwgdW0gYXVmIFRvcnVzIHp1enVncmVpZmVuXCIsXG4gICAgICBjbGlja0hlcmU6IFwiTWVociBJbmZvXCJcbiAgICB9XG4gIH0sXG4gIGphOiB7XG4gICAgZW1iZWQ6IHtcbiAgICAgIGNvbnRpbnVlOiBcIue2mee2muOBmeOCi1wiLFxuICAgICAgYWN0aW9uUmVxdWlyZWQ6IFwi6KqN6Ki844GM5b+F6KaB44Gn44GZXCIsXG4gICAgICBwZW5kaW5nQWN0aW9uOiBcIue2muihjOOCkuOCr+ODquODg+OCr+OBl+OBpuOAgeODneODg+ODl+OCouODg+ODl+OBp+ODquOCr+OCqOOCueODiOOCkue2muihjOOBl+OBvuOBmVwiLFxuICAgICAgY29va2llc1JlcXVpcmVkOiBcIuW/heimgeOBquOCr+ODg+OCreODvFwiLFxuICAgICAgZW5hYmxlQ29va2llczogXCJUb3J1c+OBq+OCouOCr+OCu+OCueOBmeOCi+OBq+OBr+OAgeODluODqeOCpuOCtuOBruioreWumuOBp0Nvb2tpZeOCkuacieWKueOBq+OBl+OBpuOBj+OBoOOBleOBhOOAglwiLFxuICAgICAgY2xpY2tIZXJlOiBcIuips+OBl+OBj+OBr1wiXG4gICAgfVxuICB9LFxuICBrbzoge1xuICAgIGVtYmVkOiB7XG4gICAgICBjb250aW51ZTogXCLqs4Tsho3tlZjri6RcIixcbiAgICAgIGFjdGlvblJlcXVpcmVkOiBcIuyKueyduCDtlYTsmpRcIixcbiAgICAgIHBlbmRpbmdBY3Rpb246IFwi7Yyd7JeF7JeQ7IScIOyalOyyreydhCDsp4TtlontlZjroKTrqbQg6rOE7IaN7J2EIO2BtOumre2VmOyLreyLnOyYpC5cIixcbiAgICAgIGNvb2tpZXNSZXF1aXJlZDogXCLsv6DtgqQg7ZWE7JqUXCIsXG4gICAgICBlbmFibGVDb29raWVzOiBcIuu4jOudvOyasOyggCDtmZjqsr0g7ISk7KCV7JeQ7IScIOy/oO2CpOulvCDtmZzshLHtmZTtlZjsl6wgVG9ydXPsl5Ag7JWh7IS47Iqk7ZWY7Iut7Iuc7JikLlwiLFxuICAgICAgY2xpY2tIZXJlOiBcIuuNlCDrp47snYAg7KCV67O0XCJcbiAgICB9XG4gIH0sXG4gIHpoOiB7XG4gICAgZW1iZWQ6IHtcbiAgICAgIGNvbnRpbnVlOiBcIue7p+e7rVwiLFxuICAgICAgYWN0aW9uUmVxdWlyZWQ6IFwi6ZyA6KaB5o6I5p2DXCIsXG4gICAgICBwZW5kaW5nQWN0aW9uOiBcIuWNleWHu+e7p+e7reS7peWcqOW8ueWHuueql+WPo+S4ree7p+e7reaCqOeahOivt+axglwiLFxuICAgICAgY29va2llc1JlcXVpcmVkOiBcIuW/heWhq0Nvb2tpZVwiLFxuICAgICAgZW5hYmxlQ29va2llczogXCLor7flnKjmgqjnmoTmtY/op4jlmajpppbpgInpobnkuK3lkK/nlKhjb29raWXku6Xorr/pl65Ub3J1c+OAglwiLFxuICAgICAgY2xpY2tIZXJlOiBcIuabtOWkmuS/oeaBr1wiXG4gICAgfVxuICB9XG59O1xudmFyIGNvbmZpZ3VyYXRpb24gPSB7XG4gIHN1cHBvcnRlZFZlcmlmaWVyTGlzdDogT2JqZWN0LnZhbHVlcyhXQUxMRVRfVkVSSUZJRVJTKSxcbiAgcGF5bWVudFByb3ZpZGVyczogcGF5bWVudFByb3ZpZGVycyQxLFxuICBhcGk6IFwiaHR0cHM6Ly9hcGkudG9yLnVzXCIsXG4gIHRyYW5zbGF0aW9ucyxcbiAgcHJvZFRvcnVzVXJsOiBcIlwiLFxuICBsb2NhbFN0b3JhZ2VLZXlQcmVmaXg6IGB0b3J1cy1gXG59O1xuXG5jb25zdCBydW5PbkxvYWQgPSBmbiA9PiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gIGlmICh3aW5kb3cuZG9jdW1lbnQuYm9keSAhPSBudWxsKSB7XG4gICAgUHJvbWlzZS5yZXNvbHZlKGZuKCkpLnRoZW4ocmVzb2x2ZSkuY2F0Y2gocmVqZWN0KTtcbiAgfSBlbHNlIHtcbiAgICB3aW5kb3cuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIkRPTUNvbnRlbnRMb2FkZWRcIiwgKCkgPT4ge1xuICAgICAgUHJvbWlzZS5yZXNvbHZlKGZuKCkpLnRoZW4ocmVzb2x2ZSkuY2F0Y2gocmVqZWN0KTtcbiAgICB9KTtcbiAgfVxufSk7XG5jb25zdCBodG1sVG9FbGVtZW50ID0gaHRtbCA9PiB7XG4gIGNvbnN0IHRlbXBsYXRlID0gd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ0ZW1wbGF0ZVwiKTtcbiAgY29uc3QgdHJpbW1lZEh0bWwgPSBodG1sLnRyaW0oKTsgLy8gTmV2ZXIgcmV0dXJuIGEgdGV4dCBub2RlIG9mIHdoaXRlc3BhY2UgYXMgdGhlIHJlc3VsdFxuXG4gIHRlbXBsYXRlLmlubmVySFRNTCA9IHRyaW1tZWRIdG1sO1xuICByZXR1cm4gdGVtcGxhdGUuY29udGVudC5maXJzdENoaWxkO1xufTtcbmNvbnN0IGhhbmRsZUV2ZW50ID0gZnVuY3Rpb24gKGhhbmRsZSwgZXZlbnROYW1lLCBoYW5kbGVyKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBoYW5kbGVyQXJncyA9IG5ldyBBcnJheShfbGVuID4gMyA/IF9sZW4gLSAzIDogMCksIF9rZXkgPSAzOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgaGFuZGxlckFyZ3NbX2tleSAtIDNdID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgY29uc3QgaGFuZGxlcldyYXBwZXIgPSAoKSA9PiB7XG4gICAgaGFuZGxlciguLi5oYW5kbGVyQXJncyk7XG4gICAgaGFuZGxlLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBoYW5kbGVyV3JhcHBlcik7XG4gIH07XG5cbiAgaGFuZGxlLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBoYW5kbGVyV3JhcHBlcik7XG59O1xuY29uc3QgaGFuZGxlU3RyZWFtID0gKGhhbmRsZSwgZXZlbnROYW1lLCBoYW5kbGVyKSA9PiB7XG4gIGNvbnN0IGhhbmRsZXJXcmFwcGVyID0gY2h1bmsgPT4ge1xuICAgIGhhbmRsZXIoY2h1bmspO1xuICAgIGhhbmRsZS5yZW1vdmVMaXN0ZW5lcihldmVudE5hbWUsIGhhbmRsZXJXcmFwcGVyKTtcbiAgfTtcblxuICBoYW5kbGUub24oZXZlbnROYW1lLCBoYW5kbGVyV3JhcHBlcik7XG59O1xuYXN5bmMgZnVuY3Rpb24gZG9jdW1lbnRSZWFkeSgpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgIGlmIChkb2N1bWVudC5yZWFkeVN0YXRlICE9PSBcImxvYWRpbmdcIikge1xuICAgICAgcmVzb2x2ZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBoYW5kbGVFdmVudChkb2N1bWVudCwgXCJET01Db250ZW50TG9hZGVkXCIsIHJlc29sdmUpO1xuICAgIH1cbiAgfSk7XG59XG5cbnZhciBsb2cgPSBsb2dsZXZlbC5nZXRMb2dnZXIoXCJ0b3J1cy1lbWJlZFwiKTtcblxudmFyIG1lc3NhZ2VzID0ge1xuICBlcnJvcnM6IHtcbiAgICBkaXNjb25uZWN0ZWQ6ICgpID0+IFwiVG9ydXM6IExvc3QgY29ubmVjdGlvbiB0byBUb3J1cy5cIixcbiAgICBwZXJtYW5lbnRseURpc2Nvbm5lY3RlZDogKCkgPT4gXCJUb3J1czogRGlzY29ubmVjdGVkIGZyb20gaWZyYW1lLiBQYWdlIHJlbG9hZCByZXF1aXJlZC5cIixcbiAgICBzZW5kU2l0ZU1ldGFkYXRhOiAoKSA9PiBcIlRvcnVzOiBGYWlsZWQgdG8gc2VuZCBzaXRlIG1ldGFkYXRhLiBUaGlzIGlzIGFuIGludGVybmFsIGVycm9yLCBwbGVhc2UgcmVwb3J0IHRoaXMgYnVnLlwiLFxuICAgIHVuc3VwcG9ydGVkU3luYzogbWV0aG9kID0+IGBUb3J1czogVGhlIFRvcnVzIEV0aGVyZXVtIHByb3ZpZGVyIGRvZXMgbm90IHN1cHBvcnQgc3luY2hyb25vdXMgbWV0aG9kcyBsaWtlICR7bWV0aG9kfSB3aXRob3V0IGEgY2FsbGJhY2sgcGFyYW1ldGVyLmAsXG4gICAgaW52YWxpZER1cGxleFN0cmVhbTogKCkgPT4gXCJNdXN0IHByb3ZpZGUgYSBOb2RlLmpzLXN0eWxlIGR1cGxleCBzdHJlYW0uXCIsXG4gICAgaW52YWxpZE9wdGlvbnM6IChtYXhFdmVudExpc3RlbmVycywgc2hvdWxkU2VuZE1ldGFkYXRhKSA9PiBgSW52YWxpZCBvcHRpb25zLiBSZWNlaXZlZDogeyBtYXhFdmVudExpc3RlbmVyczogJHttYXhFdmVudExpc3RlbmVyc30sIHNob3VsZFNlbmRNZXRhZGF0YTogJHtzaG91bGRTZW5kTWV0YWRhdGF9IH1gLFxuICAgIGludmFsaWRSZXF1ZXN0QXJnczogKCkgPT4gYEV4cGVjdGVkIGEgc2luZ2xlLCBub24tYXJyYXksIG9iamVjdCBhcmd1bWVudC5gLFxuICAgIGludmFsaWRSZXF1ZXN0TWV0aG9kOiAoKSA9PiBgJ2FyZ3MubWV0aG9kJyBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZy5gLFxuICAgIGludmFsaWRSZXF1ZXN0UGFyYW1zOiAoKSA9PiBgJ2FyZ3MucGFyYW1zJyBtdXN0IGJlIGFuIG9iamVjdCBvciBhcnJheSBpZiBwcm92aWRlZC5gLFxuICAgIGludmFsaWRMb2dnZXJPYmplY3Q6ICgpID0+IGAnYXJncy5sb2dnZXInIG11c3QgYmUgYW4gb2JqZWN0IGlmIHByb3ZpZGVkLmAsXG4gICAgaW52YWxpZExvZ2dlck1ldGhvZDogbWV0aG9kID0+IGAnYXJncy5sb2dnZXInIG11c3QgaW5jbHVkZSByZXF1aXJlZCBtZXRob2QgJyR7bWV0aG9kfScuYFxuICB9LFxuICBpbmZvOiB7XG4gICAgY29ubmVjdGVkOiBjaGFpbklkID0+IGBUb3J1czogQ29ubmVjdGVkIHRvIGNoYWluIHdpdGggSUQgXCIke2NoYWluSWR9XCIuYFxuICB9LFxuICB3YXJuaW5nczoge1xuICAgIC8vIGRlcHJlY2F0ZWQgbWV0aG9kc1xuICAgIGVuYWJsZURlcHJlY2F0aW9uOiAnVG9ydXM6IFwiXCJldGhlcmV1bS5lbmFibGUoKVwiIGlzIGRlcHJlY2F0ZWQgYW5kIG1heSBiZSByZW1vdmVkIGluIHRoZSBmdXR1cmUuICcgKyAnUGxlYXNlIHVzZSBcImV0aGVyZXVtLnNlbmQoXCJldGhfcmVxdWVzdEFjY291bnRzXCIpXCIgaW5zdGVhZC4gRm9yIG1vcmUgaW5mb3JtYXRpb24sIHNlZTogaHR0cHM6Ly9laXBzLmV0aGVyZXVtLm9yZy9FSVBTL2VpcC0xMTAyJyxcbiAgICBzZW5kRGVwcmVjYXRpb246ICdUb3J1czogXCJldGhlcmV1bS5zZW5kKC4uLilcIiBpcyBkZXByZWNhdGVkIGFuZCBtYXkgYmUgcmVtb3ZlZCBpbiB0aGUgZnV0dXJlLicgKyAnIFBsZWFzZSB1c2UgXCJldGhlcmV1bS5zZW5kQXN5bmMoLi4uKVwiIG9yIFwiZXRoZXJldW0ucmVxdWVzdCguLi4pXCIgaW5zdGVhZC5cXG5Gb3IgbW9yZSBpbmZvcm1hdGlvbiwgc2VlOiBodHRwczovL2VpcHMuZXRoZXJldW0ub3JnL0VJUFMvZWlwLTExOTMnLFxuICAgIGV2ZW50czoge1xuICAgICAgY2xvc2U6ICdUb3J1czogVGhlIGV2ZW50IFwiY2xvc2VcIiBpcyBkZXByZWNhdGVkIGFuZCBtYXkgYmUgcmVtb3ZlZCBpbiB0aGUgZnV0dXJlLiBQbGVhc2UgdXNlIFwiZGlzY29ubmVjdFwiIGluc3RlYWQuJyArIFwiXFxuRm9yIG1vcmUgaW5mb3JtYXRpb24sIHNlZTogaHR0cHM6Ly9laXBzLmV0aGVyZXVtLm9yZy9FSVBTL2VpcC0xMTkzXCIsXG4gICAgICBkYXRhOiAnVG9ydXM6IFRoZSBldmVudCBcImRhdGFcIiBpcyBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIGZ1dHVyZS4nICsgJ1VzZSBcIm1lc3NhZ2VcIiBpbnN0ZWFkLlxcbkZvciBtb3JlIGluZm9ybWF0aW9uLCBzZWU6IGh0dHBzOi8vZWlwcy5ldGhlcmV1bS5vcmcvRUlQUy9laXAtMTE5MyNtZXNzYWdlJyxcbiAgICAgIG5ldHdvcmtDaGFuZ2VkOiAnVG9ydXM6IFRoZSBldmVudCBcIm5ldHdvcmtDaGFuZ2VkXCIgaXMgZGVwcmVjYXRlZCBhbmQgbWF5IGJlIHJlbW92ZWQgaW4gdGhlIGZ1dHVyZS4nICsgJyBQbGVhc2UgdXNlIFwiY2hhaW5DaGFuZ2VkXCIgaW5zdGVhZC5cXG5Gb3IgbW9yZSBpbmZvcm1hdGlvbiwgc2VlOiBodHRwczovL2VpcHMuZXRoZXJldW0ub3JnL0VJUFMvZWlwLTExOTMnLFxuICAgICAgbm90aWZpY2F0aW9uOiAnVG9ydXM6IFRoZSBldmVudCBcIm5vdGlmaWNhdGlvblwiIGlzIGRlcHJlY2F0ZWQgYW5kIG1heSBiZSByZW1vdmVkIGluIHRoZSBmdXR1cmUuICcgKyAnUGxlYXNlIHVzZSBcIm1lc3NhZ2VcIiBpbnN0ZWFkLlxcbkZvciBtb3JlIGluZm9ybWF0aW9uLCBzZWU6IGh0dHBzOi8vZWlwcy5ldGhlcmV1bS5vcmcvRUlQUy9laXAtMTE5MydcbiAgICB9LFxuICAgIHB1YmxpY0NvbmZpZ1N0b3JlOiAnVG9ydXM6IFRoZSBwcm9wZXJ0eSBcInB1YmxpY0NvbmZpZ1N0b3JlXCIgaXMgZGVwcmVjYXRlZCBhbmQgV0lMTCBiZSByZW1vdmVkIGluIHRoZSBmdXR1cmUuJ1xuICB9XG59O1xuXG5jb25zdCB7XG4gIHBheW1lbnRQcm92aWRlcnNcbn0gPSBjb25maWd1cmF0aW9uO1xuY29uc3QgdmFsaWRhdGVQYXltZW50UHJvdmlkZXIgPSAocHJvdmlkZXIsIHBhcmFtcykgPT4ge1xuICBjb25zdCBlcnJvcnMgPSB7fTtcblxuICBpZiAoIXByb3ZpZGVyKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGVycm9ycyxcbiAgICAgIGlzVmFsaWQ6IHRydWVcbiAgICB9O1xuICB9XG5cbiAgaWYgKHByb3ZpZGVyICYmICFwYXltZW50UHJvdmlkZXJzW3Byb3ZpZGVyXSkge1xuICAgIGVycm9ycy5wcm92aWRlciA9IFwiSW52YWxpZCBQcm92aWRlclwiO1xuICAgIHJldHVybiB7XG4gICAgICBlcnJvcnMsXG4gICAgICBpc1ZhbGlkOiBPYmplY3Qua2V5cyhlcnJvcnMpLmxlbmd0aCA9PT0gMFxuICAgIH07XG4gIH1cblxuICBjb25zdCBzZWxlY3RlZFByb3ZpZGVyID0gcGF5bWVudFByb3ZpZGVyc1twcm92aWRlcl07XG4gIGNvbnN0IHNlbGVjdGVkUGFyYW1zID0gcGFyYW1zIHx8IHt9OyAvLyBzZXQgZGVmYXVsdCB2YWx1ZXNcbiAgLy8gaWYgKCFzZWxlY3RlZFBhcmFtcy5zZWxlY3RlZEN1cnJlbmN5KSBbc2VsZWN0ZWRQYXJhbXMuc2VsZWN0ZWRDdXJyZW5jeV0gPSBzZWxlY3RlZFByb3ZpZGVyLnZhbGlkQ3VycmVuY2llc1xuICAvLyBpZiAoIXNlbGVjdGVkUGFyYW1zLmZpYXRWYWx1ZSkgc2VsZWN0ZWRQYXJhbXMuZmlhdFZhbHVlID0gc2VsZWN0ZWRQcm92aWRlci5taW5PcmRlclZhbHVlXG4gIC8vIGlmICghc2VsZWN0ZWRQYXJhbXMuc2VsZWN0ZWRDcnlwdG9DdXJyZW5jeSkgW3NlbGVjdGVkUGFyYW1zLnNlbGVjdGVkQ3J5cHRvQ3VycmVuY3ldID0gc2VsZWN0ZWRQcm92aWRlci52YWxpZENyeXB0b0N1cnJlbmNpZXNcbiAgLy8gdmFsaWRhdGlvbnNcblxuICBpZiAoc2VsZWN0ZWRQYXJhbXMuZmlhdFZhbHVlKSB7XG4gICAgY29uc3QgcmVxdWVzdGVkT3JkZXJBbW91bnQgPSArcGFyc2VGbG9hdChzZWxlY3RlZFBhcmFtcy5maWF0VmFsdWUudG9TdHJpbmcoKSkgfHwgMDtcbiAgICBpZiAocmVxdWVzdGVkT3JkZXJBbW91bnQgPCBzZWxlY3RlZFByb3ZpZGVyLm1pbk9yZGVyVmFsdWUpIGVycm9ycy5maWF0VmFsdWUgPSBcIlJlcXVlc3RlZCBhbW91bnQgaXMgbG93ZXIgdGhhbiBzdXBwb3J0ZWRcIjtcbiAgICBpZiAocmVxdWVzdGVkT3JkZXJBbW91bnQgPiBzZWxlY3RlZFByb3ZpZGVyLm1heE9yZGVyVmFsdWUgJiYgc2VsZWN0ZWRQcm92aWRlci5lbmZvcmNlTWF4KSBlcnJvcnMuZmlhdFZhbHVlID0gXCJSZXF1ZXN0ZWQgYW1vdW50IGlzIGhpZ2hlciB0aGFuIHN1cHBvcnRlZFwiO1xuICB9XG5cbiAgaWYgKHNlbGVjdGVkUGFyYW1zLnNlbGVjdGVkQ3VycmVuY3kgJiYgIXNlbGVjdGVkUHJvdmlkZXIudmFsaWRDdXJyZW5jaWVzLmluY2x1ZGVzKHNlbGVjdGVkUGFyYW1zLnNlbGVjdGVkQ3VycmVuY3kpKSB7XG4gICAgZXJyb3JzLnNlbGVjdGVkQ3VycmVuY3kgPSBcIlVuc3VwcG9ydGVkIGN1cnJlbmN5XCI7XG4gIH1cblxuICBpZiAoc2VsZWN0ZWRQYXJhbXMuc2VsZWN0ZWRDcnlwdG9DdXJyZW5jeSkge1xuICAgIGNvbnN0IHZhbGlkQ3J5cHRvQ3VycmVuY2llc0J5Q2hhaW4gPSBPYmplY3QudmFsdWVzKHNlbGVjdGVkUHJvdmlkZXIudmFsaWRDcnlwdG9DdXJyZW5jaWVzQnlDaGFpbikuZmxhdCgpLm1hcChjdXJyZW5jeSA9PiBjdXJyZW5jeS52YWx1ZSk7XG4gICAgY29uc3QgZmluYWxDcnlwdG9DdXJyZW5jeSA9IHByb3ZpZGVyID09PSBQQVlNRU5UX1BST1ZJREVSLk1PT05QQVkgPyBzZWxlY3RlZFBhcmFtcy5zZWxlY3RlZENyeXB0b0N1cnJlbmN5LnRvTG93ZXJDYXNlKCkgOiBzZWxlY3RlZFBhcmFtcy5zZWxlY3RlZENyeXB0b0N1cnJlbmN5O1xuICAgIGlmICh2YWxpZENyeXB0b0N1cnJlbmNpZXNCeUNoYWluICYmICF2YWxpZENyeXB0b0N1cnJlbmNpZXNCeUNoYWluLmluY2x1ZGVzKGZpbmFsQ3J5cHRvQ3VycmVuY3kpKSBlcnJvcnMuc2VsZWN0ZWRDcnlwdG9DdXJyZW5jeSA9IFwiVW5zdXBwb3J0ZWQgY3J5cHRvQ3VycmVuY3lcIjtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgZXJyb3JzLFxuICAgIGlzVmFsaWQ6IE9iamVjdC5rZXlzKGVycm9ycykubGVuZ3RoID09PSAwXG4gIH07XG59OyAvLyB1dGlsaXR5IGZ1bmN0aW9uc1xuXG4vKipcbiAqIGpzb24tcnBjLWVuZ2luZSBtaWRkbGV3YXJlIHRoYXQgbG9ncyBSUEMgZXJyb3JzIGFuZCBhbmQgdmFsaWRhdGVzIHJlcS5tZXRob2QuXG4gKlxuICogQHBhcmFtIGxvZyAtIFRoZSBsb2dnaW5nIEFQSSB0byB1c2UuXG4gKiBAcmV0dXJucyAganNvbi1ycGMtZW5naW5lIG1pZGRsZXdhcmUgZnVuY3Rpb25cbiAqL1xuXG5mdW5jdGlvbiBjcmVhdGVFcnJvck1pZGRsZXdhcmUoKSB7XG4gIHJldHVybiAocmVxLCByZXMsIG5leHQpID0+IHtcbiAgICAvLyBqc29uLXJwYy1lbmdpbmUgd2lsbCB0ZXJtaW5hdGUgdGhlIHJlcXVlc3Qgd2hlbiBpdCBub3RpY2VzIHRoaXMgZXJyb3JcbiAgICBpZiAodHlwZW9mIHJlcS5tZXRob2QgIT09IFwic3RyaW5nXCIgfHwgIXJlcS5tZXRob2QpIHtcbiAgICAgIHJlcy5lcnJvciA9IGV0aEVycm9ycy5ycGMuaW52YWxpZFJlcXVlc3Qoe1xuICAgICAgICBtZXNzYWdlOiBgVGhlIHJlcXVlc3QgJ21ldGhvZCcgbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcuYCxcbiAgICAgICAgZGF0YTogcmVxXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBuZXh0KGRvbmUgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICBlcnJvclxuICAgICAgfSA9IHJlcztcblxuICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICByZXR1cm4gZG9uZSgpO1xuICAgICAgfVxuXG4gICAgICBsb2cuZXJyb3IoYE1ldGFNYXNrIC0gUlBDIEVycm9yOiAke2Vycm9yLm1lc3NhZ2V9YCwgZXJyb3IpO1xuICAgICAgcmV0dXJuIGRvbmUoKTtcbiAgICB9KTtcbiAgfTtcbn0gLy8gcmVzb2x2ZSByZXNwb25zZS5yZXN1bHQgb3IgcmVzcG9uc2UsIHJlamVjdCBlcnJvcnNcbi8qKlxuICogTG9ncyBhIHN0cmVhbSBkaXNjb25uZWN0aW9uIGVycm9yLiBFbWl0cyBhbiAnZXJyb3InIGlmIGdpdmVuIGFuXG4gKiBFdmVudEVtaXR0ZXIgdGhhdCBoYXMgbGlzdGVuZXJzIGZvciB0aGUgJ2Vycm9yJyBldmVudC5cbiAqXG4gKiBAcGFyYW0gbG9nIC0gVGhlIGxvZ2dpbmcgQVBJIHRvIHVzZS5cbiAqIEBwYXJhbSByZW1vdGVMYWJlbCAtIFRoZSBsYWJlbCBvZiB0aGUgZGlzY29ubmVjdGVkIHN0cmVhbS5cbiAqIEBwYXJhbSBlcnJvciAtIFRoZSBhc3NvY2lhdGVkIGVycm9yIHRvIGxvZy5cbiAqIEBwYXJhbSBlbWl0dGVyIC0gVGhlIGxvZ2dpbmcgQVBJIHRvIHVzZS5cbiAqL1xuXG5mdW5jdGlvbiBsb2dTdHJlYW1EaXNjb25uZWN0V2FybmluZyhyZW1vdGVMYWJlbCwgZXJyb3IsIGVtaXR0ZXIpIHtcbiAgbGV0IHdhcm5pbmdNc2cgPSBgTWV0YU1hc2s6IExvc3QgY29ubmVjdGlvbiB0byBcIiR7cmVtb3RlTGFiZWx9XCIuYDtcblxuICBpZiAoZXJyb3IgIT09IG51bGwgJiYgZXJyb3IgIT09IHZvaWQgMCAmJiBlcnJvci5zdGFjaykge1xuICAgIHdhcm5pbmdNc2cgKz0gYFxcbiR7ZXJyb3Iuc3RhY2t9YDtcbiAgfVxuXG4gIGxvZy53YXJuKHdhcm5pbmdNc2cpO1xuXG4gIGlmIChlbWl0dGVyICYmIGVtaXR0ZXIubGlzdGVuZXJDb3VudChcImVycm9yXCIpID4gMCkge1xuICAgIGVtaXR0ZXIuZW1pdChcImVycm9yXCIsIHdhcm5pbmdNc2cpO1xuICB9XG59XG5jb25zdCBnZXRQcmVvcGVuSW5zdGFuY2VJZCA9ICgpID0+IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnNsaWNlKDIpO1xuY29uc3QgZ2V0VG9ydXNVcmwgPSBhc3luYyAoYnVpbGRFbnYsIGludGVncml0eSkgPT4ge1xuICBsZXQgdG9ydXNVcmw7XG4gIGxldCBsb2dMZXZlbDsgLy8gRG8gbm90IGNoYW5nZSB0aGlzIGxpbmVcblxuICBjb25zdCB2ZXJzaW9uID0gXCIxLjM4LjNcIjtcbiAgbGV0IHZlcnNpb25Vc2VkID0gaW50ZWdyaXR5LnZlcnNpb24gfHwgdmVyc2lvbjtcblxuICB0cnkge1xuICAgIGlmICgoYnVpbGRFbnYgPT09IFwiYmluYW5jZVwiIHx8IGJ1aWxkRW52ID09PSBcInByb2R1Y3Rpb25cIikgJiYgIWludGVncml0eS52ZXJzaW9uKSB7XG4gICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICBpZiAoIWNvbmZpZ3VyYXRpb24ucHJvZFRvcnVzVXJsKSByZXNwb25zZSA9IGF3YWl0IGdldChgJHtjb25maWd1cmF0aW9uLmFwaX0vbGF0ZXN0dmVyc2lvbj9uYW1lPUB0b3J1c2xhYnMvdG9ydXMtZW1iZWQmdmVyc2lvbj0ke3ZlcnNpb259YCwge30sIHtcbiAgICAgICAgdXNlQVBJS2V5OiB0cnVlXG4gICAgICB9KTtlbHNlIHJlc3BvbnNlID0ge1xuICAgICAgICBkYXRhOiBjb25maWd1cmF0aW9uLnByb2RUb3J1c1VybFxuICAgICAgfTtcbiAgICAgIHZlcnNpb25Vc2VkID0gcmVzcG9uc2UuZGF0YTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlcXVpcmUtYXRvbWljLXVwZGF0ZXNcblxuICAgICAgY29uZmlndXJhdGlvbi5wcm9kVG9ydXNVcmwgPSByZXNwb25zZS5kYXRhO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBsb2cuZXJyb3IoZXJyb3IsIFwidW5hYmxlIHRvIGZldGNoIGxhdGVzdCB2ZXJzaW9uXCIpO1xuICB9XG5cbiAgbG9nLmluZm8oXCJ2ZXJzaW9uIHVzZWQ6IFwiLCB2ZXJzaW9uVXNlZCk7XG5cbiAgc3dpdGNoIChidWlsZEVudikge1xuICAgIGNhc2UgXCJiaW5hbmNlXCI6XG4gICAgICB0b3J1c1VybCA9IGBodHRwczovL2JpbmFuY2UudG9yLnVzL3Yke3ZlcnNpb25Vc2VkfWA7XG4gICAgICBsb2dMZXZlbCA9IFwiaW5mb1wiO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIFwidGVzdGluZ1wiOlxuICAgICAgdG9ydXNVcmwgPSBcImh0dHBzOi8vdGVzdGluZy50b3IudXNcIjtcbiAgICAgIGxvZ0xldmVsID0gXCJkZWJ1Z1wiO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIFwiYm5iXCI6XG4gICAgICB0b3J1c1VybCA9IFwiaHR0cHM6Ly9ibmIudG9yLnVzXCI7XG4gICAgICBsb2dMZXZlbCA9IFwiZXJyb3JcIjtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBcInBvbHlnb25cIjpcbiAgICAgIHRvcnVzVXJsID0gXCJodHRwczovL3BvbHlnb24udG9yLnVzXCI7XG4gICAgICBsb2dMZXZlbCA9IFwiZXJyb3JcIjtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBcImxyY1wiOlxuICAgICAgdG9ydXNVcmwgPSBcImh0dHBzOi8vbHJjLnRvci51c1wiO1xuICAgICAgbG9nTGV2ZWwgPSBcImRlYnVnXCI7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgXCJiZXRhXCI6XG4gICAgICB0b3J1c1VybCA9IFwiaHR0cHM6Ly9iZXRhLnRvci51c1wiO1xuICAgICAgbG9nTGV2ZWwgPSBcImRlYnVnXCI7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgXCJkZXZlbG9wbWVudFwiOlxuICAgICAgdG9ydXNVcmwgPSBcImh0dHA6Ly9sb2NhbGhvc3Q6NDA1MFwiO1xuICAgICAgbG9nTGV2ZWwgPSBcImRlYnVnXCI7XG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6XG4gICAgICB0b3J1c1VybCA9IGBodHRwczovL2FwcC50b3IudXMvdiR7dmVyc2lvblVzZWR9YDtcbiAgICAgIGxvZ0xldmVsID0gXCJlcnJvclwiO1xuICAgICAgYnJlYWs7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHRvcnVzVXJsLFxuICAgIGxvZ0xldmVsXG4gIH07XG59O1xuY29uc3QgZ2V0VXNlckxhbmd1YWdlID0gKCkgPT4ge1xuICBsZXQgdXNlckxhbmd1YWdlID0gd2luZG93Lm5hdmlnYXRvci5sYW5ndWFnZSB8fCBcImVuLVVTXCI7XG4gIGNvbnN0IHVzZXJMYW5ndWFnZXMgPSB1c2VyTGFuZ3VhZ2Uuc3BsaXQoXCItXCIpO1xuICB1c2VyTGFuZ3VhZ2UgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoY29uZmlndXJhdGlvbi50cmFuc2xhdGlvbnMsIHVzZXJMYW5ndWFnZXNbMF0pID8gdXNlckxhbmd1YWdlc1swXSA6IFwiZW5cIjtcbiAgcmV0dXJuIHVzZXJMYW5ndWFnZTtcbn07XG5jb25zdCBFTUlUVEVEX05PVElGSUNBVElPTlMgPSBbXCJldGhfc3Vic2NyaXB0aW9uXCIgLy8gcGVyIGV0aC1qc29uLXJwYy1maWx0ZXJzL3N1YnNjcmlwdGlvbk1hbmFnZXJcbl07XG5jb25zdCBOT09QID0gKCkgPT4gey8vIGVtcHR5IGZ1bmN0aW9uXG59O1xuY29uc3QgRkVBVFVSRVNfUFJPVklERVJfQ0hBTkdFX1dJTkRPVyA9IFwiZGlyZWN0b3JpZXM9MCx0aXRsZWJhcj0wLHRvb2xiYXI9MCxzdGF0dXM9MCxsb2NhdGlvbj0wLG1lbnViYXI9MCxoZWlnaHQ9NjYwLHdpZHRoPTM3NVwiO1xuY29uc3QgRkVBVFVSRVNfREVGQVVMVF9XQUxMRVRfV0lORE9XID0gXCJkaXJlY3Rvcmllcz0wLHRpdGxlYmFyPTAsdG9vbGJhcj0wLHN0YXR1cz0wLGxvY2F0aW9uPTAsbWVudWJhcj0wLGhlaWdodD03NDAsd2lkdGg9MTMxNVwiO1xuY29uc3QgRkVBVFVSRVNfQ09ORklSTV9XSU5ET1cgPSBcImRpcmVjdG9yaWVzPTAsdGl0bGViYXI9MCx0b29sYmFyPTAsc3RhdHVzPTAsbG9jYXRpb249MCxtZW51YmFyPTAsaGVpZ2h0PTcwMCx3aWR0aD00NTBcIjtcbmZ1bmN0aW9uIGdldFBvcHVwRmVhdHVyZXMoKSB7XG4gIC8vIEZpeGVzIGR1YWwtc2NyZWVuIHBvc2l0aW9uICAgICAgICAgICAgICAgICAgICAgICAgICAgICBNb3N0IGJyb3dzZXJzICAgICAgRmlyZWZveFxuICBjb25zdCBkdWFsU2NyZWVuTGVmdCA9IHdpbmRvdy5zY3JlZW5MZWZ0ICE9PSB1bmRlZmluZWQgPyB3aW5kb3cuc2NyZWVuTGVmdCA6IHdpbmRvdy5zY3JlZW5YO1xuICBjb25zdCBkdWFsU2NyZWVuVG9wID0gd2luZG93LnNjcmVlblRvcCAhPT0gdW5kZWZpbmVkID8gd2luZG93LnNjcmVlblRvcCA6IHdpbmRvdy5zY3JlZW5ZO1xuICBjb25zdCB3ID0gMTIwMDtcbiAgY29uc3QgaCA9IDcwMDtcbiAgY29uc3Qgd2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aCA/IHdpbmRvdy5pbm5lcldpZHRoIDogZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoID8gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoIDogd2luZG93LnNjcmVlbi53aWR0aDtcbiAgY29uc3QgaGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0ID8gd2luZG93LmlubmVySGVpZ2h0IDogZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodCA/IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQgOiB3aW5kb3cuc2NyZWVuLmhlaWdodDtcbiAgY29uc3Qgc3lzdGVtWm9vbSA9IDE7IC8vIE5vIHJlbGlhYmxlIGVzdGltYXRlXG5cbiAgY29uc3QgbGVmdCA9IE1hdGguYWJzKCh3aWR0aCAtIHcpIC8gMiAvIHN5c3RlbVpvb20gKyBkdWFsU2NyZWVuTGVmdCk7XG4gIGNvbnN0IHRvcCA9IE1hdGguYWJzKChoZWlnaHQgLSBoKSAvIDIgLyBzeXN0ZW1ab29tICsgZHVhbFNjcmVlblRvcCk7XG4gIGNvbnN0IGZlYXR1cmVzID0gYHRpdGxlYmFyPTAsdG9vbGJhcj0wLHN0YXR1cz0wLGxvY2F0aW9uPTAsbWVudWJhcj0wLGhlaWdodD0ke2ggLyBzeXN0ZW1ab29tfSx3aWR0aD0ke3cgLyBzeXN0ZW1ab29tfSx0b3A9JHt0b3B9LGxlZnQ9JHtsZWZ0fWA7XG4gIHJldHVybiBmZWF0dXJlcztcbn1cblxuZnVuY3Rpb24gb3duS2V5cyQxKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgZW51bWVyYWJsZU9ubHkgJiYgKHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KSksIGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkJDEodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBudWxsICE9IGFyZ3VtZW50c1tpXSA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpICUgMiA/IG93bktleXMkMShPYmplY3Qoc291cmNlKSwgITApLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSkgOiBvd25LZXlzJDEoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gcmV0dXJuIHRhcmdldDsgfVxuU2FmZUV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzID0gMTAwOyAvLyByZXNvbHZlIHJlc3BvbnNlLnJlc3VsdCwgcmVqZWN0IGVycm9yc1xuXG5jb25zdCBnZXRScGNQcm9taXNlQ2FsbGJhY2sgPSBmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gIGxldCB1bndyYXBSZXN1bHQgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHRydWU7XG4gIHJldHVybiAoZXJyb3IsIHJlc3BvbnNlKSA9PiB7XG4gICAgaWYgKGVycm9yIHx8IHJlc3BvbnNlLmVycm9yKSB7XG4gICAgICByZXR1cm4gcmVqZWN0KGVycm9yIHx8IHJlc3BvbnNlLmVycm9yKTtcbiAgICB9XG5cbiAgICByZXR1cm4gIXVud3JhcFJlc3VsdCB8fCBBcnJheS5pc0FycmF5KHJlc3BvbnNlKSA/IHJlc29sdmUocmVzcG9uc2UpIDogcmVzb2x2ZShyZXNwb25zZS5yZXN1bHQpO1xuICB9O1xufTtcblxuY2xhc3MgVG9ydXNJbnBhZ2VQcm92aWRlciBleHRlbmRzIFNhZmVFdmVudEVtaXR0ZXIge1xuICAvKipcbiAgICogVGhlIGNoYWluIElEIG9mIHRoZSBjdXJyZW50bHkgY29ubmVjdGVkIEV0aGVyZXVtIGNoYWluLlxuICAgKiBTZWUgW2NoYWluSWQubmV0d29ya117QGxpbmsgaHR0cHM6Ly9jaGFpbmlkLm5ldHdvcmt9IGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICAgKi9cblxuICAvKipcbiAgICogVGhlIHVzZXIncyBjdXJyZW50bHkgc2VsZWN0ZWQgRXRoZXJldW0gYWRkcmVzcy5cbiAgICogSWYgbnVsbCwgTWV0YU1hc2sgaXMgZWl0aGVyIGxvY2tlZCBvciB0aGUgdXNlciBoYXMgbm90IHBlcm1pdHRlZCBhbnlcbiAgICogYWRkcmVzc2VzIHRvIGJlIHZpZXdlZC5cbiAgICovXG5cbiAgLyoqXG4gICAqIEluZGljYXRpbmcgdGhhdCB0aGlzIHByb3ZpZGVyIGlzIGEgTWV0YU1hc2sgcHJvdmlkZXIuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihjb25uZWN0aW9uU3RyZWFtKSB7XG4gICAgbGV0IHtcbiAgICAgIG1heEV2ZW50TGlzdGVuZXJzID0gMTAwLFxuICAgICAgc2hvdWxkU2VuZE1ldGFkYXRhID0gdHJ1ZSxcbiAgICAgIGpzb25ScGNTdHJlYW1OYW1lID0gXCJwcm92aWRlclwiXG4gICAgfSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgc3VwZXIoKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNoYWluSWRcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInNlbGVjdGVkQWRkcmVzc1wiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX3JwY0VuZ2luZVwiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwibmV0d29ya1ZlcnNpb25cIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInNob3VsZFNlbmRNZXRhZGF0YVwiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiaXNUb3J1c1wiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX3B1YmxpY0NvbmZpZ1N0b3JlXCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0cnlQcmVvcGVuSGFuZGxlXCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJlbmFibGVcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9zdGF0ZVwiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX2pzb25ScGNDb25uZWN0aW9uXCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJfc2VudFdhcm5pbmdzXCIsIHtcbiAgICAgIC8vIG1ldGhvZHNcbiAgICAgIGVuYWJsZTogZmFsc2UsXG4gICAgICBleHBlcmltZW50YWxNZXRob2RzOiBmYWxzZSxcbiAgICAgIHNlbmQ6IGZhbHNlLFxuICAgICAgcHVibGljQ29uZmlnU3RvcmU6IGZhbHNlLFxuICAgICAgLy8gZXZlbnRzXG4gICAgICBldmVudHM6IHtcbiAgICAgICAgY2xvc2U6IGZhbHNlLFxuICAgICAgICBkYXRhOiBmYWxzZSxcbiAgICAgICAgbmV0d29ya0NoYW5nZWQ6IGZhbHNlLFxuICAgICAgICBub3RpZmljYXRpb246IGZhbHNlXG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAoIWR1cGxleChjb25uZWN0aW9uU3RyZWFtKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2VzLmVycm9ycy5pbnZhbGlkRHVwbGV4U3RyZWFtKCkpO1xuICAgIH1cblxuICAgIHRoaXMuaXNUb3J1cyA9IHRydWU7XG4gICAgdGhpcy5zZXRNYXhMaXN0ZW5lcnMobWF4RXZlbnRMaXN0ZW5lcnMpOyAvLyBwcml2YXRlIHN0YXRlXG5cbiAgICB0aGlzLl9zdGF0ZSA9IF9vYmplY3RTcHJlYWQkMSh7fSwgVG9ydXNJbnBhZ2VQcm92aWRlci5fZGVmYXVsdFN0YXRlKTsgLy8gcHVibGljIHN0YXRlXG5cbiAgICB0aGlzLnNlbGVjdGVkQWRkcmVzcyA9IG51bGw7XG4gICAgdGhpcy5uZXR3b3JrVmVyc2lvbiA9IG51bGw7XG4gICAgdGhpcy5jaGFpbklkID0gbnVsbDtcbiAgICB0aGlzLnNob3VsZFNlbmRNZXRhZGF0YSA9IHNob3VsZFNlbmRNZXRhZGF0YTsgLy8gYmluZCBmdW5jdGlvbnMgKHRvIHByZXZlbnQgZS5nLiB3ZWIzQDEueCBmcm9tIG1ha2luZyB1bmJvdW5kIGNhbGxzKVxuXG4gICAgdGhpcy5faGFuZGxlQWNjb3VudHNDaGFuZ2VkID0gdGhpcy5faGFuZGxlQWNjb3VudHNDaGFuZ2VkLmJpbmQodGhpcyk7XG4gICAgdGhpcy5faGFuZGxlQ2hhaW5DaGFuZ2VkID0gdGhpcy5faGFuZGxlQ2hhaW5DaGFuZ2VkLmJpbmQodGhpcyk7XG4gICAgdGhpcy5faGFuZGxlVW5sb2NrU3RhdGVDaGFuZ2VkID0gdGhpcy5faGFuZGxlVW5sb2NrU3RhdGVDaGFuZ2VkLmJpbmQodGhpcyk7XG4gICAgdGhpcy5faGFuZGxlQ29ubmVjdCA9IHRoaXMuX2hhbmRsZUNvbm5lY3QuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9oYW5kbGVEaXNjb25uZWN0ID0gdGhpcy5faGFuZGxlRGlzY29ubmVjdC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX2hhbmRsZVN0cmVhbURpc2Nvbm5lY3QgPSB0aGlzLl9oYW5kbGVTdHJlYW1EaXNjb25uZWN0LmJpbmQodGhpcyk7XG4gICAgdGhpcy5fc2VuZFN5bmMgPSB0aGlzLl9zZW5kU3luYy5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX3JwY1JlcXVlc3QgPSB0aGlzLl9ycGNSZXF1ZXN0LmJpbmQodGhpcyk7XG4gICAgdGhpcy5fd2Fybk9mRGVwcmVjYXRpb24gPSB0aGlzLl93YXJuT2ZEZXByZWNhdGlvbi5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX2luaXRpYWxpemVTdGF0ZSA9IHRoaXMuX2luaXRpYWxpemVTdGF0ZS5iaW5kKHRoaXMpO1xuICAgIHRoaXMucmVxdWVzdCA9IHRoaXMucmVxdWVzdC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuc2VuZCA9IHRoaXMuc2VuZC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuc2VuZEFzeW5jID0gdGhpcy5zZW5kQXN5bmMuYmluZCh0aGlzKTsgLy8gdGhpcy5lbmFibGUgPSB0aGlzLmVuYWJsZS5iaW5kKHRoaXMpO1xuICAgIC8vIHNldHVwIGNvbm5lY3Rpb25TdHJlYW0gbXVsdGlwbGV4aW5nXG5cbiAgICBjb25zdCBtdXggPSBuZXcgT2JqZWN0TXVsdGlwbGV4KCk7XG4gICAgcHVtcChjb25uZWN0aW9uU3RyZWFtLCBtdXgsIGNvbm5lY3Rpb25TdHJlYW0sIHRoaXMuX2hhbmRsZVN0cmVhbURpc2Nvbm5lY3QuYmluZCh0aGlzLCBcIk1ldGFNYXNrXCIpKTsgLy8gc3Vic2NyaWJlIHRvIG1ldGFtYXNrIHB1YmxpYyBjb25maWcgKG9uZS13YXkpXG5cbiAgICB0aGlzLl9wdWJsaWNDb25maWdTdG9yZSA9IG5ldyBPYnNlcnZhYmxlU3RvcmUoe1xuICAgICAgc3RvcmFnZUtleTogXCJNZXRhbWFzay1Db25maWdcIlxuICAgIH0pOyAvLyBoYW5kbGUgaXNVbmxvY2tlZCBjaGFuZ2VzLCBhbmQgY2hhaW5DaGFuZ2VkIGFuZCBuZXR3b3JrQ2hhbmdlZCBldmVudHNcbiAgICAvLyB0aGlzLl9wdWJsaWNDb25maWdTdG9yZS5zdWJzY3JpYmUoKHN0cmluZ2lmaWVkU3RhdGUpID0+IHtcbiAgICAvLyAgIC8vIFRoaXMgaXMgYmVjYXVzZSB3ZSBhcmUgdXNpbmcgc3RvcmUgYXMgc3RyaW5nXG4gICAgLy8gICBjb25zdCBzdGF0ZSA9IEpTT04ucGFyc2Uoc3RyaW5naWZpZWRTdGF0ZSBhcyB1bmtub3duIGFzIHN0cmluZyk7XG4gICAgLy8gICBpZiAoXCJpc1VubG9ja2VkXCIgaW4gc3RhdGUgJiYgc3RhdGUuaXNVbmxvY2tlZCAhPT0gdGhpcy5fc3RhdGUuaXNVbmxvY2tlZCkge1xuICAgIC8vICAgICB0aGlzLl9zdGF0ZS5pc1VubG9ja2VkID0gc3RhdGUuaXNVbmxvY2tlZDtcbiAgICAvLyAgICAgaWYgKCF0aGlzLl9zdGF0ZS5pc1VubG9ja2VkKSB7XG4gICAgLy8gICAgICAgLy8gYWNjb3VudHMgYXJlIG5ldmVyIGV4cG9zZWQgd2hlbiB0aGUgZXh0ZW5zaW9uIGlzIGxvY2tlZFxuICAgIC8vICAgICAgIHRoaXMuX2hhbmRsZUFjY291bnRzQ2hhbmdlZChbXSk7XG4gICAgLy8gICAgIH0gZWxzZSB7XG4gICAgLy8gICAgICAgLy8gdGhpcyB3aWxsIGdldCB0aGUgZXhwb3NlZCBhY2NvdW50cywgaWYgYW55XG4gICAgLy8gICAgICAgdHJ5IHtcbiAgICAvLyAgICAgICAgIHRoaXMuX3JwY1JlcXVlc3QoXG4gICAgLy8gICAgICAgICAgIHsgbWV0aG9kOiBcImV0aF9hY2NvdW50c1wiLCBwYXJhbXM6IFtdIH0sXG4gICAgLy8gICAgICAgICAgIE5PT1AsXG4gICAgLy8gICAgICAgICAgIHRydWUgLy8gaW5kaWNhdGluZyB0aGF0IGV0aF9hY2NvdW50cyBfc2hvdWxkXyB1cGRhdGUgYWNjb3VudHNcbiAgICAvLyAgICAgICAgICk7XG4gICAgLy8gICAgICAgfSBjYXRjaCAoXykge1xuICAgIC8vICAgICAgICAgLy8gU3dhbGxvdyBlcnJvclxuICAgIC8vICAgICAgIH1cbiAgICAvLyAgICAgfVxuICAgIC8vICAgfVxuICAgIC8vICAgaWYgKFwic2VsZWN0ZWRBZGRyZXNzXCIgaW4gc3RhdGUgJiYgdGhpcy5zZWxlY3RlZEFkZHJlc3MgIT09IHN0YXRlLnNlbGVjdGVkQWRkcmVzcykge1xuICAgIC8vICAgICB0cnkge1xuICAgIC8vICAgICAgIHRoaXMuX3JwY1JlcXVlc3QoXG4gICAgLy8gICAgICAgICB7IG1ldGhvZDogXCJldGhfYWNjb3VudHNcIiwgcGFyYW1zOiBbXSB9LFxuICAgIC8vICAgICAgICAgTk9PUCxcbiAgICAvLyAgICAgICAgIHRydWUgLy8gaW5kaWNhdGluZyB0aGF0IGV0aF9hY2NvdW50cyBfc2hvdWxkXyB1cGRhdGUgYWNjb3VudHNcbiAgICAvLyAgICAgICApO1xuICAgIC8vICAgICB9IGNhdGNoIChfKSB7XG4gICAgLy8gICAgICAgLy8gU3dhbGxvdyBlcnJvclxuICAgIC8vICAgICB9XG4gICAgLy8gICB9XG4gICAgLy8gICAvLyBFbWl0IGNoYWluQ2hhbmdlZCBldmVudCBvbiBjaGFpbiBjaGFuZ2VcbiAgICAvLyAgIGlmIChcImNoYWluSWRcIiBpbiBzdGF0ZSAmJiBzdGF0ZS5jaGFpbklkICE9PSB0aGlzLmNoYWluSWQpIHtcbiAgICAvLyAgICAgdGhpcy5jaGFpbklkID0gc3RhdGUuY2hhaW5JZCB8fCBudWxsO1xuICAgIC8vICAgICB0aGlzLmVtaXQoXCJjaGFpbkNoYW5nZWRcIiwgdGhpcy5jaGFpbklkKTtcbiAgICAvLyAgICAgLy8gaW5kaWNhdGUgdGhhdCB3ZSd2ZSBjb25uZWN0ZWQsIGZvciBFSVAtMTE5MyBjb21wbGlhbmNlXG4gICAgLy8gICAgIC8vIHdlIGRvIHRoaXMgaGVyZSBzbyB0aGF0IGlmcmFtZSBjYW4gaW5pdGlhbGl6ZVxuICAgIC8vICAgICBpZiAoIXRoaXMuX3N0YXRlLmhhc0VtaXR0ZWRDb25uZWN0aW9uKSB7XG4gICAgLy8gICAgICAgdGhpcy5faGFuZGxlQ29ubmVjdCh0aGlzLmNoYWluSWQpO1xuICAgIC8vICAgICAgIHRoaXMuX3N0YXRlLmhhc0VtaXR0ZWRDb25uZWN0aW9uID0gdHJ1ZTtcbiAgICAvLyAgICAgfVxuICAgIC8vICAgfVxuICAgIC8vICAgLy8gRW1pdCBuZXR3b3JrQ2hhbmdlZCBldmVudCBvbiBuZXR3b3JrIGNoYW5nZVxuICAgIC8vICAgaWYgKFwibmV0d29ya1ZlcnNpb25cIiBpbiBzdGF0ZSAmJiBzdGF0ZS5uZXR3b3JrVmVyc2lvbiAhPT0gdGhpcy5uZXR3b3JrVmVyc2lvbikge1xuICAgIC8vICAgICB0aGlzLm5ldHdvcmtWZXJzaW9uID0gc3RhdGUubmV0d29ya1ZlcnNpb24gfHwgbnVsbDtcbiAgICAvLyAgICAgdGhpcy5lbWl0KFwibmV0d29ya0NoYW5nZWRcIiwgdGhpcy5uZXR3b3JrVmVyc2lvbik7XG4gICAgLy8gICB9XG4gICAgLy8gfSk7XG5cbiAgICBwdW1wKG11eC5jcmVhdGVTdHJlYW0oXCJwdWJsaWNDb25maWdcIiksIHN0b3JlQXNTdHJlYW0odGhpcy5fcHVibGljQ29uZmlnU3RvcmUpLCAvLyBSUEMgcmVxdWVzdHMgc2hvdWxkIHN0aWxsIHdvcmsgaWYgb25seSB0aGlzIHN0cmVhbSBmYWlsc1xuICAgIGxvZ1N0cmVhbURpc2Nvbm5lY3RXYXJuaW5nLmJpbmQodGhpcywgXCJNZXRhTWFzayBQdWJsaWNDb25maWdTdG9yZVwiKSk7IC8vIGlnbm9yZSBwaGlzaGluZyB3YXJuaW5nIG1lc3NhZ2UgKGhhbmRsZWQgZWxzZXdoZXJlKVxuXG4gICAgbXV4Lmlnbm9yZVN0cmVhbShcInBoaXNoaW5nXCIpOyAvLyBzZXR1cCBvd24gZXZlbnQgbGlzdGVuZXJzXG4gICAgLy8gRUlQLTExOTMgY29ubmVjdFxuXG4gICAgdGhpcy5vbihcImNvbm5lY3RcIiwgKCkgPT4ge1xuICAgICAgdGhpcy5fc3RhdGUuaXNDb25uZWN0ZWQgPSB0cnVlO1xuICAgIH0pOyAvLyBjb25uZWN0IHRvIGFzeW5jIHByb3ZpZGVyXG5cbiAgICBjb25zdCBqc29uUnBjQ29ubmVjdGlvbiA9IGNyZWF0ZVN0cmVhbU1pZGRsZXdhcmUoKTtcbiAgICBwdW1wKGpzb25ScGNDb25uZWN0aW9uLnN0cmVhbSwgbXV4LmNyZWF0ZVN0cmVhbShqc29uUnBjU3RyZWFtTmFtZSksIGpzb25ScGNDb25uZWN0aW9uLnN0cmVhbSwgdGhpcy5faGFuZGxlU3RyZWFtRGlzY29ubmVjdC5iaW5kKHRoaXMsIFwiTWV0YU1hc2sgUnBjUHJvdmlkZXJcIikpOyAvLyBoYW5kbGUgUlBDIHJlcXVlc3RzIHZpYSBkYXBwLXNpZGUgcnBjIGVuZ2luZVxuXG4gICAgY29uc3QgcnBjRW5naW5lID0gbmV3IEpSUENFbmdpbmUoKTtcbiAgICBycGNFbmdpbmUucHVzaChjcmVhdGVJZFJlbWFwTWlkZGxld2FyZSgpKTtcbiAgICBycGNFbmdpbmUucHVzaChjcmVhdGVFcnJvck1pZGRsZXdhcmUoKSk7XG4gICAgcnBjRW5naW5lLnB1c2goanNvblJwY0Nvbm5lY3Rpb24ubWlkZGxld2FyZSk7XG4gICAgdGhpcy5fcnBjRW5naW5lID0gcnBjRW5naW5lOyAvLyBqc29uIHJwYyBub3RpZmljYXRpb24gbGlzdGVuZXJcblxuICAgIGpzb25ScGNDb25uZWN0aW9uLmV2ZW50cy5vbihcIm5vdGlmaWNhdGlvblwiLCBwYXlsb2FkID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgbWV0aG9kLFxuICAgICAgICBwYXJhbXNcbiAgICAgIH0gPSBwYXlsb2FkO1xuXG4gICAgICBpZiAobWV0aG9kID09PSBcIndhbGxldF9hY2NvdW50c0NoYW5nZWRcIikge1xuICAgICAgICB0aGlzLl9oYW5kbGVBY2NvdW50c0NoYW5nZWQocGFyYW1zKTtcbiAgICAgIH0gZWxzZSBpZiAobWV0aG9kID09PSBcIndhbGxldF91bmxvY2tTdGF0ZUNoYW5nZWRcIikge1xuICAgICAgICB0aGlzLl9oYW5kbGVVbmxvY2tTdGF0ZUNoYW5nZWQocGFyYW1zKTtcbiAgICAgIH0gZWxzZSBpZiAobWV0aG9kID09PSBcIndhbGxldF9jaGFpbkNoYW5nZWRcIikge1xuICAgICAgICB0aGlzLl9oYW5kbGVDaGFpbkNoYW5nZWQocGFyYW1zKTtcbiAgICAgIH0gZWxzZSBpZiAoRU1JVFRFRF9OT1RJRklDQVRJT05TLmluY2x1ZGVzKHBheWxvYWQubWV0aG9kKSkge1xuICAgICAgICAvLyBFSVAgMTE5MyBzdWJzY3JpcHRpb25zLCBwZXIgZXRoLWpzb24tcnBjLWZpbHRlcnMvc3Vic2NyaXB0aW9uTWFuYWdlclxuICAgICAgICB0aGlzLmVtaXQoXCJkYXRhXCIsIHBheWxvYWQpOyAvLyBkZXByZWNhdGVkXG5cbiAgICAgICAgdGhpcy5lbWl0KFwibm90aWZpY2F0aW9uXCIsIHBhcmFtcy5yZXN1bHQpO1xuICAgICAgICB0aGlzLmVtaXQoXCJtZXNzYWdlXCIsIHtcbiAgICAgICAgICB0eXBlOiBtZXRob2QsXG4gICAgICAgICAgZGF0YTogcGFyYW1zXG4gICAgICAgIH0pO1xuICAgICAgfSAvLyBCYWNrd2FyZCBjb21wYXRpYmlsaXR5IGZvciBvbGRlciBub24gRUlQIDExOTMgc3Vic2NyaXB0aW9uc1xuICAgICAgLy8gdGhpcy5lbWl0KCdkYXRhJywgbnVsbCwgcGF5bG9hZClcblxuICAgIH0pO1xuICB9XG5cbiAgZ2V0IHB1YmxpY0NvbmZpZ1N0b3JlKCkge1xuICAgIGlmICghdGhpcy5fc2VudFdhcm5pbmdzLnB1YmxpY0NvbmZpZ1N0b3JlKSB7XG4gICAgICBsb2cud2FybihtZXNzYWdlcy53YXJuaW5ncy5wdWJsaWNDb25maWdTdG9yZSk7XG4gICAgICB0aGlzLl9zZW50V2FybmluZ3MucHVibGljQ29uZmlnU3RvcmUgPSB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9wdWJsaWNDb25maWdTdG9yZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBpbnBhZ2UgcHJvdmlkZXIgaXMgY29ubmVjdGVkIHRvIFRvcnVzLlxuICAgKi9cblxuXG4gIGlzQ29ubmVjdGVkKCkge1xuICAgIHJldHVybiB0aGlzLl9zdGF0ZS5pc0Nvbm5lY3RlZDtcbiAgfVxuICAvKipcbiAgICogU3VibWl0cyBhbiBSUEMgcmVxdWVzdCBmb3IgdGhlIGdpdmVuIG1ldGhvZCwgd2l0aCB0aGUgZ2l2ZW4gcGFyYW1zLlxuICAgKiBSZXNvbHZlcyB3aXRoIHRoZSByZXN1bHQgb2YgdGhlIG1ldGhvZCBjYWxsLCBvciByZWplY3RzIG9uIGVycm9yLlxuICAgKlxuICAgKiBAcGFyYW0gYXJncyAtIFRoZSBSUEMgcmVxdWVzdCBhcmd1bWVudHMuXG4gICAqIEByZXR1cm5zIEEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggdGhlIHJlc3VsdCBvZiB0aGUgUlBDIG1ldGhvZCxcbiAgICogb3IgcmVqZWN0cyBpZiBhbiBlcnJvciBpcyBlbmNvdW50ZXJlZC5cbiAgICovXG5cblxuICBhc3luYyByZXF1ZXN0KGFyZ3MpIHtcbiAgICBpZiAoIWFyZ3MgfHwgdHlwZW9mIGFyZ3MgIT09IFwib2JqZWN0XCIgfHwgQXJyYXkuaXNBcnJheShhcmdzKSkge1xuICAgICAgdGhyb3cgZXRoRXJyb3JzLnJwYy5pbnZhbGlkUmVxdWVzdCh7XG4gICAgICAgIG1lc3NhZ2U6IG1lc3NhZ2VzLmVycm9ycy5pbnZhbGlkUmVxdWVzdEFyZ3MoKSxcbiAgICAgICAgZGF0YTogYXJnc1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgY29uc3Qge1xuICAgICAgbWV0aG9kLFxuICAgICAgcGFyYW1zXG4gICAgfSA9IGFyZ3M7XG5cbiAgICBpZiAodHlwZW9mIG1ldGhvZCAhPT0gXCJzdHJpbmdcIiB8fCBtZXRob2QubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBldGhFcnJvcnMucnBjLmludmFsaWRSZXF1ZXN0KHtcbiAgICAgICAgbWVzc2FnZTogbWVzc2FnZXMuZXJyb3JzLmludmFsaWRSZXF1ZXN0TWV0aG9kKCksXG4gICAgICAgIGRhdGE6IGFyZ3NcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChwYXJhbXMgIT09IHVuZGVmaW5lZCAmJiAhQXJyYXkuaXNBcnJheShwYXJhbXMpICYmICh0eXBlb2YgcGFyYW1zICE9PSBcIm9iamVjdFwiIHx8IHBhcmFtcyA9PT0gbnVsbCkpIHtcbiAgICAgIHRocm93IGV0aEVycm9ycy5ycGMuaW52YWxpZFJlcXVlc3Qoe1xuICAgICAgICBtZXNzYWdlOiBtZXNzYWdlcy5lcnJvcnMuaW52YWxpZFJlcXVlc3RQYXJhbXMoKSxcbiAgICAgICAgZGF0YTogYXJnc1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMuX3JwY1JlcXVlc3Qoe1xuICAgICAgICBtZXRob2QsXG4gICAgICAgIHBhcmFtc1xuICAgICAgfSwgZ2V0UnBjUHJvbWlzZUNhbGxiYWNrKHJlc29sdmUsIHJlamVjdCkpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBTdWJtaXRzIGFuIFJQQyByZXF1ZXN0IHBlciB0aGUgZ2l2ZW4gSlNPTi1SUEMgcmVxdWVzdCBvYmplY3QuXG4gICAqXG4gICAqIEBwYXJhbSBwYXlsb2FkIC0gVGhlIFJQQyByZXF1ZXN0IG9iamVjdC5cbiAgICogQHBhcmFtIGNiIC0gVGhlIGNhbGxiYWNrIGZ1bmN0aW9uLlxuICAgKi9cblxuXG4gIHNlbmRBc3luYyhwYXlsb2FkLCBjYWxsYmFjaykge1xuICAgIHRoaXMuX3JwY1JlcXVlc3QocGF5bG9hZCwgY2FsbGJhY2spO1xuICB9XG4gIC8qKlxuICAgKiBXZSBvdmVycmlkZSB0aGUgZm9sbG93aW5nIGV2ZW50IG1ldGhvZHMgc28gdGhhdCB3ZSBjYW4gd2FybiBjb25zdW1lcnNcbiAgICogYWJvdXQgZGVwcmVjYXRlZCBldmVudHM6XG4gICAqICAgYWRkTGlzdGVuZXIsIG9uLCBvbmNlLCBwcmVwZW5kTGlzdGVuZXIsIHByZXBlbmRPbmNlTGlzdGVuZXJcbiAgICovXG5cblxuICBhZGRMaXN0ZW5lcihldmVudE5hbWUsIGxpc3RlbmVyKSB7XG4gICAgdGhpcy5fd2Fybk9mRGVwcmVjYXRpb24oZXZlbnROYW1lKTtcblxuICAgIHJldHVybiBzdXBlci5hZGRMaXN0ZW5lcihldmVudE5hbWUsIGxpc3RlbmVyKTtcbiAgfVxuXG4gIG9uKGV2ZW50TmFtZSwgbGlzdGVuZXIpIHtcbiAgICB0aGlzLl93YXJuT2ZEZXByZWNhdGlvbihldmVudE5hbWUpO1xuXG4gICAgcmV0dXJuIHN1cGVyLm9uKGV2ZW50TmFtZSwgbGlzdGVuZXIpO1xuICB9XG5cbiAgb25jZShldmVudE5hbWUsIGxpc3RlbmVyKSB7XG4gICAgdGhpcy5fd2Fybk9mRGVwcmVjYXRpb24oZXZlbnROYW1lKTtcblxuICAgIHJldHVybiBzdXBlci5vbmNlKGV2ZW50TmFtZSwgbGlzdGVuZXIpO1xuICB9XG5cbiAgcHJlcGVuZExpc3RlbmVyKGV2ZW50TmFtZSwgbGlzdGVuZXIpIHtcbiAgICB0aGlzLl93YXJuT2ZEZXByZWNhdGlvbihldmVudE5hbWUpO1xuXG4gICAgcmV0dXJuIHN1cGVyLnByZXBlbmRMaXN0ZW5lcihldmVudE5hbWUsIGxpc3RlbmVyKTtcbiAgfVxuXG4gIHByZXBlbmRPbmNlTGlzdGVuZXIoZXZlbnROYW1lLCBsaXN0ZW5lcikge1xuICAgIHRoaXMuX3dhcm5PZkRlcHJlY2F0aW9uKGV2ZW50TmFtZSk7XG5cbiAgICByZXR1cm4gc3VwZXIucHJlcGVuZE9uY2VMaXN0ZW5lcihldmVudE5hbWUsIGxpc3RlbmVyKTtcbiAgfSAvLyBQcml2YXRlIE1ldGhvZHNcbiAgLy89ID09PT09PT09PT09PT09PT09PT1cblxuICAvKipcbiAgICogQ29uc3RydWN0b3IgaGVscGVyLlxuICAgKiBQb3B1bGF0ZXMgaW5pdGlhbCBzdGF0ZSBieSBjYWxsaW5nICd3YWxsZXRfZ2V0UHJvdmlkZXJTdGF0ZScgYW5kIGVtaXRzXG4gICAqIG5lY2Vzc2FyeSBldmVudHMuXG4gICAqL1xuXG5cbiAgYXN5bmMgX2luaXRpYWxpemVTdGF0ZSgpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBhY2NvdW50cyxcbiAgICAgICAgY2hhaW5JZCxcbiAgICAgICAgaXNVbmxvY2tlZCxcbiAgICAgICAgbmV0d29ya1ZlcnNpb25cbiAgICAgIH0gPSBhd2FpdCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICBtZXRob2Q6IFwid2FsbGV0X2dldFByb3ZpZGVyU3RhdGVcIlxuICAgICAgfSk7IC8vIGluZGljYXRlIHRoYXQgd2UndmUgY29ubmVjdGVkLCBmb3IgRUlQLTExOTMgY29tcGxpYW5jZVxuXG4gICAgICB0aGlzLmVtaXQoXCJjb25uZWN0XCIsIHtcbiAgICAgICAgY2hhaW5JZFxuICAgICAgfSk7XG5cbiAgICAgIHRoaXMuX2hhbmRsZUNoYWluQ2hhbmdlZCh7XG4gICAgICAgIGNoYWluSWQsXG4gICAgICAgIG5ldHdvcmtWZXJzaW9uXG4gICAgICB9KTtcblxuICAgICAgdGhpcy5faGFuZGxlVW5sb2NrU3RhdGVDaGFuZ2VkKHtcbiAgICAgICAgYWNjb3VudHMsXG4gICAgICAgIGlzVW5sb2NrZWRcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLl9oYW5kbGVBY2NvdW50c0NoYW5nZWQoYWNjb3VudHMpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBsb2cuZXJyb3IoXCJNZXRhTWFzazogRmFpbGVkIHRvIGdldCBpbml0aWFsIHN0YXRlLiBQbGVhc2UgcmVwb3J0IHRoaXMgYnVnLlwiLCBlcnJvcik7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGxvZy5pbmZvKFwiaW5pdGlhbGl6ZWQgc3RhdGVcIik7XG4gICAgICB0aGlzLl9zdGF0ZS5pbml0aWFsaXplZCA9IHRydWU7XG4gICAgICB0aGlzLmVtaXQoXCJfaW5pdGlhbGl6ZWRcIik7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBJbnRlcm5hbCBSUEMgbWV0aG9kLiBGb3J3YXJkcyByZXF1ZXN0cyB0byBiYWNrZ3JvdW5kIHZpYSB0aGUgUlBDIGVuZ2luZS5cbiAgICogQWxzbyByZW1hcCBpZHMgaW5ib3VuZCBhbmQgb3V0Ym91bmQuXG4gICAqXG4gICAqIEBwYXJhbSBwYXlsb2FkIC0gVGhlIFJQQyByZXF1ZXN0IG9iamVjdC5cbiAgICogQHBhcmFtIGNhbGxiYWNrIC0gVGhlIGNvbnN1bWVyJ3MgY2FsbGJhY2suXG4gICAqIEBwYXJhbSBpc0ludGVybmFsIC0gZmFsc2UgLSBXaGV0aGVyIHRoZSByZXF1ZXN0IGlzIGludGVybmFsLlxuICAgKi9cblxuXG4gIF9ycGNSZXF1ZXN0KHBheWxvYWQsIGNhbGxiYWNrKSB7XG4gICAgbGV0IGlzSW50ZXJuYWwgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGZhbHNlO1xuICAgIGxldCBjYiA9IGNhbGxiYWNrO1xuICAgIGNvbnN0IF9wYXlsb2FkID0gcGF5bG9hZDtcblxuICAgIGlmICghQXJyYXkuaXNBcnJheShfcGF5bG9hZCkpIHtcbiAgICAgIGlmICghX3BheWxvYWQuanNvbnJwYykge1xuICAgICAgICBfcGF5bG9hZC5qc29ucnBjID0gXCIyLjBcIjtcbiAgICAgIH1cblxuICAgICAgaWYgKF9wYXlsb2FkLm1ldGhvZCA9PT0gXCJldGhfYWNjb3VudHNcIiB8fCBfcGF5bG9hZC5tZXRob2QgPT09IFwiZXRoX3JlcXVlc3RBY2NvdW50c1wiKSB7XG4gICAgICAgIC8vIGhhbmRsZSBhY2NvdW50cyBjaGFuZ2luZ1xuICAgICAgICBjYiA9IChlcnIsIHJlcykgPT4ge1xuICAgICAgICAgIHRoaXMuX2hhbmRsZUFjY291bnRzQ2hhbmdlZChyZXMucmVzdWx0IHx8IFtdLCBfcGF5bG9hZC5tZXRob2QgPT09IFwiZXRoX2FjY291bnRzXCIsIGlzSW50ZXJuYWwpO1xuXG4gICAgICAgICAgY2FsbGJhY2soZXJyLCByZXMpO1xuICAgICAgICB9O1xuICAgICAgfSBlbHNlIGlmIChfcGF5bG9hZC5tZXRob2QgPT09IFwid2FsbGV0X2dldFByb3ZpZGVyU3RhdGVcIikge1xuICAgICAgICB0aGlzLl9ycGNFbmdpbmUuaGFuZGxlKHBheWxvYWQsIGNiKTtcblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy50cnlQcmVvcGVuSGFuZGxlKF9wYXlsb2FkLCBjYik7XG4gIH1cblxuICBzZW5kKG1ldGhvZE9yUGF5bG9hZCwgY2FsbGJhY2tPckFyZ3MpIHtcbiAgICBpZiAoIXRoaXMuX3NlbnRXYXJuaW5ncy5zZW5kKSB7XG4gICAgICBsb2cud2FybihtZXNzYWdlcy53YXJuaW5ncy5zZW5kRGVwcmVjYXRpb24pO1xuICAgICAgdGhpcy5fc2VudFdhcm5pbmdzLnNlbmQgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgbWV0aG9kT3JQYXlsb2FkID09PSBcInN0cmluZ1wiICYmICghY2FsbGJhY2tPckFyZ3MgfHwgQXJyYXkuaXNBcnJheShjYWxsYmFja09yQXJncykpKSB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHRoaXMuX3JwY1JlcXVlc3Qoe1xuICAgICAgICAgICAgbWV0aG9kOiBtZXRob2RPclBheWxvYWQsXG4gICAgICAgICAgICBwYXJhbXM6IGNhbGxiYWNrT3JBcmdzXG4gICAgICAgICAgfSwgZ2V0UnBjUHJvbWlzZUNhbGxiYWNrKHJlc29sdmUsIHJlamVjdCwgZmFsc2UpKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAobWV0aG9kT3JQYXlsb2FkICYmIHR5cGVvZiBtZXRob2RPclBheWxvYWQgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIGNhbGxiYWNrT3JBcmdzID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHJldHVybiB0aGlzLl9ycGNSZXF1ZXN0KG1ldGhvZE9yUGF5bG9hZCwgY2FsbGJhY2tPckFyZ3MpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9zZW5kU3luYyhtZXRob2RPclBheWxvYWQpO1xuICB9XG4gIC8qKlxuICAgKiBERVBSRUNBVEVELlxuICAgKiBJbnRlcm5hbCBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSBtZXRob2QsIHVzZWQgaW4gc2VuZC5cbiAgICovXG5cblxuICBfc2VuZFN5bmMocGF5bG9hZCkge1xuICAgIGxldCByZXN1bHQ7XG5cbiAgICBzd2l0Y2ggKHBheWxvYWQubWV0aG9kKSB7XG4gICAgICBjYXNlIFwiZXRoX2FjY291bnRzXCI6XG4gICAgICAgIHJlc3VsdCA9IHRoaXMuc2VsZWN0ZWRBZGRyZXNzID8gW3RoaXMuc2VsZWN0ZWRBZGRyZXNzXSA6IFtdO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBcImV0aF9jb2luYmFzZVwiOlxuICAgICAgICByZXN1bHQgPSB0aGlzLnNlbGVjdGVkQWRkcmVzcyB8fCBudWxsO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBcImV0aF91bmluc3RhbGxGaWx0ZXJcIjpcbiAgICAgICAgdGhpcy5fcnBjUmVxdWVzdChwYXlsb2FkLCBOT09QKTtcblxuICAgICAgICByZXN1bHQgPSB0cnVlO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBcIm5ldF92ZXJzaW9uXCI6XG4gICAgICAgIHJlc3VsdCA9IHRoaXMubmV0d29ya1ZlcnNpb24gfHwgbnVsbDtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlcy5lcnJvcnMudW5zdXBwb3J0ZWRTeW5jKHBheWxvYWQubWV0aG9kKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGlkOiBwYXlsb2FkLmlkLFxuICAgICAganNvbnJwYzogcGF5bG9hZC5qc29ucnBjLFxuICAgICAgcmVzdWx0XG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogV2hlbiB0aGUgcHJvdmlkZXIgYmVjb21lcyBjb25uZWN0ZWQsIHVwZGF0ZXMgaW50ZXJuYWwgc3RhdGUgYW5kIGVtaXRzXG4gICAqIHJlcXVpcmVkIGV2ZW50cy4gSWRlbXBvdGVudC5cbiAgICpcbiAgICogQHBhcmFtIGNoYWluSWQgLSBUaGUgSUQgb2YgdGhlIG5ld2x5IGNvbm5lY3RlZCBjaGFpbi5cbiAgICogZW1pdHMgTWV0YU1hc2tJbnBhZ2VQcm92aWRlciNjb25uZWN0XG4gICAqL1xuXG5cbiAgX2hhbmRsZUNvbm5lY3QoY2hhaW5JZCkge1xuICAgIGlmICghdGhpcy5fc3RhdGUuaXNDb25uZWN0ZWQpIHtcbiAgICAgIHRoaXMuX3N0YXRlLmlzQ29ubmVjdGVkID0gdHJ1ZTtcbiAgICAgIHRoaXMuZW1pdChcImNvbm5lY3RcIiwge1xuICAgICAgICBjaGFpbklkXG4gICAgICB9KTtcbiAgICAgIGxvZy5kZWJ1ZyhtZXNzYWdlcy5pbmZvLmNvbm5lY3RlZChjaGFpbklkKSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBXaGVuIHRoZSBwcm92aWRlciBiZWNvbWVzIGRpc2Nvbm5lY3RlZCwgdXBkYXRlcyBpbnRlcm5hbCBzdGF0ZSBhbmQgZW1pdHNcbiAgICogcmVxdWlyZWQgZXZlbnRzLiBJZGVtcG90ZW50IHdpdGggcmVzcGVjdCB0byB0aGUgaXNSZWNvdmVyYWJsZSBwYXJhbWV0ZXIuXG4gICAqXG4gICAqIEVycm9yIGNvZGVzIHBlciB0aGUgQ2xvc2VFdmVudCBzdGF0dXMgY29kZXMgYXMgcmVxdWlyZWQgYnkgRUlQLTExOTM6XG4gICAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9DbG9zZUV2ZW50I1N0YXR1c19jb2Rlc1xuICAgKlxuICAgKiBAcGFyYW0gaXNSZWNvdmVyYWJsZSAtIFdoZXRoZXIgdGhlIGRpc2Nvbm5lY3Rpb24gaXMgcmVjb3ZlcmFibGUuXG4gICAqIEBwYXJhbSBlcnJvck1lc3NhZ2UgLSBBIGN1c3RvbSBlcnJvciBtZXNzYWdlLlxuICAgKiBlbWl0cyBNZXRhTWFza0lucGFnZVByb3ZpZGVyI2Rpc2Nvbm5lY3RcbiAgICovXG5cblxuICBfaGFuZGxlRGlzY29ubmVjdChpc1JlY292ZXJhYmxlLCBlcnJvck1lc3NhZ2UpIHtcbiAgICBpZiAodGhpcy5fc3RhdGUuaXNDb25uZWN0ZWQgfHwgIXRoaXMuX3N0YXRlLmlzUGVybWFuZW50bHlEaXNjb25uZWN0ZWQgJiYgIWlzUmVjb3ZlcmFibGUpIHtcbiAgICAgIHRoaXMuX3N0YXRlLmlzQ29ubmVjdGVkID0gZmFsc2U7XG4gICAgICBsZXQgZXJyb3I7XG5cbiAgICAgIGlmIChpc1JlY292ZXJhYmxlKSB7XG4gICAgICAgIGVycm9yID0gbmV3IEV0aGVyZXVtUnBjRXJyb3IoMTAxMywgLy8gVHJ5IGFnYWluIGxhdGVyXG4gICAgICAgIGVycm9yTWVzc2FnZSB8fCBtZXNzYWdlcy5lcnJvcnMuZGlzY29ubmVjdGVkKCkpO1xuICAgICAgICBsb2cuZGVidWcoZXJyb3IpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXJyb3IgPSBuZXcgRXRoZXJldW1ScGNFcnJvcigxMDExLCAvLyBJbnRlcm5hbCBlcnJvclxuICAgICAgICBlcnJvck1lc3NhZ2UgfHwgbWVzc2FnZXMuZXJyb3JzLnBlcm1hbmVudGx5RGlzY29ubmVjdGVkKCkpO1xuICAgICAgICBsb2cuZXJyb3IoZXJyb3IpO1xuICAgICAgICB0aGlzLmNoYWluSWQgPSBudWxsO1xuICAgICAgICB0aGlzLl9zdGF0ZS5hY2NvdW50cyA9IG51bGw7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWRBZGRyZXNzID0gbnVsbDtcbiAgICAgICAgdGhpcy5fc3RhdGUuaXNVbmxvY2tlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9zdGF0ZS5pc1Blcm1hbmVudGx5RGlzY29ubmVjdGVkID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5lbWl0KFwiZGlzY29ubmVjdFwiLCBlcnJvcik7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBDYWxsZWQgd2hlbiBjb25uZWN0aW9uIGlzIGxvc3QgdG8gY3JpdGljYWwgc3RyZWFtcy5cbiAgICpcbiAgICogZW1pdHMgTWV0YW1hc2tJbnBhZ2VQcm92aWRlciNkaXNjb25uZWN0XG4gICAqL1xuXG5cbiAgX2hhbmRsZVN0cmVhbURpc2Nvbm5lY3Qoc3RyZWFtTmFtZSwgZXJyb3IpIHtcbiAgICBsb2dTdHJlYW1EaXNjb25uZWN0V2FybmluZyhzdHJlYW1OYW1lLCBlcnJvciwgdGhpcyk7XG5cbiAgICB0aGlzLl9oYW5kbGVEaXNjb25uZWN0KGZhbHNlLCBlcnJvciA/IGVycm9yLm1lc3NhZ2UgOiB1bmRlZmluZWQpO1xuICB9XG4gIC8qKlxuICAgKiBDYWxsZWQgd2hlbiBhY2NvdW50cyBtYXkgaGF2ZSBjaGFuZ2VkLlxuICAgKi9cblxuXG4gIF9oYW5kbGVBY2NvdW50c0NoYW5nZWQoYWNjb3VudHMpIHtcbiAgICBsZXQgaXNFdGhBY2NvdW50cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZmFsc2U7XG4gICAgbGV0IGlzSW50ZXJuYWwgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGZhbHNlO1xuICAgIC8vIGRlZmVuc2l2ZSBwcm9ncmFtbWluZ1xuICAgIGxldCBmaW5hbEFjY291bnRzID0gYWNjb3VudHM7XG5cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoZmluYWxBY2NvdW50cykpIHtcbiAgICAgIGxvZy5lcnJvcihcIk1ldGFNYXNrOiBSZWNlaXZlZCBub24tYXJyYXkgYWNjb3VudHMgcGFyYW1ldGVyLiBQbGVhc2UgcmVwb3J0IHRoaXMgYnVnLlwiLCBmaW5hbEFjY291bnRzKTtcbiAgICAgIGZpbmFsQWNjb3VudHMgPSBbXTtcbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IGFjY291bnQgb2YgYWNjb3VudHMpIHtcbiAgICAgIGlmICh0eXBlb2YgYWNjb3VudCAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICBsb2cuZXJyb3IoXCJNZXRhTWFzazogUmVjZWl2ZWQgbm9uLXN0cmluZyBhY2NvdW50LiBQbGVhc2UgcmVwb3J0IHRoaXMgYnVnLlwiLCBhY2NvdW50cyk7XG4gICAgICAgIGZpbmFsQWNjb3VudHMgPSBbXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSAvLyBlbWl0IGFjY291bnRzQ2hhbmdlZCBpZiBhbnl0aGluZyBhYm91dCB0aGUgYWNjb3VudHMgYXJyYXkgaGFzIGNoYW5nZWRcblxuXG4gICAgaWYgKCFkZXF1YWwodGhpcy5fc3RhdGUuYWNjb3VudHMsIGZpbmFsQWNjb3VudHMpKSB7XG4gICAgICAvLyB3ZSBzaG91bGQgYWx3YXlzIGhhdmUgdGhlIGNvcnJlY3QgYWNjb3VudHMgZXZlbiBiZWZvcmUgZXRoX2FjY291bnRzXG4gICAgICAvLyByZXR1cm5zLCBleGNlcHQgaW4gY2FzZXMgd2hlcmUgaXNJbnRlcm5hbCBpcyB0cnVlXG4gICAgICBpZiAoaXNFdGhBY2NvdW50cyAmJiBBcnJheS5pc0FycmF5KHRoaXMuX3N0YXRlLmFjY291bnRzKSAmJiB0aGlzLl9zdGF0ZS5hY2NvdW50cy5sZW5ndGggPiAwICYmICFpc0ludGVybmFsKSB7XG4gICAgICAgIGxvZy5lcnJvcignTWV0YU1hc2s6IFwiZXRoX2FjY291bnRzXCIgdW5leHBlY3RlZGx5IHVwZGF0ZWQgYWNjb3VudHMuIFBsZWFzZSByZXBvcnQgdGhpcyBidWcuJywgZmluYWxBY2NvdW50cyk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3N0YXRlLmFjY291bnRzID0gZmluYWxBY2NvdW50cztcbiAgICAgIHRoaXMuZW1pdChcImFjY291bnRzQ2hhbmdlZFwiLCBmaW5hbEFjY291bnRzKTtcbiAgICB9IC8vIGhhbmRsZSBzZWxlY3RlZEFkZHJlc3NcblxuXG4gICAgaWYgKHRoaXMuc2VsZWN0ZWRBZGRyZXNzICE9PSBmaW5hbEFjY291bnRzWzBdKSB7XG4gICAgICB0aGlzLnNlbGVjdGVkQWRkcmVzcyA9IGZpbmFsQWNjb3VudHNbMF0gfHwgbnVsbDtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFVwb24gcmVjZWlwdCBvZiBhIG5ldyBjaGFpbklkIGFuZCBuZXR3b3JrVmVyc2lvbiwgZW1pdHMgY29ycmVzcG9uZGluZ1xuICAgKiBldmVudHMgYW5kIHNldHMgcmVsZXZhbnQgcHVibGljIHN0YXRlLlxuICAgKiBEb2VzIG5vdGhpbmcgaWYgbmVpdGhlciB0aGUgY2hhaW5JZCBub3IgdGhlIG5ldHdvcmtWZXJzaW9uIGFyZSBkaWZmZXJlbnRcbiAgICogZnJvbSBleGlzdGluZyB2YWx1ZXMuXG4gICAqXG4gICAqIGVtaXRzIE1ldGFtYXNrSW5wYWdlUHJvdmlkZXIjY2hhaW5DaGFuZ2VkXG4gICAqIEBwYXJhbSBuZXR3b3JrSW5mbyAtIEFuIG9iamVjdCB3aXRoIG5ldHdvcmsgaW5mby5cbiAgICovXG5cblxuICBfaGFuZGxlQ2hhaW5DaGFuZ2VkKCkge1xuICAgIGxldCB7XG4gICAgICBjaGFpbklkLFxuICAgICAgbmV0d29ya1ZlcnNpb25cbiAgICB9ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuICAgIGlmICghY2hhaW5JZCB8fCAhbmV0d29ya1ZlcnNpb24pIHtcbiAgICAgIGxvZy5lcnJvcihcIk1ldGFNYXNrOiBSZWNlaXZlZCBpbnZhbGlkIG5ldHdvcmsgcGFyYW1ldGVycy4gUGxlYXNlIHJlcG9ydCB0aGlzIGJ1Zy5cIiwge1xuICAgICAgICBjaGFpbklkLFxuICAgICAgICBuZXR3b3JrVmVyc2lvblxuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG5ldHdvcmtWZXJzaW9uID09PSBcImxvYWRpbmdcIikge1xuICAgICAgdGhpcy5faGFuZGxlRGlzY29ubmVjdCh0cnVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5faGFuZGxlQ29ubmVjdChjaGFpbklkKTtcblxuICAgICAgaWYgKGNoYWluSWQgIT09IHRoaXMuY2hhaW5JZCkge1xuICAgICAgICB0aGlzLmNoYWluSWQgPSBjaGFpbklkO1xuXG4gICAgICAgIGlmICh0aGlzLl9zdGF0ZS5pbml0aWFsaXplZCkge1xuICAgICAgICAgIHRoaXMuZW1pdChcImNoYWluQ2hhbmdlZFwiLCB0aGlzLmNoYWluSWQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBVcG9uIHJlY2VpcHQgb2YgYSBuZXcgaXNVbmxvY2tlZCBzdGF0ZSwgc2V0cyByZWxldmFudCBwdWJsaWMgc3RhdGUuXG4gICAqIENhbGxzIHRoZSBhY2NvdW50cyBjaGFuZ2VkIGhhbmRsZXIgd2l0aCB0aGUgcmVjZWl2ZWQgYWNjb3VudHMsIG9yIGFuIGVtcHR5XG4gICAqIGFycmF5LlxuICAgKlxuICAgKiBEb2VzIG5vdGhpbmcgaWYgdGhlIHJlY2VpdmVkIHZhbHVlIGlzIGVxdWFsIHRvIHRoZSBleGlzdGluZyB2YWx1ZS5cbiAgICogVGhlcmUgYXJlIG5vIGxvY2svdW5sb2NrIGV2ZW50cy5cbiAgICpcbiAgICogQHBhcmFtIG9wdHMgLSBPcHRpb25zIGJhZy5cbiAgICovXG5cblxuICBfaGFuZGxlVW5sb2NrU3RhdGVDaGFuZ2VkKCkge1xuICAgIGxldCB7XG4gICAgICBhY2NvdW50cyxcbiAgICAgIGlzVW5sb2NrZWRcbiAgICB9ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuICAgIGlmICh0eXBlb2YgaXNVbmxvY2tlZCAhPT0gXCJib29sZWFuXCIpIHtcbiAgICAgIGxvZy5lcnJvcihcIk1ldGFNYXNrOiBSZWNlaXZlZCBpbnZhbGlkIGlzVW5sb2NrZWQgcGFyYW1ldGVyLiBQbGVhc2UgcmVwb3J0IHRoaXMgYnVnLlwiLCB7XG4gICAgICAgIGlzVW5sb2NrZWRcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChpc1VubG9ja2VkICE9PSB0aGlzLl9zdGF0ZS5pc1VubG9ja2VkKSB7XG4gICAgICB0aGlzLl9zdGF0ZS5pc1VubG9ja2VkID0gaXNVbmxvY2tlZDtcblxuICAgICAgdGhpcy5faGFuZGxlQWNjb3VudHNDaGFuZ2VkKGFjY291bnRzIHx8IFtdKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFdhcm5zIG9mIGRlcHJlY2F0aW9uIGZvciB0aGUgZ2l2ZW4gZXZlbnQsIGlmIGFwcGxpY2FibGUuXG4gICAqL1xuXG5cbiAgX3dhcm5PZkRlcHJlY2F0aW9uKGV2ZW50TmFtZSkge1xuICAgIGlmICh0aGlzLl9zZW50V2FybmluZ3MuZXZlbnRzW2V2ZW50TmFtZV0gPT09IGZhbHNlKSB7XG4gICAgICBsb2cud2FybihtZXNzYWdlcy53YXJuaW5ncy5ldmVudHNbZXZlbnROYW1lXSk7XG4gICAgICB0aGlzLl9zZW50V2FybmluZ3MuZXZlbnRzW2V2ZW50TmFtZV0gPSB0cnVlO1xuICAgIH1cbiAgfVxuXG59XG5cbl9kZWZpbmVQcm9wZXJ0eShUb3J1c0lucGFnZVByb3ZpZGVyLCBcIl9kZWZhdWx0U3RhdGVcIiwge1xuICBhY2NvdW50czogbnVsbCxcbiAgaXNDb25uZWN0ZWQ6IGZhbHNlLFxuICBpc1VubG9ja2VkOiBmYWxzZSxcbiAgaW5pdGlhbGl6ZWQ6IGZhbHNlLFxuICBpc1Blcm1hbmVudGx5RGlzY29ubmVjdGVkOiBmYWxzZSxcbiAgaGFzRW1pdHRlZENvbm5lY3Rpb246IGZhbHNlXG59KTtcblxuY29uc3QgZGVmYXVsdHMgPSBvcHRpb25zID0+ICh7XG4gIGFsZ29yaXRobXM6IG9wdGlvbnMuYWxnb3JpdGhtcyB8fCBbXCJzaGEyNTZcIl0sXG4gIGRlbGltaXRlcjogb3B0aW9ucy5kZWxpbWl0ZXIgfHwgXCIgXCIsXG4gIGZ1bGw6IG9wdGlvbnMuZnVsbCB8fCBmYWxzZVxufSk7IC8vIEdlbmVyYXRlIGxpc3Qgb2YgaGFzaGVzXG5cblxuY29uc3QgaGFzaGVzID0gKG9wdGlvbnMsIGRhdGEpID0+IHtcbiAgY29uc3QgaW50ZXJuYWxIYXNoZXMgPSB7fTtcbiAgb3B0aW9ucy5hbGdvcml0aG1zLmZvckVhY2goYWxnb3JpdGhtID0+IHtcbiAgICBpbnRlcm5hbEhhc2hlc1thbGdvcml0aG1dID0gY3JlYXRlSGFzaChhbGdvcml0aG0pLnVwZGF0ZShkYXRhLCBcInV0ZjhcIikuZGlnZXN0KFwiYmFzZTY0XCIpO1xuICB9KTtcbiAgcmV0dXJuIGludGVybmFsSGFzaGVzO1xufTsgLy8gQnVpbGQgYW4gaW50ZWdyaXR5IHN0cmluZ1xuXG5cbmNvbnN0IGludGVncml0eSA9IChvcHRpb25zLCBzcmkpID0+IHtcbiAgbGV0IG91dHB1dCA9IFwiXCI7IC8vIEhhc2ggbGlzdFxuXG4gIG91dHB1dCArPSBPYmplY3Qua2V5cyhzcmkuaGFzaGVzKS5tYXAoYWxnb3JpdGhtID0+IGAke2FsZ29yaXRobX0tJHtzcmkuaGFzaGVzW2FsZ29yaXRobV19YCkuam9pbihvcHRpb25zLmRlbGltaXRlcik7XG4gIHJldHVybiBvdXRwdXQ7XG59O1xuXG5jb25zdCBtYWluID0gKG9wdGlvbnMsIGRhdGEpID0+IHtcbiAgLy8gRGVmYXVsdHNcbiAgY29uc3QgZmluYWxPcHRpb25zID0gZGVmYXVsdHMob3B0aW9ucyk7XG4gIGNvbnN0IHNyaSA9IHtcbiAgICBoYXNoZXM6IGhhc2hlcyhmaW5hbE9wdGlvbnMsIGRhdGEpLFxuICAgIGludGVncml0eTogdW5kZWZpbmVkXG4gIH07XG4gIHNyaS5pbnRlZ3JpdHkgPSBpbnRlZ3JpdHkoZmluYWxPcHRpb25zLCBzcmkpO1xuICByZXR1cm4gZmluYWxPcHRpb25zLmZ1bGwgPyBzcmkgOiBzcmkuaW50ZWdyaXR5O1xufTtcblxuY2xhc3MgUG9wdXBIYW5kbGVyIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgY29uc3RydWN0b3IoX3JlZikge1xuICAgIGxldCB7XG4gICAgICB1cmwsXG4gICAgICB0YXJnZXQsXG4gICAgICBmZWF0dXJlc1xuICAgIH0gPSBfcmVmO1xuICAgIHN1cGVyKCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJ1cmxcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRhcmdldFwiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiZmVhdHVyZXNcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIndpbmRvd1wiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwid2luZG93VGltZXJcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImlDbG9zZWRXaW5kb3dcIiwgdm9pZCAwKTtcblxuICAgIHRoaXMudXJsID0gdXJsO1xuICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0IHx8IFwiX2JsYW5rXCI7XG4gICAgdGhpcy5mZWF0dXJlcyA9IGZlYXR1cmVzIHx8IGdldFBvcHVwRmVhdHVyZXMoKTtcbiAgICB0aGlzLndpbmRvdyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLndpbmRvd1RpbWVyID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuaUNsb3NlZFdpbmRvdyA9IGZhbHNlO1xuXG4gICAgdGhpcy5fc2V0dXBUaW1lcigpO1xuICB9XG5cbiAgX3NldHVwVGltZXIoKSB7XG4gICAgdGhpcy53aW5kb3dUaW1lciA9IE51bWJlcihzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICBpZiAodGhpcy53aW5kb3cgJiYgdGhpcy53aW5kb3cuY2xvc2VkKSB7XG4gICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy53aW5kb3dUaW1lcik7XG5cbiAgICAgICAgaWYgKCF0aGlzLmlDbG9zZWRXaW5kb3cpIHtcbiAgICAgICAgICB0aGlzLmVtaXQoXCJjbG9zZVwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuaUNsb3NlZFdpbmRvdyA9IGZhbHNlO1xuICAgICAgICB0aGlzLndpbmRvdyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMud2luZG93ID09PSB1bmRlZmluZWQpIGNsZWFySW50ZXJ2YWwodGhpcy53aW5kb3dUaW1lcik7XG4gICAgfSwgNTAwKSk7XG4gIH1cblxuICBvcGVuKCkge1xuICAgIHZhciBfdGhpcyR3aW5kb3c7XG5cbiAgICB0aGlzLndpbmRvdyA9IHdpbmRvdy5vcGVuKHRoaXMudXJsLmhyZWYsIHRoaXMudGFyZ2V0LCB0aGlzLmZlYXR1cmVzKTtcbiAgICBpZiAoKF90aGlzJHdpbmRvdyA9IHRoaXMud2luZG93KSAhPT0gbnVsbCAmJiBfdGhpcyR3aW5kb3cgIT09IHZvaWQgMCAmJiBfdGhpcyR3aW5kb3cuZm9jdXMpIHRoaXMud2luZG93LmZvY3VzKCk7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICB9XG5cbiAgY2xvc2UoKSB7XG4gICAgdGhpcy5pQ2xvc2VkV2luZG93ID0gdHJ1ZTtcbiAgICBpZiAodGhpcy53aW5kb3cpIHRoaXMud2luZG93LmNsb3NlKCk7XG4gIH1cblxuICByZWRpcmVjdChsb2NhdGlvblJlcGxhY2VPblJlZGlyZWN0KSB7XG4gICAgaWYgKGxvY2F0aW9uUmVwbGFjZU9uUmVkaXJlY3QpIHtcbiAgICAgIHdpbmRvdy5sb2NhdGlvbi5yZXBsYWNlKHRoaXMudXJsLmhyZWYpO1xuICAgIH0gZWxzZSB7XG4gICAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IHRoaXMudXJsLmhyZWY7XG4gICAgfVxuICB9XG5cbn1cblxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgdGhlIGdpdmVuIGltYWdlIFVSTCBleGlzdHNcbiAqIEBwYXJhbSB1cmwgLSB0aGUgdXJsIG9mIHRoZSBpbWFnZVxuICogQHJldHVybnMgLSB3aGV0aGVyIHRoZSBpbWFnZSBleGlzdHNcbiAqL1xuXG5mdW5jdGlvbiBpbWdFeGlzdHModXJsKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGltZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbWdcIik7XG5cbiAgICAgIGltZy5vbmxvYWQgPSAoKSA9PiByZXNvbHZlKHRydWUpO1xuXG4gICAgICBpbWcub25lcnJvciA9ICgpID0+IHJlc29sdmUoZmFsc2UpO1xuXG4gICAgICBpbWcuc3JjID0gdXJsO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJlamVjdChlKTtcbiAgICB9XG4gIH0pO1xufVxuLyoqXG4gKiBFeHRyYWN0cyBhIG5hbWUgZm9yIHRoZSBzaXRlIGZyb20gdGhlIERPTVxuICovXG5cblxuY29uc3QgZ2V0U2l0ZU5hbWUgPSB3aW5kb3cgPT4ge1xuICBjb25zdCB7XG4gICAgZG9jdW1lbnRcbiAgfSA9IHdpbmRvdztcbiAgY29uc3Qgc2l0ZU5hbWUgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdoZWFkID4gbWV0YVtwcm9wZXJ0eT1cIm9nOnNpdGVfbmFtZVwiXScpO1xuXG4gIGlmIChzaXRlTmFtZSkge1xuICAgIHJldHVybiBzaXRlTmFtZS5jb250ZW50O1xuICB9XG5cbiAgY29uc3QgbWV0YVRpdGxlID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignaGVhZCA+IG1ldGFbbmFtZT1cInRpdGxlXCJdJyk7XG5cbiAgaWYgKG1ldGFUaXRsZSkge1xuICAgIHJldHVybiBtZXRhVGl0bGUuY29udGVudDtcbiAgfVxuXG4gIGlmIChkb2N1bWVudC50aXRsZSAmJiBkb2N1bWVudC50aXRsZS5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LnRpdGxlO1xuICB9XG5cbiAgcmV0dXJuIHdpbmRvdy5sb2NhdGlvbi5ob3N0bmFtZTtcbn07XG4vKipcbiAqIEV4dHJhY3RzIGFuIGljb24gZm9yIHRoZSBzaXRlIGZyb20gdGhlIERPTVxuICovXG5cblxuYXN5bmMgZnVuY3Rpb24gZ2V0U2l0ZUljb24od2luZG93KSB7XG4gIGNvbnN0IHtcbiAgICBkb2N1bWVudFxuICB9ID0gd2luZG93OyAvLyBVc2UgdGhlIHNpdGUncyBmYXZpY29uIGlmIGl0IGV4aXN0c1xuXG4gIGxldCBpY29uID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignaGVhZCA+IGxpbmtbcmVsPVwic2hvcnRjdXQgaWNvblwiXScpO1xuXG4gIGlmIChpY29uICYmIChhd2FpdCBpbWdFeGlzdHMoaWNvbi5ocmVmKSkpIHtcbiAgICByZXR1cm4gaWNvbi5ocmVmO1xuICB9IC8vIFNlYXJjaCB0aHJvdWdoIGF2YWlsYWJsZSBpY29ucyBpbiBubyBwYXJ0aWN1bGFyIG9yZGVyXG5cblxuICBpY29uID0gQXJyYXkuZnJvbShkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdoZWFkID4gbGlua1tyZWw9XCJpY29uXCJdJykpLmZpbmQoX2ljb24gPT4gQm9vbGVhbihfaWNvbi5ocmVmKSk7XG5cbiAgaWYgKGljb24gJiYgKGF3YWl0IGltZ0V4aXN0cyhpY29uLmhyZWYpKSkge1xuICAgIHJldHVybiBpY29uLmhyZWY7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cbi8qKlxuICogR2V0cyBzaXRlIG1ldGFkYXRhIGFuZCByZXR1cm5zIGl0XG4gKlxuICovXG5cblxuY29uc3QgZ2V0U2l0ZU1ldGFkYXRhID0gYXN5bmMgKCkgPT4gKHtcbiAgbmFtZTogZ2V0U2l0ZU5hbWUod2luZG93KSxcbiAgaWNvbjogYXdhaXQgZ2V0U2l0ZUljb24od2luZG93KVxufSk7XG4vKipcbiAqIFNlbmRzIHNpdGUgbWV0YWRhdGEgb3ZlciBhbiBSUEMgcmVxdWVzdC5cbiAqL1xuXG5cbmFzeW5jIGZ1bmN0aW9uIHNlbmRTaXRlTWV0YWRhdGEoZW5naW5lKSB7XG4gIHRyeSB7XG4gICAgY29uc3QgZG9tYWluTWV0YWRhdGEgPSBhd2FpdCBnZXRTaXRlTWV0YWRhdGEoKTsgLy8gY2FsbCBlbmdpbmUuaGFuZGxlIGRpcmVjdGx5IHRvIGF2b2lkIG5vcm1hbCBSUEMgcmVxdWVzdCBoYW5kbGluZ1xuXG4gICAgZW5naW5lLmhhbmRsZSh7XG4gICAgICBqc29ucnBjOiBcIjIuMFwiLFxuICAgICAgaWQ6IGdldFByZW9wZW5JbnN0YW5jZUlkKCksXG4gICAgICBtZXRob2Q6IFwid2FsbGV0X3NlbmREb21haW5NZXRhZGF0YVwiLFxuICAgICAgcGFyYW1zOiBkb21haW5NZXRhZGF0YVxuICAgIH0sIE5PT1ApO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGxvZy5lcnJvcih7XG4gICAgICBtZXNzYWdlOiBtZXNzYWdlcy5lcnJvcnMuc2VuZFNpdGVNZXRhZGF0YSgpLFxuICAgICAgb3JpZ2luYWxFcnJvcjogZXJyb3JcbiAgICB9KTtcbiAgfVxufVxuXG5jb25zdCBfZXhjbHVkZWQgPSBbXCJob3N0XCIsIFwiY2hhaW5JZFwiLCBcIm5ldHdvcmtOYW1lXCJdO1xuXG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgZW51bWVyYWJsZU9ubHkgJiYgKHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KSksIGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gbnVsbCAhPSBhcmd1bWVudHNbaV0gPyBhcmd1bWVudHNbaV0gOiB7fTsgaSAlIDIgPyBvd25LZXlzKE9iamVjdChzb3VyY2UpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKSA6IG93bktleXMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gcmV0dXJuIHRhcmdldDsgfVxuY29uc3QgZGVmYXVsdFZlcmlmaWVycyA9IHtcbiAgW0xPR0lOX1BST1ZJREVSLkdPT0dMRV06IHRydWUsXG4gIFtMT0dJTl9QUk9WSURFUi5GQUNFQk9PS106IHRydWUsXG4gIFtMT0dJTl9QUk9WSURFUi5SRURESVRdOiB0cnVlLFxuICBbTE9HSU5fUFJPVklERVIuVFdJVENIXTogdHJ1ZSxcbiAgW0xPR0lOX1BST1ZJREVSLkRJU0NPUkRdOiB0cnVlXG59O1xuY29uc3QgaWZyYW1lSW50ZWdyaXR5ID0gXCJzaGEzODQtZ0JvTGlzWm9JQ1UrRzVXMEZ1dWF3ZGRiNFllL0Y3WnRtUlBSZHpVblBYQy9QcUs5RTVuYkdZN1dYdjJ1SndZMFwiO1xuY29uc3QgZXhwZWN0ZWRDYWNoZUNvbnRyb2xIZWFkZXIgPSBcIm1heC1hZ2U9MzYwMFwiO1xuY29uc3QgVU5TQUZFX01FVEhPRFMgPSBbXCJldGhfc2VuZFRyYW5zYWN0aW9uXCIsIFwiZXRoX3NpZ25UeXBlZERhdGFcIiwgXCJldGhfc2lnblR5cGVkRGF0YV92M1wiLCBcImV0aF9zaWduVHlwZWREYXRhX3Y0XCIsIFwicGVyc29uYWxfc2lnblwiLCBcImV0aF9nZXRFbmNyeXB0aW9uUHVibGljS2V5XCIsIFwiZXRoX2RlY3J5cHRcIl07IC8vIHByZWxvYWQgZm9yIGlmcmFtZSBkb2Vzbid0IHdvcmsgaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NTkzMjY3XG5cbihhc3luYyBmdW5jdGlvbiBwcmVMb2FkSWZyYW1lKCkge1xuICB0cnkge1xuICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgPT09IFwidW5kZWZpbmVkXCIpIHJldHVybjtcbiAgICBjb25zdCB0b3J1c0lmcmFtZUh0bWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibGlua1wiKTtcbiAgICBjb25zdCB7XG4gICAgICB0b3J1c1VybFxuICAgIH0gPSBhd2FpdCBnZXRUb3J1c1VybChcInByb2R1Y3Rpb25cIiwge1xuICAgICAgY2hlY2s6IGZhbHNlLFxuICAgICAgaGFzaDogaWZyYW1lSW50ZWdyaXR5LFxuICAgICAgdmVyc2lvbjogXCJcIlxuICAgIH0pO1xuICAgIHRvcnVzSWZyYW1lSHRtbC5ocmVmID0gYCR7dG9ydXNVcmx9L3BvcHVwYDtcbiAgICB0b3J1c0lmcmFtZUh0bWwuY3Jvc3NPcmlnaW4gPSBcImFub255bW91c1wiO1xuICAgIHRvcnVzSWZyYW1lSHRtbC50eXBlID0gXCJ0ZXh0L2h0bWxcIjtcbiAgICB0b3J1c0lmcmFtZUh0bWwucmVsID0gXCJwcmVmZXRjaFwiO1xuXG4gICAgaWYgKHRvcnVzSWZyYW1lSHRtbC5yZWxMaXN0ICYmIHRvcnVzSWZyYW1lSHRtbC5yZWxMaXN0LnN1cHBvcnRzKSB7XG4gICAgICBpZiAodG9ydXNJZnJhbWVIdG1sLnJlbExpc3Quc3VwcG9ydHMoXCJwcmVmZXRjaFwiKSkge1xuICAgICAgICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKHRvcnVzSWZyYW1lSHRtbCk7XG4gICAgICB9XG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGxvZy53YXJuKGVycm9yKTtcbiAgfVxufSkoKTtcblxuY2xhc3MgVG9ydXMge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBsZXQge1xuICAgICAgYnV0dG9uUG9zaXRpb24gPSBCVVRUT05fUE9TSVRJT04uQk9UVE9NX0xFRlQsXG4gICAgICBidXR0b25TaXplID0gNTYsXG4gICAgICBtb2RhbFpJbmRleCA9IDk5OTk5LFxuICAgICAgYXBpS2V5ID0gXCJ0b3J1cy1kZWZhdWx0XCJcbiAgICB9ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImJ1dHRvblBvc2l0aW9uXCIsIEJVVFRPTl9QT1NJVElPTi5CT1RUT01fTEVGVCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJidXR0b25TaXplXCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0b3J1c1VybFwiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwidG9ydXNJZnJhbWVcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInN0eWxlTGlua1wiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiaXNMb2dnZWRJblwiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiaXNJbml0aWFsaXplZFwiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwidG9ydXNXaWRnZXRWaXNpYmlsaXR5XCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0b3J1c0FsZXJ0XCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJhcGlLZXlcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm1vZGFsWkluZGV4XCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJhbGVydFpJbmRleFwiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwidG9ydXNBbGVydENvbnRhaW5lclwiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiaXNJZnJhbWVGdWxsU2NyZWVuXCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJ3aGl0ZUxhYmVsXCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJyZXF1ZXN0ZWRWZXJpZmllclwiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiY3VycmVudFZlcmlmaWVyXCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJlbWJlZFRyYW5zbGF0aW9uc1wiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiZXRoZXJldW1cIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInByb3ZpZGVyXCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJjb21tdW5pY2F0aW9uTXV4XCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJpc0xvZ2luQ2FsbGJhY2tcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInBheW1lbnRQcm92aWRlcnNcIiwgY29uZmlndXJhdGlvbi5wYXltZW50UHJvdmlkZXJzKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxvZ2luSGludFwiLCBcIlwiKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInVzZVdhbGxldENvbm5lY3RcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImlzQ3VzdG9tTG9naW5cIiwgZmFsc2UpO1xuXG4gICAgdGhpcy5idXR0b25Qb3NpdGlvbiA9IGJ1dHRvblBvc2l0aW9uO1xuICAgIHRoaXMuYnV0dG9uU2l6ZSA9IGJ1dHRvblNpemU7XG4gICAgdGhpcy50b3J1c1VybCA9IFwiXCI7XG4gICAgdGhpcy5pc0xvZ2dlZEluID0gZmFsc2U7IC8vIGV0aGVyZXVtLmVuYWJsZSB3b3JraW5nXG5cbiAgICB0aGlzLmlzSW5pdGlhbGl6ZWQgPSBmYWxzZTsgLy8gaW5pdCBkb25lXG5cbiAgICB0aGlzLnRvcnVzV2lkZ2V0VmlzaWJpbGl0eSA9IHRydWU7XG4gICAgdGhpcy5yZXF1ZXN0ZWRWZXJpZmllciA9IFwiXCI7XG4gICAgdGhpcy5jdXJyZW50VmVyaWZpZXIgPSBcIlwiOyAvLyB0aGlzLm5vZGVEZXRhaWxNYW5hZ2VyID0gbmV3IE5vZGVEZXRhaWxNYW5hZ2VyKCk7XG4gICAgLy8gdGhpcy50b3J1c0pzID0gbmV3IFRvcnVzSnMoe1xuICAgIC8vICAgbWV0YWRhdGFIb3N0OiBcImh0dHBzOi8vbWV0YWRhdGEudG9yLnVzXCIsXG4gICAgLy8gICBhbGxvd0hvc3Q6IFwiaHR0cHM6Ly9zaWduZXIudG9yLnVzL2FwaS9hbGxvd1wiLFxuICAgIC8vICAgbmV0d29yazogXCJtYWlubmV0XCIsXG4gICAgLy8gfSk7XG5cbiAgICB0aGlzLmFwaUtleSA9IGFwaUtleTtcbiAgICBzZXRBUElLZXkoYXBpS2V5KTtcbiAgICB0aGlzLm1vZGFsWkluZGV4ID0gbW9kYWxaSW5kZXg7XG4gICAgdGhpcy5hbGVydFpJbmRleCA9IG1vZGFsWkluZGV4ICsgMTAwMDtcbiAgICB0aGlzLmlzSWZyYW1lRnVsbFNjcmVlbiA9IGZhbHNlO1xuICB9XG5cbiAgYXN5bmMgaW5pdCgpIHtcbiAgICBsZXQge1xuICAgICAgYnVpbGRFbnYgPSBUT1JVU19CVUlMRF9FTlYuUFJPRFVDVElPTixcbiAgICAgIGVuYWJsZUxvZ2dpbmcgPSBmYWxzZSxcbiAgICAgIC8vIGRlcHJlY2F0ZWQ6IHVzZSBsb2dpbkNvbmZpZyBpbnN0ZWFkXG4gICAgICBlbmFibGVkVmVyaWZpZXJzID0gZGVmYXVsdFZlcmlmaWVycyxcbiAgICAgIG5ldHdvcmsgPSB7XG4gICAgICAgIGhvc3Q6IFwibWFpbm5ldFwiLFxuICAgICAgICBjaGFpbklkOiBudWxsLFxuICAgICAgICBuZXR3b3JrTmFtZTogXCJcIixcbiAgICAgICAgYmxvY2tFeHBsb3JlcjogXCJcIixcbiAgICAgICAgdGlja2VyOiBcIlwiLFxuICAgICAgICB0aWNrZXJOYW1lOiBcIlwiXG4gICAgICB9LFxuICAgICAgbG9naW5Db25maWcgPSB7fSxcbiAgICAgIHNob3dUb3J1c0J1dHRvbiA9IHRydWUsXG4gICAgICBpbnRlZ3JpdHkgPSB7XG4gICAgICAgIGNoZWNrOiBmYWxzZSxcbiAgICAgICAgaGFzaDogaWZyYW1lSW50ZWdyaXR5LFxuICAgICAgICB2ZXJzaW9uOiBcIlwiXG4gICAgICB9LFxuICAgICAgd2hpdGVMYWJlbCxcbiAgICAgIHNraXBUS2V5ID0gZmFsc2UsXG4gICAgICB1c2VXYWxsZXRDb25uZWN0ID0gZmFsc2UsXG4gICAgICBtZmFMZXZlbCA9IFwiZGVmYXVsdFwiXG4gICAgfSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgaWYgKHRoaXMuaXNJbml0aWFsaXplZCkgdGhyb3cgbmV3IEVycm9yKFwiQWxyZWFkeSBpbml0aWFsaXplZFwiKTtcbiAgICBjb25zdCB7XG4gICAgICB0b3J1c1VybCxcbiAgICAgIGxvZ0xldmVsXG4gICAgfSA9IGF3YWl0IGdldFRvcnVzVXJsKGJ1aWxkRW52LCBpbnRlZ3JpdHkpO1xuICAgIGxvZy5pbmZvKHRvcnVzVXJsLCBcInVybCBsb2FkZWRcIik7XG4gICAgdGhpcy50b3J1c1VybCA9IHRvcnVzVXJsO1xuICAgIHRoaXMud2hpdGVMYWJlbCA9IHdoaXRlTGFiZWw7XG4gICAgdGhpcy51c2VXYWxsZXRDb25uZWN0ID0gdXNlV2FsbGV0Q29ubmVjdDtcbiAgICB0aGlzLmlzQ3VzdG9tTG9naW4gPSAhIShsb2dpbkNvbmZpZyAmJiBPYmplY3Qua2V5cyhsb2dpbkNvbmZpZykubGVuZ3RoID4gMCkgfHwgISEod2hpdGVMYWJlbCAmJiBPYmplY3Qua2V5cyh3aGl0ZUxhYmVsKS5sZW5ndGggPiAwKTtcbiAgICBsb2cuc2V0RGVmYXVsdExldmVsKGxvZ0xldmVsKTtcbiAgICBpZiAoZW5hYmxlTG9nZ2luZykgbG9nLmVuYWJsZUFsbCgpO2Vsc2UgbG9nLmRpc2FibGVBbGwoKTtcbiAgICB0aGlzLnRvcnVzV2lkZ2V0VmlzaWJpbGl0eSA9IHNob3dUb3J1c0J1dHRvbjtcbiAgICBjb25zdCB0b3J1c0lmcmFtZVVybCA9IG5ldyBVUkwodG9ydXNVcmwpO1xuICAgIGlmICh0b3J1c0lmcmFtZVVybC5wYXRobmFtZS5lbmRzV2l0aChcIi9cIikpIHRvcnVzSWZyYW1lVXJsLnBhdGhuYW1lICs9IFwicG9wdXBcIjtlbHNlIHRvcnVzSWZyYW1lVXJsLnBhdGhuYW1lICs9IFwiL3BvcHVwXCI7XG4gICAgdG9ydXNJZnJhbWVVcmwuaGFzaCA9IGAjaXNDdXN0b21Mb2dpbj0ke3RoaXMuaXNDdXN0b21Mb2dpbn1gOyAvLyBJZnJhbWUgY29kZVxuXG4gICAgdGhpcy50b3J1c0lmcmFtZSA9IGh0bWxUb0VsZW1lbnQoYDxpZnJhbWVcbiAgICAgICAgaWQ9XCJ0b3J1c0lmcmFtZVwiXG4gICAgICAgIGFsbG93PSR7dXNlV2FsbGV0Q29ubmVjdCA/IFwiY2FtZXJhXCIgOiBcIlwifVxuICAgICAgICBjbGFzcz1cInRvcnVzSWZyYW1lXCJcbiAgICAgICAgc3JjPVwiJHt0b3J1c0lmcmFtZVVybC5ocmVmfVwiXG4gICAgICAgIHN0eWxlPVwiZGlzcGxheTogbm9uZTsgcG9zaXRpb246IGZpeGVkOyB0b3A6IDA7IHJpZ2h0OiAwOyB3aWR0aDogMTAwJTsgY29sb3Itc2NoZW1lOiBub25lO1xuICAgICAgICBoZWlnaHQ6IDEwMCU7IGJvcmRlcjogbm9uZTsgYm9yZGVyLXJhZGl1czogMDsgei1pbmRleDogJHt0aGlzLm1vZGFsWkluZGV4fVwiXG4gICAgICA+PC9pZnJhbWU+YCk7XG4gICAgdGhpcy50b3J1c0FsZXJ0Q29udGFpbmVyID0gaHRtbFRvRWxlbWVudCgnPGRpdiBpZD1cInRvcnVzQWxlcnRDb250YWluZXJcIj48L2Rpdj4nKTtcbiAgICB0aGlzLnRvcnVzQWxlcnRDb250YWluZXIuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgIHRoaXMudG9ydXNBbGVydENvbnRhaW5lci5zdHlsZS5zZXRQcm9wZXJ0eShcInotaW5kZXhcIiwgdGhpcy5hbGVydFpJbmRleC50b1N0cmluZygpKTtcbiAgICBjb25zdCBsaW5rID0gd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJsaW5rXCIpO1xuICAgIGxpbmsuc2V0QXR0cmlidXRlKFwicmVsXCIsIFwic3R5bGVzaGVldFwiKTtcbiAgICBsaW5rLnNldEF0dHJpYnV0ZShcInR5cGVcIiwgXCJ0ZXh0L2Nzc1wiKTtcbiAgICBsaW5rLnNldEF0dHJpYnV0ZShcImhyZWZcIiwgYCR7dG9ydXNVcmx9L2Nzcy93aWRnZXQuY3NzYCk7XG4gICAgdGhpcy5zdHlsZUxpbmsgPSBsaW5rO1xuICAgIGNvbnN0IHtcbiAgICAgIGRlZmF1bHRMYW5ndWFnZSA9IGdldFVzZXJMYW5ndWFnZSgpLFxuICAgICAgY3VzdG9tVHJhbnNsYXRpb25zID0ge31cbiAgICB9ID0gdGhpcy53aGl0ZUxhYmVsIHx8IHt9O1xuICAgIGNvbnN0IG1lcmdlZFRyYW5zbGF0aW9ucyA9IGRlZXBtZXJnZShjb25maWd1cmF0aW9uLnRyYW5zbGF0aW9ucywgY3VzdG9tVHJhbnNsYXRpb25zKTtcbiAgICBjb25zdCBsYW5ndWFnZVRyYW5zbGF0aW9ucyA9IG1lcmdlZFRyYW5zbGF0aW9uc1tkZWZhdWx0TGFuZ3VhZ2VdIHx8IGNvbmZpZ3VyYXRpb24udHJhbnNsYXRpb25zW2dldFVzZXJMYW5ndWFnZSgpXTtcbiAgICB0aGlzLmVtYmVkVHJhbnNsYXRpb25zID0gbGFuZ3VhZ2VUcmFuc2xhdGlvbnMuZW1iZWQ7XG5cbiAgICBjb25zdCBoYW5kbGVTZXR1cCA9IGFzeW5jICgpID0+IHtcbiAgICAgIGF3YWl0IGRvY3VtZW50UmVhZHkoKTtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIHRoaXMudG9ydXNJZnJhbWUub25sb2FkID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgIC8vIG9ubHkgZG8gdGhpcyBpZiBpZnJhbWUgaXMgbm90IGZ1bGwgc2NyZWVuXG4gICAgICAgICAgdGhpcy5fc2V0dXBXZWIzKCk7XG5cbiAgICAgICAgICBjb25zdCBpbml0U3RyZWFtID0gdGhpcy5jb21tdW5pY2F0aW9uTXV4LmdldFN0cmVhbShcImluaXRfc3RyZWFtXCIpO1xuICAgICAgICAgIGluaXRTdHJlYW0ub24oXCJkYXRhXCIsIGNodW5rID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgICAgZXJyb3JcbiAgICAgICAgICAgIH0gPSBjaHVuaztcblxuICAgICAgICAgICAgaWYgKG5hbWUgPT09IFwiaW5pdF9jb21wbGV0ZVwiICYmIGRhdGEuc3VjY2Vzcykge1xuICAgICAgICAgICAgICAvLyByZXNvbHZlIHByb21pc2VcbiAgICAgICAgICAgICAgdGhpcy5pc0luaXRpYWxpemVkID0gdHJ1ZTtcblxuICAgICAgICAgICAgICB0aGlzLl9kaXNwbGF5SWZyYW1lKHRoaXMuaXNJZnJhbWVGdWxsU2NyZWVuKTtcblxuICAgICAgICAgICAgICByZXNvbHZlKHVuZGVmaW5lZCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoZXJyb3IpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpbml0U3RyZWFtLndyaXRlKHtcbiAgICAgICAgICAgIG5hbWU6IFwiaW5pdF9zdHJlYW1cIixcbiAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgZW5hYmxlZFZlcmlmaWVycyxcbiAgICAgICAgICAgICAgbG9naW5Db25maWcsXG4gICAgICAgICAgICAgIHdoaXRlTGFiZWw6IHRoaXMud2hpdGVMYWJlbCxcbiAgICAgICAgICAgICAgYnV0dG9uUG9zaXRpb246IHRoaXMuYnV0dG9uUG9zaXRpb24sXG4gICAgICAgICAgICAgIGJ1dHRvblNpemU6IHRoaXMuYnV0dG9uU2l6ZSxcbiAgICAgICAgICAgICAgdG9ydXNXaWRnZXRWaXNpYmlsaXR5OiB0aGlzLnRvcnVzV2lkZ2V0VmlzaWJpbGl0eSxcbiAgICAgICAgICAgICAgYXBpS2V5OiB0aGlzLmFwaUtleSxcbiAgICAgICAgICAgICAgc2tpcFRLZXksXG4gICAgICAgICAgICAgIG5ldHdvcmssXG4gICAgICAgICAgICAgIG1mYUxldmVsXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgd2luZG93LmRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQodGhpcy5zdHlsZUxpbmspO1xuICAgICAgICB3aW5kb3cuZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0aGlzLnRvcnVzSWZyYW1lKTtcbiAgICAgICAgd2luZG93LmRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhpcy50b3J1c0FsZXJ0Q29udGFpbmVyKTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBpZiAoYnVpbGRFbnYgPT09IFwicHJvZHVjdGlvblwiICYmIGludGVncml0eS5jaGVjaykge1xuICAgICAgLy8gaGFja3kgc29sdXRpb24gdG8gY2hlY2sgZm9yIGlmcmFtZSBpbnRlZ3JpdHlcbiAgICAgIGNvbnN0IGZldGNoVXJsID0gYCR7dG9ydXNVcmx9L3BvcHVwYDtcbiAgICAgIGNvbnN0IHJlc3AgPSBhd2FpdCBmZXRjaChmZXRjaFVybCwge1xuICAgICAgICBjYWNoZTogXCJyZWxvYWRcIlxuICAgICAgfSk7XG5cbiAgICAgIGlmIChyZXNwLmhlYWRlcnMuZ2V0KFwiQ2FjaGUtQ29udHJvbFwiKSAhPT0gZXhwZWN0ZWRDYWNoZUNvbnRyb2xIZWFkZXIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmV4cGVjdGVkIENhY2hlLUNvbnRyb2wgaGVhZGVycywgZ290ICR7cmVzcC5oZWFkZXJzLmdldChcIkNhY2hlLUNvbnRyb2xcIil9YCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgcmVzcC50ZXh0KCk7XG4gICAgICBjb25zdCBjYWxjdWxhdGVkSW50ZWdyaXR5ID0gbWFpbih7XG4gICAgICAgIGFsZ29yaXRobXM6IFtcInNoYTM4NFwiXVxuICAgICAgfSwgcmVzcG9uc2UpO1xuICAgICAgbG9nLmluZm8oY2FsY3VsYXRlZEludGVncml0eSwgXCJpbnRlZ3JpdHlcIik7XG5cbiAgICAgIGlmIChjYWxjdWxhdGVkSW50ZWdyaXR5ID09PSBpbnRlZ3JpdHkuaGFzaCkge1xuICAgICAgICBhd2FpdCBoYW5kbGVTZXR1cCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5jbGVhckluaXQoKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW50ZWdyaXR5IGNoZWNrIGZhaWxlZFwiKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgYXdhaXQgaGFuZGxlU2V0dXAoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgbG9naW4oKSB7XG4gICAgbGV0IHtcbiAgICAgIHZlcmlmaWVyID0gXCJcIixcbiAgICAgIGxvZ2luX2hpbnQ6IGxvZ2luSGludCA9IFwiXCJcbiAgICB9ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICBpZiAoIXRoaXMuaXNJbml0aWFsaXplZCkgdGhyb3cgbmV3IEVycm9yKFwiQ2FsbCBpbml0KCkgZmlyc3RcIik7XG4gICAgdGhpcy5yZXF1ZXN0ZWRWZXJpZmllciA9IHZlcmlmaWVyO1xuICAgIHRoaXMubG9naW5IaW50ID0gbG9naW5IaW50O1xuICAgIHJldHVybiB0aGlzLmV0aGVyZXVtLmVuYWJsZSgpO1xuICB9XG5cbiAgbG9nb3V0KCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBpZiAoIXRoaXMuaXNMb2dnZWRJbikge1xuICAgICAgICByZWplY3QobmV3IEVycm9yKFwiVXNlciBoYXMgbm90IGxvZ2dlZCBpbiB5ZXRcIikpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGxvZ091dFN0cmVhbSA9IHRoaXMuY29tbXVuaWNhdGlvbk11eC5nZXRTdHJlYW0oXCJsb2dvdXRcIik7XG4gICAgICBsb2dPdXRTdHJlYW0ud3JpdGUoe1xuICAgICAgICBuYW1lOiBcImxvZ091dFwiXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHN0YXR1c1N0cmVhbSA9IHRoaXMuY29tbXVuaWNhdGlvbk11eC5nZXRTdHJlYW0oXCJzdGF0dXNcIik7XG5cbiAgICAgIGNvbnN0IHN0YXR1c1N0cmVhbUhhbmRsZXIgPSBzdGF0dXMgPT4ge1xuICAgICAgICBpZiAoIXN0YXR1cy5sb2dnZWRJbikge1xuICAgICAgICAgIHRoaXMuaXNMb2dnZWRJbiA9IGZhbHNlO1xuICAgICAgICAgIHRoaXMuY3VycmVudFZlcmlmaWVyID0gXCJcIjtcbiAgICAgICAgICB0aGlzLnJlcXVlc3RlZFZlcmlmaWVyID0gXCJcIjtcbiAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH0gZWxzZSByZWplY3QobmV3IEVycm9yKFwiU29tZSBFcnJvciBPY2N1cmVkXCIpKTtcbiAgICAgIH07XG5cbiAgICAgIGhhbmRsZVN0cmVhbShzdGF0dXNTdHJlYW0sIFwiZGF0YVwiLCBzdGF0dXNTdHJlYW1IYW5kbGVyKTtcbiAgICB9KTtcbiAgfVxuXG4gIGFzeW5jIGNsZWFuVXAoKSB7XG4gICAgaWYgKHRoaXMuaXNMb2dnZWRJbikge1xuICAgICAgYXdhaXQgdGhpcy5sb2dvdXQoKTtcbiAgICB9XG5cbiAgICB0aGlzLmNsZWFySW5pdCgpO1xuICB9XG5cbiAgY2xlYXJJbml0KCkge1xuICAgIGZ1bmN0aW9uIGlzRWxlbWVudChlbGVtZW50KSB7XG4gICAgICByZXR1cm4gZWxlbWVudCBpbnN0YW5jZW9mIEVsZW1lbnQgfHwgZWxlbWVudCBpbnN0YW5jZW9mIEhUTUxEb2N1bWVudDtcbiAgICB9XG5cbiAgICBpZiAoaXNFbGVtZW50KHRoaXMuc3R5bGVMaW5rKSAmJiB3aW5kb3cuZG9jdW1lbnQuYm9keS5jb250YWlucyh0aGlzLnN0eWxlTGluaykpIHtcbiAgICAgIHRoaXMuc3R5bGVMaW5rLnJlbW92ZSgpO1xuICAgICAgdGhpcy5zdHlsZUxpbmsgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgaWYgKGlzRWxlbWVudCh0aGlzLnRvcnVzSWZyYW1lKSAmJiB3aW5kb3cuZG9jdW1lbnQuYm9keS5jb250YWlucyh0aGlzLnRvcnVzSWZyYW1lKSkge1xuICAgICAgdGhpcy50b3J1c0lmcmFtZS5yZW1vdmUoKTtcbiAgICAgIHRoaXMudG9ydXNJZnJhbWUgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgaWYgKGlzRWxlbWVudCh0aGlzLnRvcnVzQWxlcnRDb250YWluZXIpICYmIHdpbmRvdy5kb2N1bWVudC5ib2R5LmNvbnRhaW5zKHRoaXMudG9ydXNBbGVydENvbnRhaW5lcikpIHtcbiAgICAgIHRoaXMudG9ydXNBbGVydCA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMudG9ydXNBbGVydENvbnRhaW5lci5yZW1vdmUoKTtcbiAgICAgIHRoaXMudG9ydXNBbGVydENvbnRhaW5lciA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICB0aGlzLmlzSW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgfVxuXG4gIGhpZGVUb3J1c0J1dHRvbigpIHtcbiAgICB0aGlzLnRvcnVzV2lkZ2V0VmlzaWJpbGl0eSA9IGZhbHNlO1xuXG4gICAgdGhpcy5fc2VuZFdpZGdldFZpc2liaWxpdHlTdGF0dXMoZmFsc2UpO1xuXG4gICAgdGhpcy5fZGlzcGxheUlmcmFtZSgpO1xuICB9XG5cbiAgc2hvd1RvcnVzQnV0dG9uKCkge1xuICAgIHRoaXMudG9ydXNXaWRnZXRWaXNpYmlsaXR5ID0gdHJ1ZTtcblxuICAgIHRoaXMuX3NlbmRXaWRnZXRWaXNpYmlsaXR5U3RhdHVzKHRydWUpO1xuXG4gICAgdGhpcy5fZGlzcGxheUlmcmFtZSgpO1xuICB9XG5cbiAgc2V0UHJvdmlkZXIoX3JlZikge1xuICAgIGxldCB7XG4gICAgICBob3N0ID0gXCJtYWlubmV0XCIsXG4gICAgICBjaGFpbklkID0gbnVsbCxcbiAgICAgIG5ldHdvcmtOYW1lID0gXCJcIlxuICAgIH0gPSBfcmVmLFxuICAgICAgICByZXN0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYsIF9leGNsdWRlZCk7XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgY29uc3QgcHJvdmlkZXJDaGFuZ2VTdHJlYW0gPSB0aGlzLmNvbW11bmljYXRpb25NdXguZ2V0U3RyZWFtKFwicHJvdmlkZXJfY2hhbmdlXCIpO1xuXG4gICAgICBjb25zdCBoYW5kbGVyID0gY2h1bmsgPT4ge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgZXJyLFxuICAgICAgICAgIHN1Y2Nlc3NcbiAgICAgICAgfSA9IGNodW5rLmRhdGE7XG4gICAgICAgIGxvZy5pbmZvKGNodW5rKTtcblxuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgIH0gZWxzZSBpZiAoc3VjY2Vzcykge1xuICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfSBlbHNlIHJlamVjdChuZXcgRXJyb3IoXCJzb21lIGVycm9yIG9jY3VyZWRcIikpO1xuICAgICAgfTtcblxuICAgICAgaGFuZGxlU3RyZWFtKHByb3ZpZGVyQ2hhbmdlU3RyZWFtLCBcImRhdGFcIiwgaGFuZGxlcik7XG4gICAgICBjb25zdCBwcmVvcGVuSW5zdGFuY2VJZCA9IGdldFByZW9wZW5JbnN0YW5jZUlkKCk7XG5cbiAgICAgIHRoaXMuX2hhbmRsZVdpbmRvdyhwcmVvcGVuSW5zdGFuY2VJZCwge1xuICAgICAgICB0YXJnZXQ6IFwiX2JsYW5rXCIsXG4gICAgICAgIGZlYXR1cmVzOiBGRUFUVVJFU19QUk9WSURFUl9DSEFOR0VfV0lORE9XXG4gICAgICB9KTtcblxuICAgICAgcHJvdmlkZXJDaGFuZ2VTdHJlYW0ud3JpdGUoe1xuICAgICAgICBuYW1lOiBcInNob3dfcHJvdmlkZXJfY2hhbmdlXCIsXG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICBuZXR3b3JrOiBfb2JqZWN0U3ByZWFkKHtcbiAgICAgICAgICAgIGhvc3QsXG4gICAgICAgICAgICBjaGFpbklkLFxuICAgICAgICAgICAgbmV0d29ya05hbWVcbiAgICAgICAgICB9LCByZXN0KSxcbiAgICAgICAgICBwcmVvcGVuSW5zdGFuY2VJZCxcbiAgICAgICAgICBvdmVycmlkZTogZmFsc2VcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBzaG93V2FsbGV0KHBhdGgpIHtcbiAgICBsZXQgcGFyYW1zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICBjb25zdCBzaG93V2FsbGV0U3RyZWFtID0gdGhpcy5jb21tdW5pY2F0aW9uTXV4LmdldFN0cmVhbShcInNob3dfd2FsbGV0XCIpO1xuICAgIGNvbnN0IGZpbmFsUGF0aCA9IHBhdGggPyBgLyR7cGF0aH1gIDogXCJcIjtcbiAgICBzaG93V2FsbGV0U3RyZWFtLndyaXRlKHtcbiAgICAgIG5hbWU6IFwic2hvd193YWxsZXRcIixcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgcGF0aDogZmluYWxQYXRoXG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBjb25zdCBzaG93V2FsbGV0SGFuZGxlciA9IGNodW5rID0+IHtcbiAgICAgIGlmIChjaHVuay5uYW1lID09PSBcInNob3dfd2FsbGV0X2luc3RhbmNlXCIpIHtcbiAgICAgICAgLy8gTGV0IHRoZSBlcnJvciBwcm9wb2dhdGUgdXAgKGhlbmNlLCBubyB0cnkgY2F0Y2gpXG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBpbnN0YW5jZUlkXG4gICAgICAgIH0gPSBjaHVuay5kYXRhO1xuICAgICAgICBjb25zdCBmaW5hbFVybCA9IG5ldyBVUkwoYCR7dGhpcy50b3J1c1VybH0vd2FsbGV0JHtmaW5hbFBhdGh9YCk7IC8vIFVzaW5nIFVSTCBjb25zdHJ1Y3RvciB0byBwcmV2ZW50IGpzIGluamVjdGlvbiBhbmQgYWxsb3cgcGFyYW1ldGVyIHZhbGlkYXRpb24uIVxuXG4gICAgICAgIGZpbmFsVXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoXCJpbnRlZ3JpdHlcIiwgXCJ0cnVlXCIpO1xuICAgICAgICBmaW5hbFVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKFwiaW5zdGFuY2VJZFwiLCBpbnN0YW5jZUlkKTtcbiAgICAgICAgT2JqZWN0LmtleXMocGFyYW1zKS5mb3JFYWNoKHggPT4ge1xuICAgICAgICAgIGZpbmFsVXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoeCwgcGFyYW1zW3hdKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGZpbmFsVXJsLmhhc2ggPSBgI2lzQ3VzdG9tTG9naW49JHt0aGlzLmlzQ3VzdG9tTG9naW59YDtcbiAgICAgICAgY29uc3Qgd2FsbGV0V2luZG93ID0gbmV3IFBvcHVwSGFuZGxlcih7XG4gICAgICAgICAgdXJsOiBmaW5hbFVybCxcbiAgICAgICAgICBmZWF0dXJlczogRkVBVFVSRVNfREVGQVVMVF9XQUxMRVRfV0lORE9XXG4gICAgICAgIH0pO1xuICAgICAgICB3YWxsZXRXaW5kb3cub3BlbigpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBoYW5kbGVTdHJlYW0oc2hvd1dhbGxldFN0cmVhbSwgXCJkYXRhXCIsIHNob3dXYWxsZXRIYW5kbGVyKTtcbiAgfVxuXG4gIGFzeW5jIGdldFB1YmxpY0FkZHJlc3MoX3JlZjIpIHtcbiAgICBsZXQge1xuICAgICAgdmVyaWZpZXIsXG4gICAgICB2ZXJpZmllcklkLFxuICAgICAgaXNFeHRlbmRlZCA9IGZhbHNlXG4gICAgfSA9IF9yZWYyO1xuICAgIGlmICghY29uZmlndXJhdGlvbi5zdXBwb3J0ZWRWZXJpZmllckxpc3QuaW5jbHVkZXModmVyaWZpZXIpIHx8ICFXQUxMRVRfT1BFTkxPR0lOX1ZFUklGSUVSX01BUFt2ZXJpZmllcl0pIHRocm93IG5ldyBFcnJvcihcIlVuc3VwcG9ydGVkIHZlcmlmaWVyXCIpO1xuICAgIGNvbnN0IHdhbGxldFZlcmlmaWVyID0gdmVyaWZpZXI7XG4gICAgY29uc3Qgb3BlbmxvZ2luVmVyaWZpZXIgPSBXQUxMRVRfT1BFTkxPR0lOX1ZFUklGSUVSX01BUFt2ZXJpZmllcl07XG4gICAgY29uc3QgdXJsID0gbmV3IFVSTChgaHR0cHM6Ly9hcGkudG9yLnVzL2xvb2t1cC90b3J1c2ApO1xuICAgIHVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKFwidmVyaWZpZXJcIiwgb3BlbmxvZ2luVmVyaWZpZXIpO1xuICAgIHVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKFwidmVyaWZpZXJJZFwiLCB2ZXJpZmllcklkKTtcbiAgICB1cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChcIndhbGxldFZlcmlmaWVyXCIsIHdhbGxldFZlcmlmaWVyKTtcbiAgICB1cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChcIm5ldHdvcmtcIiwgXCJtYWlubmV0XCIpO1xuICAgIHVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKFwiaXNFeHRlbmRlZFwiLCBpc0V4dGVuZGVkLnRvU3RyaW5nKCkpO1xuICAgIHJldHVybiBnZXQodXJsLmhyZWYsIHtcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uOyBjaGFyc2V0PXV0Zi04XCJcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICB1c2VBUElLZXk6IHRydWVcbiAgICB9KTtcbiAgfVxuXG4gIGdldFVzZXJJbmZvKG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgaWYgKHRoaXMuaXNMb2dnZWRJbikge1xuICAgICAgICBjb25zdCB1c2VySW5mb0FjY2Vzc1N0cmVhbSA9IHRoaXMuY29tbXVuaWNhdGlvbk11eC5nZXRTdHJlYW0oXCJ1c2VyX2luZm9fYWNjZXNzXCIpO1xuICAgICAgICB1c2VySW5mb0FjY2Vzc1N0cmVhbS53cml0ZSh7XG4gICAgICAgICAgbmFtZTogXCJ1c2VyX2luZm9fYWNjZXNzX3JlcXVlc3RcIlxuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCB1c2VySW5mb0FjY2Vzc0hhbmRsZXIgPSBjaHVuayA9PiB7XG4gICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgYXBwcm92ZWQsXG4gICAgICAgICAgICAgIHBheWxvYWQsXG4gICAgICAgICAgICAgIHJlamVjdGVkLFxuICAgICAgICAgICAgICBuZXdSZXF1ZXN0XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSA9IGNodW5rO1xuXG4gICAgICAgICAgaWYgKG5hbWUgPT09IFwidXNlcl9pbmZvX2FjY2Vzc19yZXNwb25zZVwiKSB7XG4gICAgICAgICAgICBpZiAoYXBwcm92ZWQpIHtcbiAgICAgICAgICAgICAgcmVzb2x2ZShwYXlsb2FkKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocmVqZWN0ZWQpIHtcbiAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihcIlVzZXIgcmVqZWN0ZWQgdGhlIHJlcXVlc3RcIikpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChuZXdSZXF1ZXN0KSB7XG4gICAgICAgICAgICAgIGNvbnN0IHVzZXJJbmZvU3RyZWFtID0gdGhpcy5jb21tdW5pY2F0aW9uTXV4LmdldFN0cmVhbShcInVzZXJfaW5mb1wiKTtcblxuICAgICAgICAgICAgICBjb25zdCB1c2VySW5mb0hhbmRsZXIgPSBoYW5kbGVyQ2h1bmsgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChoYW5kbGVyQ2h1bmsubmFtZSA9PT0gXCJ1c2VyX2luZm9fcmVzcG9uc2VcIikge1xuICAgICAgICAgICAgICAgICAgaWYgKGhhbmRsZXJDaHVuay5kYXRhLmFwcHJvdmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoaGFuZGxlckNodW5rLmRhdGEucGF5bG9hZCk7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKFwiVXNlciByZWplY3RlZCB0aGUgcmVxdWVzdFwiKSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgIGhhbmRsZVN0cmVhbSh1c2VySW5mb1N0cmVhbSwgXCJkYXRhXCIsIHVzZXJJbmZvSGFuZGxlcik7XG4gICAgICAgICAgICAgIGNvbnN0IHByZW9wZW5JbnN0YW5jZUlkID0gZ2V0UHJlb3Blbkluc3RhbmNlSWQoKTtcblxuICAgICAgICAgICAgICB0aGlzLl9oYW5kbGVXaW5kb3cocHJlb3Blbkluc3RhbmNlSWQsIHtcbiAgICAgICAgICAgICAgICB0YXJnZXQ6IFwiX2JsYW5rXCIsXG4gICAgICAgICAgICAgICAgZmVhdHVyZXM6IEZFQVRVUkVTX1BST1ZJREVSX0NIQU5HRV9XSU5ET1dcbiAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgdXNlckluZm9TdHJlYW0ud3JpdGUoe1xuICAgICAgICAgICAgICAgIG5hbWU6IFwidXNlcl9pbmZvX3JlcXVlc3RcIixcbiAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICBtZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgcHJlb3Blbkluc3RhbmNlSWRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBoYW5kbGVTdHJlYW0odXNlckluZm9BY2Nlc3NTdHJlYW0sIFwiZGF0YVwiLCB1c2VySW5mb0FjY2Vzc0hhbmRsZXIpO1xuICAgICAgfSBlbHNlIHJlamVjdChuZXcgRXJyb3IoXCJVc2VyIGhhcyBub3QgbG9nZ2VkIGluIHlldFwiKSk7XG4gICAgfSk7XG4gIH1cblxuICBpbml0aWF0ZVRvcHVwKHByb3ZpZGVyLCBwYXJhbXMpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgaWYgKHRoaXMuaXNJbml0aWFsaXplZCkge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgZXJyb3JzLFxuICAgICAgICAgIGlzVmFsaWRcbiAgICAgICAgfSA9IHZhbGlkYXRlUGF5bWVudFByb3ZpZGVyKHByb3ZpZGVyLCBwYXJhbXMpO1xuXG4gICAgICAgIGlmICghaXNWYWxpZCkge1xuICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoSlNPTi5zdHJpbmdpZnkoZXJyb3JzKSkpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHRvcHVwU3RyZWFtID0gdGhpcy5jb21tdW5pY2F0aW9uTXV4LmdldFN0cmVhbShcInRvcHVwXCIpO1xuXG4gICAgICAgIGNvbnN0IHRvcHVwSGFuZGxlciA9IGNodW5rID0+IHtcbiAgICAgICAgICBpZiAoY2h1bmsubmFtZSA9PT0gXCJ0b3B1cF9yZXNwb25zZVwiKSB7XG4gICAgICAgICAgICBpZiAoY2h1bmsuZGF0YS5zdWNjZXNzKSB7XG4gICAgICAgICAgICAgIHJlc29sdmUoY2h1bmsuZGF0YS5zdWNjZXNzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoY2h1bmsuZGF0YS5lcnJvcikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBoYW5kbGVTdHJlYW0odG9wdXBTdHJlYW0sIFwiZGF0YVwiLCB0b3B1cEhhbmRsZXIpO1xuICAgICAgICBjb25zdCBwcmVvcGVuSW5zdGFuY2VJZCA9IGdldFByZW9wZW5JbnN0YW5jZUlkKCk7XG5cbiAgICAgICAgdGhpcy5faGFuZGxlV2luZG93KHByZW9wZW5JbnN0YW5jZUlkKTtcblxuICAgICAgICB0b3B1cFN0cmVhbS53cml0ZSh7XG4gICAgICAgICAgbmFtZTogXCJ0b3B1cF9yZXF1ZXN0XCIsXG4gICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgcHJvdmlkZXIsXG4gICAgICAgICAgICBwYXJhbXMsXG4gICAgICAgICAgICBwcmVvcGVuSW5zdGFuY2VJZFxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgcmVqZWN0KG5ldyBFcnJvcihcIlRvcnVzIGlzIG5vdCBpbml0aWFsaXplZCB5ZXRcIikpO1xuICAgIH0pO1xuICB9XG5cbiAgYXN5bmMgbG9naW5XaXRoUHJpdmF0ZUtleShsb2dpblBhcmFtcykge1xuICAgIGNvbnN0IHtcbiAgICAgIHByaXZhdGVLZXksXG4gICAgICB1c2VySW5mb1xuICAgIH0gPSBsb2dpblBhcmFtcztcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgaWYgKHRoaXMuaXNJbml0aWFsaXplZCkge1xuICAgICAgICBpZiAoQnVmZmVyLmZyb20ocHJpdmF0ZUtleSwgXCJoZXhcIikubGVuZ3RoICE9PSAzMikge1xuICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoXCJJbnZhbGlkIHByaXZhdGUga2V5LCBQbGVhc2UgcHJvdmlkZSBhIDMyIGJ5dGUgdmFsaWQgc2VjcDI1azEgcHJpdmF0ZSBrZXlcIikpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGxvZ2luUHJpdktleVN0cmVhbSA9IHRoaXMuY29tbXVuaWNhdGlvbk11eC5nZXRTdHJlYW0oXCJsb2dpbl93aXRoX3ByaXZhdGVfa2V5XCIpO1xuXG4gICAgICAgIGNvbnN0IGxvZ2luSGFuZGxlciA9IGNodW5rID0+IHtcbiAgICAgICAgICBpZiAoY2h1bmsubmFtZSA9PT0gXCJsb2dpbl93aXRoX3ByaXZhdGVfa2V5X3Jlc3BvbnNlXCIpIHtcbiAgICAgICAgICAgIGlmIChjaHVuay5kYXRhLnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgcmVzb2x2ZShjaHVuay5kYXRhLnN1Y2Nlc3MpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihjaHVuay5kYXRhLmVycm9yKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGhhbmRsZVN0cmVhbShsb2dpblByaXZLZXlTdHJlYW0sIFwiZGF0YVwiLCBsb2dpbkhhbmRsZXIpO1xuICAgICAgICBsb2dpblByaXZLZXlTdHJlYW0ud3JpdGUoe1xuICAgICAgICAgIG5hbWU6IFwibG9naW5fd2l0aF9wcml2YXRlX2tleV9yZXF1ZXN0XCIsXG4gICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgcHJpdmF0ZUtleSxcbiAgICAgICAgICAgIHVzZXJJbmZvXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSByZWplY3QobmV3IEVycm9yKFwiVG9ydXMgaXMgbm90IGluaXRpYWxpemVkIHlldFwiKSk7XG4gICAgfSk7XG4gIH1cblxuICBhc3luYyBzaG93V2FsbGV0Q29ubmVjdFNjYW5uZXIoKSB7XG4gICAgaWYgKCF0aGlzLnVzZVdhbGxldENvbm5lY3QpIHRocm93IG5ldyBFcnJvcihcIlNldCBgdXNlV2FsbGV0Q29ubmVjdGAgYXMgdHJ1ZSBpbiBpbml0IGZ1bmN0aW9uIG9wdGlvbnMgdG8gdXNlIHdhbGxldCBjb25uZWN0IHNjYW5uZXJcIik7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGlmICh0aGlzLmlzTG9nZ2VkSW4pIHtcbiAgICAgICAgY29uc3Qgd2FsbGV0Q29ubmVjdFN0cmVhbSA9IHRoaXMuY29tbXVuaWNhdGlvbk11eC5nZXRTdHJlYW0oXCJ3YWxsZXRfY29ubmVjdF9zdHJlYW1cIik7XG5cbiAgICAgICAgY29uc3Qgd2FsbGV0Q29ubmVjdEhhbmRsZXIgPSBjaHVuayA9PiB7XG4gICAgICAgICAgaWYgKGNodW5rLm5hbWUgPT09IFwid2FsbGV0X2Nvbm5lY3Rfc3RyZWFtX3Jlc1wiKSB7XG4gICAgICAgICAgICBpZiAoY2h1bmsuZGF0YS5zdWNjZXNzKSB7XG4gICAgICAgICAgICAgIHJlc29sdmUoY2h1bmsuZGF0YS5zdWNjZXNzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoY2h1bmsuZGF0YS5lcnJvcikpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl9kaXNwbGF5SWZyYW1lKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGhhbmRsZVN0cmVhbSh3YWxsZXRDb25uZWN0U3RyZWFtLCBcImRhdGFcIiwgd2FsbGV0Q29ubmVjdEhhbmRsZXIpO1xuICAgICAgICB3YWxsZXRDb25uZWN0U3RyZWFtLndyaXRlKHtcbiAgICAgICAgICBuYW1lOiBcIndhbGxldF9jb25uZWN0X3N0cmVhbV9yZXFcIlxuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLl9kaXNwbGF5SWZyYW1lKHRydWUpO1xuICAgICAgfSBlbHNlIHJlamVjdChuZXcgRXJyb3IoXCJVc2VyIGhhcyBub3QgbG9nZ2VkIGluIHlldFwiKSk7XG4gICAgfSk7XG4gIH1cblxuICBfaGFuZGxlV2luZG93KHByZW9wZW5JbnN0YW5jZUlkKSB7XG4gICAgbGV0IHtcbiAgICAgIHVybCxcbiAgICAgIHRhcmdldCxcbiAgICAgIGZlYXR1cmVzXG4gICAgfSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgICBpZiAocHJlb3Blbkluc3RhbmNlSWQpIHtcbiAgICAgIGNvbnN0IHdpbmRvd1N0cmVhbSA9IHRoaXMuY29tbXVuaWNhdGlvbk11eC5nZXRTdHJlYW0oXCJ3aW5kb3dcIik7XG4gICAgICBjb25zdCBmaW5hbFVybCA9IG5ldyBVUkwodXJsIHx8IGAke3RoaXMudG9ydXNVcmx9L3JlZGlyZWN0P3ByZW9wZW5JbnN0YW5jZUlkPSR7cHJlb3Blbkluc3RhbmNlSWR9YCk7XG4gICAgICBpZiAoZmluYWxVcmwuaGFzaCkgZmluYWxVcmwuaGFzaCArPSBgJmlzQ3VzdG9tTG9naW49JHt0aGlzLmlzQ3VzdG9tTG9naW59YDtlbHNlIGZpbmFsVXJsLmhhc2ggPSBgI2lzQ3VzdG9tTG9naW49JHt0aGlzLmlzQ3VzdG9tTG9naW59YDtcbiAgICAgIGNvbnN0IGhhbmRsZWRXaW5kb3cgPSBuZXcgUG9wdXBIYW5kbGVyKHtcbiAgICAgICAgdXJsOiBmaW5hbFVybCxcbiAgICAgICAgdGFyZ2V0LFxuICAgICAgICBmZWF0dXJlc1xuICAgICAgfSk7XG4gICAgICBoYW5kbGVkV2luZG93Lm9wZW4oKTtcblxuICAgICAgaWYgKCFoYW5kbGVkV2luZG93LndpbmRvdykge1xuICAgICAgICB0aGlzLl9jcmVhdGVQb3B1cEJsb2NrQWxlcnQocHJlb3Blbkluc3RhbmNlSWQsIGZpbmFsVXJsLmhyZWYpO1xuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgd2luZG93U3RyZWFtLndyaXRlKHtcbiAgICAgICAgbmFtZTogXCJvcGVuZWRfd2luZG93XCIsXG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICBwcmVvcGVuSW5zdGFuY2VJZFxuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgY29uc3QgY2xvc2VIYW5kbGVyID0gX3JlZjMgPT4ge1xuICAgICAgICBsZXQge1xuICAgICAgICAgIHByZW9wZW5JbnN0YW5jZUlkOiByZWNlaXZlZElkLFxuICAgICAgICAgIGNsb3NlXG4gICAgICAgIH0gPSBfcmVmMztcblxuICAgICAgICBpZiAocmVjZWl2ZWRJZCA9PT0gcHJlb3Blbkluc3RhbmNlSWQgJiYgY2xvc2UpIHtcbiAgICAgICAgICBoYW5kbGVkV2luZG93LmNsb3NlKCk7XG4gICAgICAgICAgd2luZG93U3RyZWFtLnJlbW92ZUxpc3RlbmVyKFwiZGF0YVwiLCBjbG9zZUhhbmRsZXIpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB3aW5kb3dTdHJlYW0ub24oXCJkYXRhXCIsIGNsb3NlSGFuZGxlcik7XG4gICAgICBoYW5kbGVkV2luZG93Lm9uY2UoXCJjbG9zZVwiLCAoKSA9PiB7XG4gICAgICAgIHdpbmRvd1N0cmVhbS53cml0ZSh7XG4gICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgcHJlb3Blbkluc3RhbmNlSWQsXG4gICAgICAgICAgICBjbG9zZWQ6IHRydWVcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB3aW5kb3dTdHJlYW0ucmVtb3ZlTGlzdGVuZXIoXCJkYXRhXCIsIGNsb3NlSGFuZGxlcik7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBfc2V0RW1iZWRXaGl0ZUxhYmVsKGVsZW1lbnQpIHtcbiAgICAvLyBTZXQgd2hpdGVsYWJlbFxuICAgIGNvbnN0IHtcbiAgICAgIHRoZW1lXG4gICAgfSA9IHRoaXMud2hpdGVMYWJlbCB8fCB7fTtcblxuICAgIGlmICh0aGVtZSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBpc0RhcmsgPSBmYWxzZSxcbiAgICAgICAgY29sb3JzID0ge31cbiAgICAgIH0gPSB0aGVtZTtcbiAgICAgIGlmIChpc0RhcmspIGVsZW1lbnQuY2xhc3NMaXN0LmFkZChcInRvcnVzLWRhcmtcIik7XG4gICAgICBpZiAoY29sb3JzLnRvcnVzQnJhbmQxKSBlbGVtZW50LnN0eWxlLnNldFByb3BlcnR5KFwiLS10b3J1cy1icmFuZC0xXCIsIGNvbG9ycy50b3J1c0JyYW5kMSk7XG4gICAgICBpZiAoY29sb3JzLnRvcnVzR3JheTIpIGVsZW1lbnQuc3R5bGUuc2V0UHJvcGVydHkoXCItLXRvcnVzLWdyYXktMlwiLCBjb2xvcnMudG9ydXNHcmF5Mik7XG4gICAgfVxuICB9XG5cbiAgX2dldExvZ29VcmwoKSB7XG4gICAgdmFyIF90aGlzJHdoaXRlTGFiZWwsIF90aGlzJHdoaXRlTGFiZWwkdGhlbTtcblxuICAgIGxldCBsb2dvVXJsID0gYCR7dGhpcy50b3J1c1VybH0vaW1hZ2VzL3RvcnVzX2ljb24tYmx1ZS5zdmdgO1xuXG4gICAgaWYgKChfdGhpcyR3aGl0ZUxhYmVsID0gdGhpcy53aGl0ZUxhYmVsKSAhPT0gbnVsbCAmJiBfdGhpcyR3aGl0ZUxhYmVsICE9PSB2b2lkIDAgJiYgKF90aGlzJHdoaXRlTGFiZWwkdGhlbSA9IF90aGlzJHdoaXRlTGFiZWwudGhlbWUpICE9PSBudWxsICYmIF90aGlzJHdoaXRlTGFiZWwkdGhlbSAhPT0gdm9pZCAwICYmIF90aGlzJHdoaXRlTGFiZWwkdGhlbS5pc0RhcmspIHtcbiAgICAgIHZhciBfdGhpcyR3aGl0ZUxhYmVsMjtcblxuICAgICAgbG9nb1VybCA9ICgoX3RoaXMkd2hpdGVMYWJlbDIgPSB0aGlzLndoaXRlTGFiZWwpID09PSBudWxsIHx8IF90aGlzJHdoaXRlTGFiZWwyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdGhpcyR3aGl0ZUxhYmVsMi5sb2dvTGlnaHQpIHx8IGxvZ29Vcmw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBfdGhpcyR3aGl0ZUxhYmVsMztcblxuICAgICAgbG9nb1VybCA9ICgoX3RoaXMkd2hpdGVMYWJlbDMgPSB0aGlzLndoaXRlTGFiZWwpID09PSBudWxsIHx8IF90aGlzJHdoaXRlTGFiZWwzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdGhpcyR3aGl0ZUxhYmVsMy5sb2dvRGFyaykgfHwgbG9nb1VybDtcbiAgICB9XG5cbiAgICByZXR1cm4gbG9nb1VybDtcbiAgfVxuXG4gIF9zZW5kV2lkZ2V0VmlzaWJpbGl0eVN0YXR1cyhzdGF0dXMpIHtcbiAgICBjb25zdCB0b3J1c1dpZGdldFZpc2liaWxpdHlTdHJlYW0gPSB0aGlzLmNvbW11bmljYXRpb25NdXguZ2V0U3RyZWFtKFwidG9ydXMtd2lkZ2V0LXZpc2liaWxpdHlcIik7XG4gICAgdG9ydXNXaWRnZXRWaXNpYmlsaXR5U3RyZWFtLndyaXRlKHtcbiAgICAgIGRhdGE6IHN0YXR1c1xuICAgIH0pO1xuICB9XG5cbiAgX2Rpc3BsYXlJZnJhbWUoKSB7XG4gICAgbGV0IGlzRnVsbCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogZmFsc2U7XG4gICAgY29uc3Qgc3R5bGUgPSB7fTtcbiAgICBjb25zdCBzaXplID0gdGhpcy5idXR0b25TaXplICsgMTQ7IC8vIDE1cHggcGFkZGluZ1xuICAgIC8vIHNldCBwaGFzZVxuXG4gICAgaWYgKCFpc0Z1bGwpIHtcbiAgICAgIHN0eWxlLmRpc3BsYXkgPSB0aGlzLnRvcnVzV2lkZ2V0VmlzaWJpbGl0eSA/IFwiYmxvY2tcIiA6IFwibm9uZVwiO1xuICAgICAgc3R5bGUuaGVpZ2h0ID0gYCR7c2l6ZX1weGA7XG4gICAgICBzdHlsZS53aWR0aCA9IGAke3NpemV9cHhgO1xuXG4gICAgICBzd2l0Y2ggKHRoaXMuYnV0dG9uUG9zaXRpb24pIHtcbiAgICAgICAgY2FzZSBCVVRUT05fUE9TSVRJT04uVE9QX0xFRlQ6XG4gICAgICAgICAgc3R5bGUudG9wID0gXCIwcHhcIjtcbiAgICAgICAgICBzdHlsZS5sZWZ0ID0gXCIwcHhcIjtcbiAgICAgICAgICBzdHlsZS5yaWdodCA9IFwiYXV0b1wiO1xuICAgICAgICAgIHN0eWxlLmJvdHRvbSA9IFwiYXV0b1wiO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgQlVUVE9OX1BPU0lUSU9OLlRPUF9SSUdIVDpcbiAgICAgICAgICBzdHlsZS50b3AgPSBcIjBweFwiO1xuICAgICAgICAgIHN0eWxlLnJpZ2h0ID0gXCIwcHhcIjtcbiAgICAgICAgICBzdHlsZS5sZWZ0ID0gXCJhdXRvXCI7XG4gICAgICAgICAgc3R5bGUuYm90dG9tID0gXCJhdXRvXCI7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBCVVRUT05fUE9TSVRJT04uQk9UVE9NX1JJR0hUOlxuICAgICAgICAgIHN0eWxlLmJvdHRvbSA9IFwiMHB4XCI7XG4gICAgICAgICAgc3R5bGUucmlnaHQgPSBcIjBweFwiO1xuICAgICAgICAgIHN0eWxlLnRvcCA9IFwiYXV0b1wiO1xuICAgICAgICAgIHN0eWxlLmxlZnQgPSBcImF1dG9cIjtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIEJVVFRPTl9QT1NJVElPTi5CT1RUT01fTEVGVDpcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBzdHlsZS5ib3R0b20gPSBcIjBweFwiO1xuICAgICAgICAgIHN0eWxlLmxlZnQgPSBcIjBweFwiO1xuICAgICAgICAgIHN0eWxlLnRvcCA9IFwiYXV0b1wiO1xuICAgICAgICAgIHN0eWxlLnJpZ2h0ID0gXCJhdXRvXCI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCI7XG4gICAgICBzdHlsZS53aWR0aCA9IFwiMTAwJVwiO1xuICAgICAgc3R5bGUuaGVpZ2h0ID0gXCIxMDAlXCI7XG4gICAgICBzdHlsZS50b3AgPSBcIjBweFwiO1xuICAgICAgc3R5bGUucmlnaHQgPSBcIjBweFwiO1xuICAgICAgc3R5bGUubGVmdCA9IFwiMHB4XCI7XG4gICAgICBzdHlsZS5ib3R0b20gPSBcIjBweFwiO1xuICAgIH1cblxuICAgIE9iamVjdC5hc3NpZ24odGhpcy50b3J1c0lmcmFtZS5zdHlsZSwgc3R5bGUpO1xuICAgIHRoaXMuaXNJZnJhbWVGdWxsU2NyZWVuID0gaXNGdWxsO1xuICB9XG5cbiAgX3NldHVwV2ViMygpIHtcbiAgICBsb2cuaW5mbyhcInNldHVwV2ViMyBydW5uaW5nXCIpOyAvLyBzZXR1cCBiYWNrZ3JvdW5kIGNvbm5lY3Rpb25cblxuICAgIGNvbnN0IG1ldGFtYXNrU3RyZWFtID0gbmV3IEJhc2VQb3N0TWVzc2FnZVN0cmVhbSh7XG4gICAgICBuYW1lOiBcImVtYmVkX21ldGFtYXNrXCIsXG4gICAgICB0YXJnZXQ6IFwiaWZyYW1lX21ldGFtYXNrXCIsXG4gICAgICB0YXJnZXRXaW5kb3c6IHRoaXMudG9ydXNJZnJhbWUuY29udGVudFdpbmRvdyxcbiAgICAgIHRhcmdldE9yaWdpbjogbmV3IFVSTCh0aGlzLnRvcnVzVXJsKS5vcmlnaW5cbiAgICB9KTsgLy8gRHVlIHRvIGNvbXBhdGliaWxpdHkgcmVhc29ucywgd2Ugc2hvdWxkIG5vdCBzZXQgdXAgbXVsdGlwbGV4aW5nIG9uIHdpbmRvdy5tZXRhbWFza3N0cmVhbVxuICAgIC8vIGJlY2F1c2UgdGhlIE1ldGFtYXNrSW5wYWdlUHJvdmlkZXIgYWxzbyBhdHRlbXB0cyB0byBkbyBzby5cbiAgICAvLyBXZSBjcmVhdGUgYW5vdGhlciBMb2NhbE1lc3NhZ2VEdXBsZXhTdHJlYW0gZm9yIGNvbW11bmljYXRpb24gYmV0d2VlbiBkYXBwIDw+IGlmcmFtZVxuXG4gICAgY29uc3QgY29tbXVuaWNhdGlvblN0cmVhbSA9IG5ldyBCYXNlUG9zdE1lc3NhZ2VTdHJlYW0oe1xuICAgICAgbmFtZTogXCJlbWJlZF9jb21tXCIsXG4gICAgICB0YXJnZXQ6IFwiaWZyYW1lX2NvbW1cIixcbiAgICAgIHRhcmdldFdpbmRvdzogdGhpcy50b3J1c0lmcmFtZS5jb250ZW50V2luZG93LFxuICAgICAgdGFyZ2V0T3JpZ2luOiBuZXcgVVJMKHRoaXMudG9ydXNVcmwpLm9yaWdpblxuICAgIH0pOyAvLyBCYWNrd2FyZCBjb21wYXRpYmlsaXR5IHdpdGggR290Y2hpIDopXG4gICAgLy8gd2luZG93Lm1ldGFtYXNrU3RyZWFtID0gdGhpcy5jb21tdW5pY2F0aW9uU3RyZWFtXG4gICAgLy8gY29tcG9zZSB0aGUgaW5wYWdlIHByb3ZpZGVyXG5cbiAgICBjb25zdCBpbnBhZ2VQcm92aWRlciA9IG5ldyBUb3J1c0lucGFnZVByb3ZpZGVyKG1ldGFtYXNrU3RyZWFtKTsgLy8gZGV0ZWN0IGV0aF9yZXF1ZXN0QWNjb3VudHMgYW5kIHBpcGUgdG8gZW5hYmxlIGZvciBub3dcblxuICAgIGNvbnN0IGRldGVjdEFjY291bnRSZXF1ZXN0UHJvdG90eXBlTW9kaWZpZXIgPSBtID0+IHtcbiAgICAgIGNvbnN0IG9yaWdpbmFsTWV0aG9kID0gaW5wYWdlUHJvdmlkZXJbbV07XG5cbiAgICAgIGlucGFnZVByb3ZpZGVyW21dID0gZnVuY3Rpb24gcHJvdmlkZXJGdW5jKG1ldGhvZCkge1xuICAgICAgICBpZiAobWV0aG9kICYmIG1ldGhvZCA9PT0gXCJldGhfcmVxdWVzdEFjY291bnRzXCIpIHtcbiAgICAgICAgICByZXR1cm4gaW5wYWdlUHJvdmlkZXIuZW5hYmxlKCk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb3JpZ2luYWxNZXRob2QuYXBwbHkodGhpcywgW21ldGhvZCwgLi4uYXJnc10pO1xuICAgICAgfTtcbiAgICB9O1xuXG4gICAgZGV0ZWN0QWNjb3VudFJlcXVlc3RQcm90b3R5cGVNb2RpZmllcihcInNlbmRcIik7XG4gICAgZGV0ZWN0QWNjb3VudFJlcXVlc3RQcm90b3R5cGVNb2RpZmllcihcInNlbmRBc3luY1wiKTtcblxuICAgIGlucGFnZVByb3ZpZGVyLmVuYWJsZSA9ICgpID0+IHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIC8vIElmIHVzZXIgaXMgYWxyZWFkeSBsb2dnZWQgaW4sIHdlIGFzc3VtZSB0aGV5IGhhdmUgZ2l2ZW4gYWNjZXNzIHRvIHRoZSB3ZWJzaXRlXG4gICAgICAgIGlucGFnZVByb3ZpZGVyLnNlbmRBc3luYyh7XG4gICAgICAgICAganNvbnJwYzogXCIyLjBcIixcbiAgICAgICAgICBpZDogZ2V0UHJlb3Blbkluc3RhbmNlSWQoKSxcbiAgICAgICAgICBtZXRob2Q6IFwiZXRoX3JlcXVlc3RBY2NvdW50c1wiLFxuICAgICAgICAgIHBhcmFtczogW11cbiAgICAgICAgfSwgKGVyciwgcmVzcG9uc2UpID0+IHtcbiAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICByZXN1bHQ6IHJlc1xuICAgICAgICAgIH0gPSByZXNwb25zZSB8fCB7fTtcblxuICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgIH0sIDUwKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkocmVzKSAmJiByZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgLy8gSWYgdXNlciBpcyBhbHJlYWR5IHJlaHlkcmF0ZWQsIHJlc29sdmUgdGhpc1xuICAgICAgICAgICAgLy8gZWxzZSB3YWl0IGZvciBzb21ldGhpbmcgdG8gYmUgd3JpdHRlbiB0byBzdGF0dXMgc3RyZWFtXG4gICAgICAgICAgICBjb25zdCBoYW5kbGVMb2dpbkNiID0gKCkgPT4ge1xuICAgICAgICAgICAgICBpZiAodGhpcy5yZXF1ZXN0ZWRWZXJpZmllciAhPT0gXCJcIiAmJiB0aGlzLmN1cnJlbnRWZXJpZmllciAhPT0gdGhpcy5yZXF1ZXN0ZWRWZXJpZmllcikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgICAgICAgIHJlcXVlc3RlZFZlcmlmaWVyXG4gICAgICAgICAgICAgICAgfSA9IHRoaXM7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcm9taXNlL25vLXByb21pc2UtaW4tY2FsbGJhY2tcblxuICAgICAgICAgICAgICAgIHRoaXMubG9nb3V0KCkgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByb21pc2UvYWx3YXlzLXJldHVyblxuICAgICAgICAgICAgICAgIC50aGVuKF8gPT4ge1xuICAgICAgICAgICAgICAgICAgdGhpcy5yZXF1ZXN0ZWRWZXJpZmllciA9IHJlcXVlc3RlZFZlcmlmaWVyO1xuXG4gICAgICAgICAgICAgICAgICB0aGlzLl9zaG93TG9naW5Qb3B1cCh0cnVlLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgICAgICAgIH0pLmNhdGNoKGVycm9yID0+IHJlamVjdChlcnJvcikpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc29sdmUocmVzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuaXNMb2dnZWRJbikge1xuICAgICAgICAgICAgICBoYW5kbGVMb2dpbkNiKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLmlzTG9naW5DYWxsYmFjayA9IGhhbmRsZUxvZ2luQ2I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHNldCB1cCBsaXN0ZW5lciBmb3IgbG9naW5cbiAgICAgICAgICAgIHRoaXMuX3Nob3dMb2dpblBvcHVwKHRydWUsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBpbnBhZ2VQcm92aWRlci50cnlQcmVvcGVuSGFuZGxlID0gKHBheWxvYWQsIGNiKSA9PiB7XG4gICAgICBjb25zdCBfcGF5bG9hZCA9IHBheWxvYWQ7XG5cbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShfcGF5bG9hZCkgJiYgVU5TQUZFX01FVEhPRFMuaW5jbHVkZXMoX3BheWxvYWQubWV0aG9kKSkge1xuICAgICAgICBjb25zdCBwcmVvcGVuSW5zdGFuY2VJZCA9IGdldFByZW9wZW5JbnN0YW5jZUlkKCk7XG5cbiAgICAgICAgdGhpcy5faGFuZGxlV2luZG93KHByZW9wZW5JbnN0YW5jZUlkLCB7XG4gICAgICAgICAgdGFyZ2V0OiBcIl9ibGFua1wiLFxuICAgICAgICAgIGZlYXR1cmVzOiBGRUFUVVJFU19DT05GSVJNX1dJTkRPV1xuICAgICAgICB9KTtcblxuICAgICAgICBfcGF5bG9hZC5wcmVvcGVuSW5zdGFuY2VJZCA9IHByZW9wZW5JbnN0YW5jZUlkO1xuICAgICAgfVxuXG4gICAgICBpbnBhZ2VQcm92aWRlci5fcnBjRW5naW5lLmhhbmRsZShfcGF5bG9hZCwgY2IpO1xuICAgIH07IC8vIFdvcmsgYXJvdW5kIGZvciB3ZWIzQDEuMCBkZWxldGluZyB0aGUgYm91bmQgYHNlbmRBc3luY2AgYnV0IG5vdCB0aGUgdW5ib3VuZFxuICAgIC8vIGBzZW5kQXN5bmNgIG1ldGhvZCBvbiB0aGUgcHJvdG90eXBlLCBjYXVzaW5nIGB0aGlzYCByZWZlcmVuY2UgaXNzdWVzIHdpdGggZHJpenpsZVxuXG5cbiAgICBjb25zdCBwcm94aWVkSW5wYWdlUHJvdmlkZXIgPSBuZXcgUHJveHkoaW5wYWdlUHJvdmlkZXIsIHtcbiAgICAgIC8vIHN0cmFpZ2h0IHVwIGxpZSB0aGF0IHdlIGRlbGV0ZWQgdGhlIHByb3BlcnR5IHNvIHRoYXQgaXQgZG9lc250XG4gICAgICAvLyB0aHJvdyBhbiBlcnJvciBpbiBzdHJpY3QgbW9kZVxuICAgICAgZGVsZXRlUHJvcGVydHk6ICgpID0+IHRydWVcbiAgICB9KTtcbiAgICB0aGlzLmV0aGVyZXVtID0gcHJveGllZElucGFnZVByb3ZpZGVyO1xuICAgIGNvbnN0IGNvbW11bmljYXRpb25NdXggPSBzZXR1cE11bHRpcGxleChjb21tdW5pY2F0aW9uU3RyZWFtKTtcbiAgICB0aGlzLmNvbW11bmljYXRpb25NdXggPSBjb21tdW5pY2F0aW9uTXV4O1xuICAgIGNvbnN0IHdpbmRvd1N0cmVhbSA9IGNvbW11bmljYXRpb25NdXguZ2V0U3RyZWFtKFwid2luZG93XCIpO1xuICAgIHdpbmRvd1N0cmVhbS5vbihcImRhdGFcIiwgY2h1bmsgPT4ge1xuICAgICAgaWYgKGNodW5rLm5hbWUgPT09IFwiY3JlYXRlX3dpbmRvd1wiKSB7XG4gICAgICAgIC8vIHVybCBpcyB0aGUgdXJsIHdlIG5lZWQgdG8gb3BlblxuICAgICAgICAvLyB3ZSBjYW4gcGFzcyB0aGUgZmluYWwgdXJsIHVwZnJvbnQgc28gdGhhdCBpdCByZW1vdmVzIHRoZSBzdGVwIG9mIHJlZGlyZWN0aW5nIHRvIC9yZWRpcmVjdCBhbmQgd2FpdGluZyBmb3IgZmluYWxVcmxcbiAgICAgICAgdGhpcy5fY3JlYXRlUG9wdXBCbG9ja0FsZXJ0KGNodW5rLmRhdGEucHJlb3Blbkluc3RhbmNlSWQsIGNodW5rLmRhdGEudXJsKTtcbiAgICAgIH1cbiAgICB9KTsgLy8gc2hvdyB0b3J1cyB3aWRnZXQgaWYgYnV0dG9uIGNsaWNrZWRcblxuICAgIGNvbnN0IHdpZGdldFN0cmVhbSA9IGNvbW11bmljYXRpb25NdXguZ2V0U3RyZWFtKFwid2lkZ2V0XCIpO1xuICAgIHdpZGdldFN0cmVhbS5vbihcImRhdGFcIiwgY2h1bmsgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICBkYXRhXG4gICAgICB9ID0gY2h1bms7XG5cbiAgICAgIHRoaXMuX2Rpc3BsYXlJZnJhbWUoZGF0YSk7XG4gICAgfSk7IC8vIFNob3cgdG9ydXMgYnV0dG9uIGlmIHdhbGxldCBoYXMgYmVlbiBoeWRyYXRlZC9kZXRlY3RlZFxuXG4gICAgY29uc3Qgc3RhdHVzU3RyZWFtID0gY29tbXVuaWNhdGlvbk11eC5nZXRTdHJlYW0oXCJzdGF0dXNcIik7XG4gICAgc3RhdHVzU3RyZWFtLm9uKFwiZGF0YVwiLCBzdGF0dXMgPT4ge1xuICAgICAgLy8gbG9naW5cbiAgICAgIGlmIChzdGF0dXMubG9nZ2VkSW4pIHtcbiAgICAgICAgdGhpcy5pc0xvZ2dlZEluID0gc3RhdHVzLmxvZ2dlZEluO1xuICAgICAgICB0aGlzLmN1cnJlbnRWZXJpZmllciA9IHN0YXR1cy52ZXJpZmllcjtcbiAgICAgIH0gLy8gbG9nb3V0XG4gICAgICBlbHNlIHRoaXMuX2Rpc3BsYXlJZnJhbWUoKTtcblxuICAgICAgaWYgKHRoaXMuaXNMb2dpbkNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuaXNMb2dpbkNhbGxiYWNrKCk7XG4gICAgICAgIGRlbGV0ZSB0aGlzLmlzTG9naW5DYWxsYmFjaztcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLnByb3ZpZGVyID0gcHJveGllZElucGFnZVByb3ZpZGVyO1xuICAgIGlmICh0aGlzLnByb3ZpZGVyLnNob3VsZFNlbmRNZXRhZGF0YSkgc2VuZFNpdGVNZXRhZGF0YSh0aGlzLnByb3ZpZGVyLl9ycGNFbmdpbmUpO1xuXG4gICAgaW5wYWdlUHJvdmlkZXIuX2luaXRpYWxpemVTdGF0ZSgpO1xuXG4gICAgbG9nLmRlYnVnKFwiVG9ydXMgLSBpbmplY3RlZCBwcm92aWRlclwiKTtcbiAgfVxuXG4gIF9zaG93TG9naW5Qb3B1cChjYWxsZWRGcm9tRW1iZWQsIHJlc29sdmUsIHJlamVjdCkge1xuICAgIGNvbnN0IGxvZ2luSGFuZGxlciA9IGRhdGEgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICBlcnIsXG4gICAgICAgIHNlbGVjdGVkQWRkcmVzc1xuICAgICAgfSA9IGRhdGE7XG5cbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgbG9nLmVycm9yKGVycik7XG4gICAgICAgIGlmIChyZWplY3QpIHJlamVjdChlcnIpO1xuICAgICAgfSAvLyByZXR1cm5zIGFuIGFycmF5IChjYXVzZSBhY2NvdW50cyBleHBlY3RzIGl0KVxuICAgICAgZWxzZSBpZiAocmVzb2x2ZSkgcmVzb2x2ZShbc2VsZWN0ZWRBZGRyZXNzXSk7XG5cbiAgICAgIGlmICh0aGlzLmlzSWZyYW1lRnVsbFNjcmVlbikgdGhpcy5fZGlzcGxheUlmcmFtZSgpO1xuICAgIH07XG5cbiAgICBjb25zdCBvYXV0aFN0cmVhbSA9IHRoaXMuY29tbXVuaWNhdGlvbk11eC5nZXRTdHJlYW0oXCJvYXV0aFwiKTtcblxuICAgIGlmICghdGhpcy5yZXF1ZXN0ZWRWZXJpZmllcikge1xuICAgICAgdGhpcy5fZGlzcGxheUlmcmFtZSh0cnVlKTtcblxuICAgICAgaGFuZGxlU3RyZWFtKG9hdXRoU3RyZWFtLCBcImRhdGFcIiwgbG9naW5IYW5kbGVyKTtcbiAgICAgIG9hdXRoU3RyZWFtLndyaXRlKHtcbiAgICAgICAgbmFtZTogXCJvYXV0aF9tb2RhbFwiLFxuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgY2FsbGVkRnJvbUVtYmVkXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBoYW5kbGVTdHJlYW0ob2F1dGhTdHJlYW0sIFwiZGF0YVwiLCBsb2dpbkhhbmRsZXIpO1xuICAgICAgY29uc3QgcHJlb3Blbkluc3RhbmNlSWQgPSBnZXRQcmVvcGVuSW5zdGFuY2VJZCgpO1xuXG4gICAgICB0aGlzLl9oYW5kbGVXaW5kb3cocHJlb3Blbkluc3RhbmNlSWQpO1xuXG4gICAgICBvYXV0aFN0cmVhbS53cml0ZSh7XG4gICAgICAgIG5hbWU6IFwib2F1dGhcIixcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIGNhbGxlZEZyb21FbWJlZCxcbiAgICAgICAgICB2ZXJpZmllcjogdGhpcy5yZXF1ZXN0ZWRWZXJpZmllcixcbiAgICAgICAgICBwcmVvcGVuSW5zdGFuY2VJZCxcbiAgICAgICAgICBsb2dpbl9oaW50OiB0aGlzLmxvZ2luSGludFxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBfY3JlYXRlUG9wdXBCbG9ja0FsZXJ0KHByZW9wZW5JbnN0YW5jZUlkLCB1cmwpIHtcbiAgICBjb25zdCBsb2dvVXJsID0gdGhpcy5fZ2V0TG9nb1VybCgpO1xuXG4gICAgY29uc3QgdG9ydXNBbGVydCA9IGh0bWxUb0VsZW1lbnQoJzxkaXYgaWQ9XCJ0b3J1c0FsZXJ0XCIgY2xhc3M9XCJ0b3J1cy1hbGVydC0tdjJcIj4nICsgYDxkaXYgaWQ9XCJ0b3J1c0FsZXJ0X19sb2dvXCI+PGltZyBzcmM9XCIke2xvZ29Vcmx9XCIgLz48L2Rpdj5gICsgXCI8ZGl2PlwiICsgYDxoMSBpZD1cInRvcnVzQWxlcnRfX3RpdGxlXCI+JHt0aGlzLmVtYmVkVHJhbnNsYXRpb25zLmFjdGlvblJlcXVpcmVkfTwvaDE+YCArIGA8cCBpZD1cInRvcnVzQWxlcnRfX2Rlc2NcIj4ke3RoaXMuZW1iZWRUcmFuc2xhdGlvbnMucGVuZGluZ0FjdGlvbn08L3A+YCArIFwiPC9kaXY+XCIgKyBcIjwvZGl2PlwiKTtcbiAgICBjb25zdCBzdWNjZXNzQWxlcnQgPSBodG1sVG9FbGVtZW50KGA8ZGl2PjxhIGlkPVwidG9ydXNBbGVydF9fYnRuXCI+JHt0aGlzLmVtYmVkVHJhbnNsYXRpb25zLmNvbnRpbnVlfTwvYT48L2Rpdj5gKTtcbiAgICBjb25zdCBidG5Db250YWluZXIgPSBodG1sVG9FbGVtZW50KCc8ZGl2IGlkPVwidG9ydXNBbGVydF9fYnRuLWNvbnRhaW5lclwiPjwvZGl2PicpO1xuICAgIGJ0bkNvbnRhaW5lci5hcHBlbmRDaGlsZChzdWNjZXNzQWxlcnQpO1xuICAgIHRvcnVzQWxlcnQuYXBwZW5kQ2hpbGQoYnRuQ29udGFpbmVyKTtcblxuICAgIGNvbnN0IGJpbmRPbkxvYWQgPSAoKSA9PiB7XG4gICAgICBzdWNjZXNzQWxlcnQuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsICgpID0+IHtcbiAgICAgICAgdGhpcy5faGFuZGxlV2luZG93KHByZW9wZW5JbnN0YW5jZUlkLCB7XG4gICAgICAgICAgdXJsLFxuICAgICAgICAgIHRhcmdldDogXCJfYmxhbmtcIixcbiAgICAgICAgICBmZWF0dXJlczogRkVBVFVSRVNfQ09ORklSTV9XSU5ET1dcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdG9ydXNBbGVydC5yZW1vdmUoKTtcbiAgICAgICAgaWYgKHRoaXMudG9ydXNBbGVydENvbnRhaW5lci5jaGlsZHJlbi5sZW5ndGggPT09IDApIHRoaXMudG9ydXNBbGVydENvbnRhaW5lci5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgdGhpcy5fc2V0RW1iZWRXaGl0ZUxhYmVsKHRvcnVzQWxlcnQpO1xuXG4gICAgY29uc3QgYXR0YWNoT25Mb2FkID0gKCkgPT4ge1xuICAgICAgdGhpcy50b3J1c0FsZXJ0Q29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCI7XG4gICAgICB0aGlzLnRvcnVzQWxlcnRDb250YWluZXIuYXBwZW5kQ2hpbGQodG9ydXNBbGVydCk7XG4gICAgfTtcblxuICAgIHJ1bk9uTG9hZChhdHRhY2hPbkxvYWQpO1xuICAgIHJ1bk9uTG9hZChiaW5kT25Mb2FkKTtcbiAgfVxuXG59XG5cbmV4cG9ydCB7IEJVVFRPTl9QT1NJVElPTiwgTE9HSU5fUFJPVklERVIsIFBBWU1FTlRfUFJPVklERVIsIFNVUFBPUlRFRF9QQVlNRU5UX05FVFdPUkssIFRPUlVTX0JVSUxEX0VOViwgVG9ydXNJbnBhZ2VQcm92aWRlciwgV0FMTEVUX09QRU5MT0dJTl9WRVJJRklFUl9NQVAsIFdBTExFVF9WRVJJRklFUlMsIFRvcnVzIGFzIGRlZmF1bHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRvcnVzLmVzbS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@toruslabs/torus-embed/dist/torus.esm.js\n");

/***/ }),

/***/ "./node_modules/@web3auth/base-evm-adapter/dist/baseEvmAdapter.esm.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@web3auth/base-evm-adapter/dist/baseEvmAdapter.esm.js ***!
  \****************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"BaseEvmAdapter\": function() { return /* binding */ BaseEvmAdapter; }\n/* harmony export */ });\n/* harmony import */ var _web3auth_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @web3auth/base */ \"./node_modules/@web3auth/base/dist/base.esm.js\");\n\n\nclass BaseEvmAdapter extends _web3auth_base__WEBPACK_IMPORTED_MODULE_0__.BaseAdapter {\n  async authenticateUser() {\n    var _this$chainConfig;\n\n    if (!this.provider || !((_this$chainConfig = this.chainConfig) !== null && _this$chainConfig !== void 0 && _this$chainConfig.chainId)) throw _web3auth_base__WEBPACK_IMPORTED_MODULE_0__.WalletLoginError.notConnectedError();\n    const {\n      chainNamespace,\n      chainId\n    } = this.chainConfig;\n    if (this.status !== _web3auth_base__WEBPACK_IMPORTED_MODULE_0__.ADAPTER_STATUS.CONNECTED) throw _web3auth_base__WEBPACK_IMPORTED_MODULE_0__.WalletLoginError.notConnectedError(\"Not connected with wallet, Please login/connect first\");\n    const accounts = await this.provider.request({\n      method: \"eth_accounts\"\n    });\n\n    if (accounts && accounts.length > 0) {\n      const existingToken = (0,_web3auth_base__WEBPACK_IMPORTED_MODULE_0__.getSavedToken)(accounts[0], this.name);\n\n      if (existingToken) {\n        const isExpired = (0,_web3auth_base__WEBPACK_IMPORTED_MODULE_0__.checkIfTokenIsExpired)(existingToken);\n\n        if (!isExpired) {\n          return {\n            idToken: existingToken\n          };\n        }\n      }\n\n      const payload = {\n        domain: window.location.origin,\n        uri: window.location.href,\n        address: accounts[0],\n        chainId: parseInt(chainId, 16),\n        version: \"1\",\n        nonce: Math.random().toString(36).slice(2),\n        issuedAt: new Date().toISOString()\n      };\n      const challenge = await (0,_web3auth_base__WEBPACK_IMPORTED_MODULE_0__.signChallenge)(payload, chainNamespace);\n      const signedMessage = await this.provider.request({\n        method: \"personal_sign\",\n        params: [challenge, accounts[0]]\n      });\n      const idToken = await (0,_web3auth_base__WEBPACK_IMPORTED_MODULE_0__.verifySignedChallenge)(chainNamespace, signedMessage, challenge, this.name, this.sessionTime);\n      (0,_web3auth_base__WEBPACK_IMPORTED_MODULE_0__.saveToken)(accounts[0], this.name, idToken);\n      return {\n        idToken\n      };\n    }\n\n    throw _web3auth_base__WEBPACK_IMPORTED_MODULE_0__.WalletLoginError.notConnectedError(\"Not connected with wallet, Please login/connect first\");\n  }\n\n  async disconnect() {\n    if (this.status !== _web3auth_base__WEBPACK_IMPORTED_MODULE_0__.ADAPTER_STATUS.CONNECTED) throw _web3auth_base__WEBPACK_IMPORTED_MODULE_0__.WalletLoginError.disconnectionError(\"Not connected with wallet\");\n    const accounts = await this.provider.request({\n      method: \"eth_accounts\"\n    });\n\n    if (accounts && accounts.length > 0) {\n      (0,_web3auth_base__WEBPACK_IMPORTED_MODULE_0__.clearToken)(accounts[0], this.name);\n    }\n  }\n\n}\n\n\n//# sourceMappingURL=baseEvmAdapter.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHdlYjNhdXRoL2Jhc2UtZXZtLWFkYXB0ZXIvZGlzdC9iYXNlRXZtQWRhcHRlci5lc20uanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBa0w7O0FBRWxMLDZCQUE2Qix1REFBVztBQUN4QztBQUNBOztBQUVBLGlKQUFpSiw4RUFBa0M7QUFDbkw7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLHdCQUF3QixvRUFBd0IsUUFBUSw4RUFBa0M7QUFDMUY7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSw0QkFBNEIsNkRBQWE7O0FBRXpDO0FBQ0EsMEJBQTBCLHFFQUFxQjs7QUFFL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qiw2REFBYTtBQUMzQztBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsNEJBQTRCLHFFQUFxQjtBQUNqRCxNQUFNLHlEQUFTO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVSw4RUFBa0M7QUFDNUM7O0FBRUE7QUFDQSx3QkFBd0Isb0VBQXdCLFFBQVEsK0VBQW1DO0FBQzNGO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsTUFBTSwwREFBVTtBQUNoQjtBQUNBOztBQUVBOztBQUUwQjtBQUMxQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHdlYjNhdXRoL2Jhc2UtZXZtLWFkYXB0ZXIvZGlzdC9iYXNlRXZtQWRhcHRlci5lc20uanM/ZjJmOCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBCYXNlQWRhcHRlciwgV2FsbGV0TG9naW5FcnJvciwgQURBUFRFUl9TVEFUVVMsIGdldFNhdmVkVG9rZW4sIGNoZWNrSWZUb2tlbklzRXhwaXJlZCwgc2lnbkNoYWxsZW5nZSwgdmVyaWZ5U2lnbmVkQ2hhbGxlbmdlLCBzYXZlVG9rZW4sIGNsZWFyVG9rZW4gfSBmcm9tICdAd2ViM2F1dGgvYmFzZSc7XG5cbmNsYXNzIEJhc2VFdm1BZGFwdGVyIGV4dGVuZHMgQmFzZUFkYXB0ZXIge1xuICBhc3luYyBhdXRoZW50aWNhdGVVc2VyKCkge1xuICAgIHZhciBfdGhpcyRjaGFpbkNvbmZpZztcblxuICAgIGlmICghdGhpcy5wcm92aWRlciB8fCAhKChfdGhpcyRjaGFpbkNvbmZpZyA9IHRoaXMuY2hhaW5Db25maWcpICE9PSBudWxsICYmIF90aGlzJGNoYWluQ29uZmlnICE9PSB2b2lkIDAgJiYgX3RoaXMkY2hhaW5Db25maWcuY2hhaW5JZCkpIHRocm93IFdhbGxldExvZ2luRXJyb3Iubm90Q29ubmVjdGVkRXJyb3IoKTtcbiAgICBjb25zdCB7XG4gICAgICBjaGFpbk5hbWVzcGFjZSxcbiAgICAgIGNoYWluSWRcbiAgICB9ID0gdGhpcy5jaGFpbkNvbmZpZztcbiAgICBpZiAodGhpcy5zdGF0dXMgIT09IEFEQVBURVJfU1RBVFVTLkNPTk5FQ1RFRCkgdGhyb3cgV2FsbGV0TG9naW5FcnJvci5ub3RDb25uZWN0ZWRFcnJvcihcIk5vdCBjb25uZWN0ZWQgd2l0aCB3YWxsZXQsIFBsZWFzZSBsb2dpbi9jb25uZWN0IGZpcnN0XCIpO1xuICAgIGNvbnN0IGFjY291bnRzID0gYXdhaXQgdGhpcy5wcm92aWRlci5yZXF1ZXN0KHtcbiAgICAgIG1ldGhvZDogXCJldGhfYWNjb3VudHNcIlxuICAgIH0pO1xuXG4gICAgaWYgKGFjY291bnRzICYmIGFjY291bnRzLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IGV4aXN0aW5nVG9rZW4gPSBnZXRTYXZlZFRva2VuKGFjY291bnRzWzBdLCB0aGlzLm5hbWUpO1xuXG4gICAgICBpZiAoZXhpc3RpbmdUb2tlbikge1xuICAgICAgICBjb25zdCBpc0V4cGlyZWQgPSBjaGVja0lmVG9rZW5Jc0V4cGlyZWQoZXhpc3RpbmdUb2tlbik7XG5cbiAgICAgICAgaWYgKCFpc0V4cGlyZWQpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaWRUb2tlbjogZXhpc3RpbmdUb2tlblxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY29uc3QgcGF5bG9hZCA9IHtcbiAgICAgICAgZG9tYWluOiB3aW5kb3cubG9jYXRpb24ub3JpZ2luLFxuICAgICAgICB1cmk6IHdpbmRvdy5sb2NhdGlvbi5ocmVmLFxuICAgICAgICBhZGRyZXNzOiBhY2NvdW50c1swXSxcbiAgICAgICAgY2hhaW5JZDogcGFyc2VJbnQoY2hhaW5JZCwgMTYpLFxuICAgICAgICB2ZXJzaW9uOiBcIjFcIixcbiAgICAgICAgbm9uY2U6IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnNsaWNlKDIpLFxuICAgICAgICBpc3N1ZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG4gICAgICB9O1xuICAgICAgY29uc3QgY2hhbGxlbmdlID0gYXdhaXQgc2lnbkNoYWxsZW5nZShwYXlsb2FkLCBjaGFpbk5hbWVzcGFjZSk7XG4gICAgICBjb25zdCBzaWduZWRNZXNzYWdlID0gYXdhaXQgdGhpcy5wcm92aWRlci5yZXF1ZXN0KHtcbiAgICAgICAgbWV0aG9kOiBcInBlcnNvbmFsX3NpZ25cIixcbiAgICAgICAgcGFyYW1zOiBbY2hhbGxlbmdlLCBhY2NvdW50c1swXV1cbiAgICAgIH0pO1xuICAgICAgY29uc3QgaWRUb2tlbiA9IGF3YWl0IHZlcmlmeVNpZ25lZENoYWxsZW5nZShjaGFpbk5hbWVzcGFjZSwgc2lnbmVkTWVzc2FnZSwgY2hhbGxlbmdlLCB0aGlzLm5hbWUsIHRoaXMuc2Vzc2lvblRpbWUpO1xuICAgICAgc2F2ZVRva2VuKGFjY291bnRzWzBdLCB0aGlzLm5hbWUsIGlkVG9rZW4pO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaWRUb2tlblxuICAgICAgfTtcbiAgICB9XG5cbiAgICB0aHJvdyBXYWxsZXRMb2dpbkVycm9yLm5vdENvbm5lY3RlZEVycm9yKFwiTm90IGNvbm5lY3RlZCB3aXRoIHdhbGxldCwgUGxlYXNlIGxvZ2luL2Nvbm5lY3QgZmlyc3RcIik7XG4gIH1cblxuICBhc3luYyBkaXNjb25uZWN0KCkge1xuICAgIGlmICh0aGlzLnN0YXR1cyAhPT0gQURBUFRFUl9TVEFUVVMuQ09OTkVDVEVEKSB0aHJvdyBXYWxsZXRMb2dpbkVycm9yLmRpc2Nvbm5lY3Rpb25FcnJvcihcIk5vdCBjb25uZWN0ZWQgd2l0aCB3YWxsZXRcIik7XG4gICAgY29uc3QgYWNjb3VudHMgPSBhd2FpdCB0aGlzLnByb3ZpZGVyLnJlcXVlc3Qoe1xuICAgICAgbWV0aG9kOiBcImV0aF9hY2NvdW50c1wiXG4gICAgfSk7XG5cbiAgICBpZiAoYWNjb3VudHMgJiYgYWNjb3VudHMubGVuZ3RoID4gMCkge1xuICAgICAgY2xlYXJUb2tlbihhY2NvdW50c1swXSwgdGhpcy5uYW1lKTtcbiAgICB9XG4gIH1cblxufVxuXG5leHBvcnQgeyBCYXNlRXZtQWRhcHRlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmFzZUV2bUFkYXB0ZXIuZXNtLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@web3auth/base-evm-adapter/dist/baseEvmAdapter.esm.js\n");

/***/ }),

/***/ "./node_modules/@web3auth/torus-evm-adapter/dist/torusEvmAdapter.esm.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@web3auth/torus-evm-adapter/dist/torusEvmAdapter.esm.js ***!
  \******************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"TorusWalletAdapter\": function() { return /* binding */ TorusWalletAdapter; }\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ \"./node_modules/@babel/runtime/helpers/esm/defineProperty.js\");\n/* harmony import */ var _toruslabs_torus_embed__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @toruslabs/torus-embed */ \"./node_modules/@toruslabs/torus-embed/dist/torus.esm.js\");\n/* harmony import */ var _web3auth_base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @web3auth/base */ \"./node_modules/@web3auth/base/dist/base.esm.js\");\n/* harmony import */ var _web3auth_base_evm_adapter__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @web3auth/base-evm-adapter */ \"./node_modules/@web3auth/base-evm-adapter/dist/baseEvmAdapter.esm.js\");\n\n\n\n\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nclass TorusWalletAdapter extends _web3auth_base_evm_adapter__WEBPACK_IMPORTED_MODULE_3__.BaseEvmAdapter {\n  constructor() {\n    let params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super();\n\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this, \"name\", _web3auth_base__WEBPACK_IMPORTED_MODULE_2__.WALLET_ADAPTERS.TORUS_EVM);\n\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this, \"adapterNamespace\", _web3auth_base__WEBPACK_IMPORTED_MODULE_2__.ADAPTER_NAMESPACES.EIP155);\n\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this, \"currentChainNamespace\", _web3auth_base__WEBPACK_IMPORTED_MODULE_2__.CHAIN_NAMESPACES.EIP155);\n\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this, \"type\", _web3auth_base__WEBPACK_IMPORTED_MODULE_2__.ADAPTER_CATEGORY.EXTERNAL);\n\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this, \"status\", _web3auth_base__WEBPACK_IMPORTED_MODULE_2__.ADAPTER_STATUS.NOT_READY);\n\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this, \"torusInstance\", null);\n\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this, \"torusWalletOptions\", void 0);\n\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this, \"initParams\", void 0);\n\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this, \"loginSettings\", {});\n\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this, \"rehydrated\", false);\n\n    this.torusWalletOptions = params.adapterSettings || {};\n    this.initParams = params.initParams || {};\n    this.loginSettings = params.loginSettings || {};\n    this.chainConfig = params.chainConfig || null;\n    this.sessionTime = params.sessionTime || 86400;\n  }\n\n  get provider() {\n    if (this.status === _web3auth_base__WEBPACK_IMPORTED_MODULE_2__.ADAPTER_STATUS.CONNECTED && this.torusInstance) {\n      return this.torusInstance.provider;\n    }\n\n    return null;\n  }\n\n  set provider(_) {\n    throw new Error(\"Not implemented\");\n  }\n\n  async init(options) {\n    super.checkInitializationRequirements(); // set chainConfig for mainnet by default if not set\n\n    let network;\n\n    if (!this.chainConfig) {\n      this.chainConfig = (0,_web3auth_base__WEBPACK_IMPORTED_MODULE_2__.getChainConfig)(_web3auth_base__WEBPACK_IMPORTED_MODULE_2__.CHAIN_NAMESPACES.EIP155, 1);\n      const {\n        blockExplorer,\n        displayName,\n        chainId,\n        ticker,\n        tickerName\n      } = this.chainConfig;\n      network = {\n        chainId: Number.parseInt(chainId, 16),\n        host: \"mainnet\",\n        blockExplorer,\n        networkName: displayName,\n        ticker,\n        tickerName\n      };\n    } else {\n      const {\n        chainId,\n        blockExplorer,\n        displayName,\n        rpcTarget,\n        ticker,\n        tickerName\n      } = this.chainConfig;\n      network = {\n        chainId: Number.parseInt(chainId, 16),\n        host: rpcTarget,\n        blockExplorer,\n        networkName: displayName,\n        ticker,\n        tickerName\n      };\n    }\n\n    this.torusInstance = new _toruslabs_torus_embed__WEBPACK_IMPORTED_MODULE_1__[\"default\"](this.torusWalletOptions);\n    _web3auth_base__WEBPACK_IMPORTED_MODULE_2__.log.debug(\"initializing torus evm adapter init\");\n    await this.torusInstance.init(_objectSpread(_objectSpread({\n      showTorusButton: false\n    }, this.initParams), {}, {\n      network\n    }));\n    this.status = _web3auth_base__WEBPACK_IMPORTED_MODULE_2__.ADAPTER_STATUS.READY;\n    this.emit(_web3auth_base__WEBPACK_IMPORTED_MODULE_2__.ADAPTER_EVENTS.READY, _web3auth_base__WEBPACK_IMPORTED_MODULE_2__.WALLET_ADAPTERS.TORUS_EVM);\n\n    try {\n      _web3auth_base__WEBPACK_IMPORTED_MODULE_2__.log.debug(\"initializing torus evm adapter\");\n\n      if (options.autoConnect) {\n        this.rehydrated = true;\n        await this.connect();\n      }\n    } catch (error) {\n      _web3auth_base__WEBPACK_IMPORTED_MODULE_2__.log.error(\"Failed to connect with torus evm provider\", error);\n      this.emit(_web3auth_base__WEBPACK_IMPORTED_MODULE_2__.ADAPTER_EVENTS.ERRORED, error);\n    }\n  }\n\n  async connect() {\n    super.checkConnectionRequirements();\n    if (!this.torusInstance) throw _web3auth_base__WEBPACK_IMPORTED_MODULE_2__.WalletInitializationError.notReady(\"Torus wallet is not initialized\");\n    this.status = _web3auth_base__WEBPACK_IMPORTED_MODULE_2__.ADAPTER_STATUS.CONNECTING;\n    this.emit(_web3auth_base__WEBPACK_IMPORTED_MODULE_2__.ADAPTER_EVENTS.CONNECTING, {\n      adapter: _web3auth_base__WEBPACK_IMPORTED_MODULE_2__.WALLET_ADAPTERS.TORUS_EVM\n    });\n\n    try {\n      await this.torusInstance.login(this.loginSettings);\n      const {\n        chainId\n      } = this.torusInstance.provider;\n\n      if (chainId && parseInt(chainId) !== parseInt(this.chainConfig.chainId, 16)) {\n        const {\n          chainId: _chainId,\n          blockExplorer,\n          displayName,\n          rpcTarget,\n          ticker,\n          tickerName\n        } = this.chainConfig;\n        const network = {\n          chainId: Number.parseInt(_chainId, 16),\n          host: rpcTarget,\n          blockExplorer,\n          networkName: displayName,\n          tickerName,\n          ticker\n        }; // in some cases when user manually switches chain and relogin then adapter will not connect to initially passed\n        // chainConfig but will connect to the one that user switched to.\n        // So here trying to switch network to the one that was initially passed in chainConfig.\n\n        await this.torusInstance.setProvider(_objectSpread({}, network));\n        const updatedChainID = await this.torusInstance.ethereum.request({\n          method: \"eth_chainId\"\n        });\n\n        if (updatedChainID && parseInt(updatedChainID) !== parseInt(this.chainConfig.chainId, 16)) {\n          throw _web3auth_base__WEBPACK_IMPORTED_MODULE_2__.WalletInitializationError.fromCode(5000, \"Not connected to correct chainId. Expected: \".concat(this.chainConfig.chainId, \", Current: \").concat(updatedChainID));\n        }\n      }\n\n      this.status = _web3auth_base__WEBPACK_IMPORTED_MODULE_2__.ADAPTER_STATUS.CONNECTED;\n      this.torusInstance.showTorusButton();\n      this.emit(_web3auth_base__WEBPACK_IMPORTED_MODULE_2__.ADAPTER_STATUS.CONNECTED, {\n        adapter: _web3auth_base__WEBPACK_IMPORTED_MODULE_2__.WALLET_ADAPTERS.TORUS_EVM,\n        reconnected: this.rehydrated\n      });\n      return this.provider;\n    } catch (error) {\n      // ready again to be connected\n      this.status = _web3auth_base__WEBPACK_IMPORTED_MODULE_2__.ADAPTER_STATUS.READY;\n      this.rehydrated = false;\n      this.emit(_web3auth_base__WEBPACK_IMPORTED_MODULE_2__.ADAPTER_STATUS.ERRORED, error);\n      throw error instanceof _web3auth_base__WEBPACK_IMPORTED_MODULE_2__.Web3AuthError ? error : _web3auth_base__WEBPACK_IMPORTED_MODULE_2__.WalletLoginError.connectionError(\"Failed to login with torus wallet\");\n    }\n  }\n\n  async disconnect() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n      cleanup: false\n    };\n    if (!this.torusInstance) throw _web3auth_base__WEBPACK_IMPORTED_MODULE_2__.WalletInitializationError.notReady(\"Torus wallet is not initialized\");\n    await super.disconnect();\n    await this.torusInstance.logout();\n    this.torusInstance.hideTorusButton();\n\n    if (options.cleanup) {\n      this.status = _web3auth_base__WEBPACK_IMPORTED_MODULE_2__.ADAPTER_STATUS.NOT_READY;\n      this.torusInstance = null;\n    } else {\n      // ready to be connected again\n      this.status = _web3auth_base__WEBPACK_IMPORTED_MODULE_2__.ADAPTER_STATUS.READY;\n    }\n\n    this.rehydrated = false;\n    this.emit(_web3auth_base__WEBPACK_IMPORTED_MODULE_2__.ADAPTER_EVENTS.DISCONNECTED);\n  }\n\n  async getUserInfo() {\n    if (this.status !== _web3auth_base__WEBPACK_IMPORTED_MODULE_2__.ADAPTER_STATUS.CONNECTED) throw _web3auth_base__WEBPACK_IMPORTED_MODULE_2__.WalletLoginError.notConnectedError(\"Not connected with wallet\");\n    if (!this.torusInstance) throw _web3auth_base__WEBPACK_IMPORTED_MODULE_2__.WalletInitializationError.notReady(\"Torus wallet is not initialized\");\n    const userInfo = await this.torusInstance.getUserInfo(\"\");\n    return userInfo;\n  }\n\n  setAdapterSettings(options) {\n    if (this.status === _web3auth_base__WEBPACK_IMPORTED_MODULE_2__.ADAPTER_STATUS.READY) return;\n\n    if (options !== null && options !== void 0 && options.sessionTime) {\n      this.sessionTime = options.sessionTime;\n    }\n  }\n\n}\n\n\n//# sourceMappingURL=torusEvmAdapter.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHdlYjNhdXRoL3RvcnVzLWV2bS1hZGFwdGVyL2Rpc3QvdG9ydXNFdm1BZGFwdGVyLmVzbS5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFvRTtBQUN6QjtBQUMrSztBQUM5Sjs7QUFFNUQsMkNBQTJDLGdDQUFnQyxvQ0FBb0Msb0RBQW9ELDZEQUE2RCxpRUFBaUUsc0NBQXNDOztBQUV2VSxpQ0FBaUMsZ0JBQWdCLHNCQUFzQixPQUFPLHVEQUF1RCw2REFBNkQsaUZBQWUsNkJBQTZCLG9LQUFvSyxtRkFBbUYsS0FBSztBQUMxZSxpQ0FBaUMsc0VBQWM7QUFDL0M7QUFDQTtBQUNBOztBQUVBLElBQUksaUZBQWUsZUFBZSxxRUFBeUI7O0FBRTNELElBQUksaUZBQWUsMkJBQTJCLHFFQUF5Qjs7QUFFdkUsSUFBSSxpRkFBZSxnQ0FBZ0MsbUVBQXVCOztBQUUxRSxJQUFJLGlGQUFlLGVBQWUscUVBQXlCOztBQUUzRCxJQUFJLGlGQUFlLGlCQUFpQixvRUFBd0I7O0FBRTVELElBQUksaUZBQWU7O0FBRW5CLElBQUksaUZBQWU7O0FBRW5CLElBQUksaUZBQWU7O0FBRW5CLElBQUksaUZBQWUsMEJBQTBCOztBQUU3QyxJQUFJLGlGQUFlOztBQUVuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0Isb0VBQXdCO0FBQ2hEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2Q0FBNkM7O0FBRTdDOztBQUVBO0FBQ0EseUJBQXlCLDhEQUFjLENBQUMsbUVBQXVCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw2QkFBNkIsOERBQUs7QUFDbEMsSUFBSSxxREFBUztBQUNiO0FBQ0E7QUFDQSxLQUFLLHNCQUFzQjtBQUMzQjtBQUNBLEtBQUs7QUFDTCxrQkFBa0IsZ0VBQW9CO0FBQ3RDLGNBQWMsZ0VBQW9CLEVBQUUscUVBQXlCOztBQUU3RDtBQUNBLE1BQU0scURBQVM7O0FBRWY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sTUFBTSxxREFBUztBQUNmLGdCQUFnQixrRUFBc0I7QUFDdEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUNBQW1DLDhFQUFrQztBQUNyRSxrQkFBa0IscUVBQXlCO0FBQzNDLGNBQWMscUVBQXlCO0FBQ3ZDLGVBQWUscUVBQXlCO0FBQ3hDLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFROztBQUVSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQSw2REFBNkQ7QUFDN0Q7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQSxnQkFBZ0IsOEVBQWtDO0FBQ2xEO0FBQ0E7O0FBRUEsb0JBQW9CLG9FQUF3QjtBQUM1QztBQUNBLGdCQUFnQixvRUFBd0I7QUFDeEMsaUJBQWlCLHFFQUF5QjtBQUMxQztBQUNBLE9BQU87QUFDUDtBQUNBLE1BQU07QUFDTjtBQUNBLG9CQUFvQixnRUFBb0I7QUFDeEM7QUFDQSxnQkFBZ0Isa0VBQXNCO0FBQ3RDLDZCQUE2Qix5REFBYSxXQUFXLDRFQUFnQztBQUNyRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLDhFQUFrQztBQUNyRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0Isb0VBQXdCO0FBQzVDO0FBQ0EsTUFBTTtBQUNOO0FBQ0Esb0JBQW9CLGdFQUFvQjtBQUN4Qzs7QUFFQTtBQUNBLGNBQWMsdUVBQTJCO0FBQ3pDOztBQUVBO0FBQ0Esd0JBQXdCLG9FQUF3QixRQUFRLDhFQUFrQztBQUMxRixtQ0FBbUMsOEVBQWtDO0FBQ3JFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdCQUF3QixnRUFBb0I7O0FBRTVDO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUU4QjtBQUM5QiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHdlYjNhdXRoL3RvcnVzLWV2bS1hZGFwdGVyL2Rpc3QvdG9ydXNFdm1BZGFwdGVyLmVzbS5qcz8wMmI1Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBfZGVmaW5lUHJvcGVydHkgZnJvbSAnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9kZWZpbmVQcm9wZXJ0eSc7XG5pbXBvcnQgVG9ydXMgZnJvbSAnQHRvcnVzbGFicy90b3J1cy1lbWJlZCc7XG5pbXBvcnQgeyBXQUxMRVRfQURBUFRFUlMsIEFEQVBURVJfTkFNRVNQQUNFUywgQ0hBSU5fTkFNRVNQQUNFUywgQURBUFRFUl9DQVRFR09SWSwgQURBUFRFUl9TVEFUVVMsIGdldENoYWluQ29uZmlnLCBsb2csIEFEQVBURVJfRVZFTlRTLCBXYWxsZXRJbml0aWFsaXphdGlvbkVycm9yLCBXZWIzQXV0aEVycm9yLCBXYWxsZXRMb2dpbkVycm9yIH0gZnJvbSAnQHdlYjNhdXRoL2Jhc2UnO1xuaW1wb3J0IHsgQmFzZUV2bUFkYXB0ZXIgfSBmcm9tICdAd2ViM2F1dGgvYmFzZS1ldm0tYWRhcHRlcic7XG5cbmZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBlbnVtZXJhYmxlT25seSAmJiAoc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pKSwga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBudWxsICE9IGFyZ3VtZW50c1tpXSA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpICUgMiA/IG93bktleXMoT2JqZWN0KHNvdXJjZSksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpIDogb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5jbGFzcyBUb3J1c1dhbGxldEFkYXB0ZXIgZXh0ZW5kcyBCYXNlRXZtQWRhcHRlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIGxldCBwYXJhbXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgIHN1cGVyKCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIFdBTExFVF9BREFQVEVSUy5UT1JVU19FVk0pO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiYWRhcHRlck5hbWVzcGFjZVwiLCBBREFQVEVSX05BTUVTUEFDRVMuRUlQMTU1KTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImN1cnJlbnRDaGFpbk5hbWVzcGFjZVwiLCBDSEFJTl9OQU1FU1BBQ0VTLkVJUDE1NSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0eXBlXCIsIEFEQVBURVJfQ0FURUdPUlkuRVhURVJOQUwpO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwic3RhdHVzXCIsIEFEQVBURVJfU1RBVFVTLk5PVF9SRUFEWSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0b3J1c0luc3RhbmNlXCIsIG51bGwpO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwidG9ydXNXYWxsZXRPcHRpb25zXCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJpbml0UGFyYW1zXCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJsb2dpblNldHRpbmdzXCIsIHt9KTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInJlaHlkcmF0ZWRcIiwgZmFsc2UpO1xuXG4gICAgdGhpcy50b3J1c1dhbGxldE9wdGlvbnMgPSBwYXJhbXMuYWRhcHRlclNldHRpbmdzIHx8IHt9O1xuICAgIHRoaXMuaW5pdFBhcmFtcyA9IHBhcmFtcy5pbml0UGFyYW1zIHx8IHt9O1xuICAgIHRoaXMubG9naW5TZXR0aW5ncyA9IHBhcmFtcy5sb2dpblNldHRpbmdzIHx8IHt9O1xuICAgIHRoaXMuY2hhaW5Db25maWcgPSBwYXJhbXMuY2hhaW5Db25maWcgfHwgbnVsbDtcbiAgICB0aGlzLnNlc3Npb25UaW1lID0gcGFyYW1zLnNlc3Npb25UaW1lIHx8IDg2NDAwO1xuICB9XG5cbiAgZ2V0IHByb3ZpZGVyKCkge1xuICAgIGlmICh0aGlzLnN0YXR1cyA9PT0gQURBUFRFUl9TVEFUVVMuQ09OTkVDVEVEICYmIHRoaXMudG9ydXNJbnN0YW5jZSkge1xuICAgICAgcmV0dXJuIHRoaXMudG9ydXNJbnN0YW5jZS5wcm92aWRlcjtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHNldCBwcm92aWRlcihfKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTm90IGltcGxlbWVudGVkXCIpO1xuICB9XG5cbiAgYXN5bmMgaW5pdChvcHRpb25zKSB7XG4gICAgc3VwZXIuY2hlY2tJbml0aWFsaXphdGlvblJlcXVpcmVtZW50cygpOyAvLyBzZXQgY2hhaW5Db25maWcgZm9yIG1haW5uZXQgYnkgZGVmYXVsdCBpZiBub3Qgc2V0XG5cbiAgICBsZXQgbmV0d29yaztcblxuICAgIGlmICghdGhpcy5jaGFpbkNvbmZpZykge1xuICAgICAgdGhpcy5jaGFpbkNvbmZpZyA9IGdldENoYWluQ29uZmlnKENIQUlOX05BTUVTUEFDRVMuRUlQMTU1LCAxKTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgYmxvY2tFeHBsb3JlcixcbiAgICAgICAgZGlzcGxheU5hbWUsXG4gICAgICAgIGNoYWluSWQsXG4gICAgICAgIHRpY2tlcixcbiAgICAgICAgdGlja2VyTmFtZVxuICAgICAgfSA9IHRoaXMuY2hhaW5Db25maWc7XG4gICAgICBuZXR3b3JrID0ge1xuICAgICAgICBjaGFpbklkOiBOdW1iZXIucGFyc2VJbnQoY2hhaW5JZCwgMTYpLFxuICAgICAgICBob3N0OiBcIm1haW5uZXRcIixcbiAgICAgICAgYmxvY2tFeHBsb3JlcixcbiAgICAgICAgbmV0d29ya05hbWU6IGRpc3BsYXlOYW1lLFxuICAgICAgICB0aWNrZXIsXG4gICAgICAgIHRpY2tlck5hbWVcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgY2hhaW5JZCxcbiAgICAgICAgYmxvY2tFeHBsb3JlcixcbiAgICAgICAgZGlzcGxheU5hbWUsXG4gICAgICAgIHJwY1RhcmdldCxcbiAgICAgICAgdGlja2VyLFxuICAgICAgICB0aWNrZXJOYW1lXG4gICAgICB9ID0gdGhpcy5jaGFpbkNvbmZpZztcbiAgICAgIG5ldHdvcmsgPSB7XG4gICAgICAgIGNoYWluSWQ6IE51bWJlci5wYXJzZUludChjaGFpbklkLCAxNiksXG4gICAgICAgIGhvc3Q6IHJwY1RhcmdldCxcbiAgICAgICAgYmxvY2tFeHBsb3JlcixcbiAgICAgICAgbmV0d29ya05hbWU6IGRpc3BsYXlOYW1lLFxuICAgICAgICB0aWNrZXIsXG4gICAgICAgIHRpY2tlck5hbWVcbiAgICAgIH07XG4gICAgfVxuXG4gICAgdGhpcy50b3J1c0luc3RhbmNlID0gbmV3IFRvcnVzKHRoaXMudG9ydXNXYWxsZXRPcHRpb25zKTtcbiAgICBsb2cuZGVidWcoXCJpbml0aWFsaXppbmcgdG9ydXMgZXZtIGFkYXB0ZXIgaW5pdFwiKTtcbiAgICBhd2FpdCB0aGlzLnRvcnVzSW5zdGFuY2UuaW5pdChfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe1xuICAgICAgc2hvd1RvcnVzQnV0dG9uOiBmYWxzZVxuICAgIH0sIHRoaXMuaW5pdFBhcmFtcyksIHt9LCB7XG4gICAgICBuZXR3b3JrXG4gICAgfSkpO1xuICAgIHRoaXMuc3RhdHVzID0gQURBUFRFUl9TVEFUVVMuUkVBRFk7XG4gICAgdGhpcy5lbWl0KEFEQVBURVJfRVZFTlRTLlJFQURZLCBXQUxMRVRfQURBUFRFUlMuVE9SVVNfRVZNKTtcblxuICAgIHRyeSB7XG4gICAgICBsb2cuZGVidWcoXCJpbml0aWFsaXppbmcgdG9ydXMgZXZtIGFkYXB0ZXJcIik7XG5cbiAgICAgIGlmIChvcHRpb25zLmF1dG9Db25uZWN0KSB7XG4gICAgICAgIHRoaXMucmVoeWRyYXRlZCA9IHRydWU7XG4gICAgICAgIGF3YWl0IHRoaXMuY29ubmVjdCgpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBsb2cuZXJyb3IoXCJGYWlsZWQgdG8gY29ubmVjdCB3aXRoIHRvcnVzIGV2bSBwcm92aWRlclwiLCBlcnJvcik7XG4gICAgICB0aGlzLmVtaXQoQURBUFRFUl9FVkVOVFMuRVJST1JFRCwgZXJyb3IpO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGNvbm5lY3QoKSB7XG4gICAgc3VwZXIuY2hlY2tDb25uZWN0aW9uUmVxdWlyZW1lbnRzKCk7XG4gICAgaWYgKCF0aGlzLnRvcnVzSW5zdGFuY2UpIHRocm93IFdhbGxldEluaXRpYWxpemF0aW9uRXJyb3Iubm90UmVhZHkoXCJUb3J1cyB3YWxsZXQgaXMgbm90IGluaXRpYWxpemVkXCIpO1xuICAgIHRoaXMuc3RhdHVzID0gQURBUFRFUl9TVEFUVVMuQ09OTkVDVElORztcbiAgICB0aGlzLmVtaXQoQURBUFRFUl9FVkVOVFMuQ09OTkVDVElORywge1xuICAgICAgYWRhcHRlcjogV0FMTEVUX0FEQVBURVJTLlRPUlVTX0VWTVxuICAgIH0pO1xuXG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHRoaXMudG9ydXNJbnN0YW5jZS5sb2dpbih0aGlzLmxvZ2luU2V0dGluZ3MpO1xuICAgICAgY29uc3Qge1xuICAgICAgICBjaGFpbklkXG4gICAgICB9ID0gdGhpcy50b3J1c0luc3RhbmNlLnByb3ZpZGVyO1xuXG4gICAgICBpZiAoY2hhaW5JZCAmJiBwYXJzZUludChjaGFpbklkKSAhPT0gcGFyc2VJbnQodGhpcy5jaGFpbkNvbmZpZy5jaGFpbklkLCAxNikpIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGNoYWluSWQ6IF9jaGFpbklkLFxuICAgICAgICAgIGJsb2NrRXhwbG9yZXIsXG4gICAgICAgICAgZGlzcGxheU5hbWUsXG4gICAgICAgICAgcnBjVGFyZ2V0LFxuICAgICAgICAgIHRpY2tlcixcbiAgICAgICAgICB0aWNrZXJOYW1lXG4gICAgICAgIH0gPSB0aGlzLmNoYWluQ29uZmlnO1xuICAgICAgICBjb25zdCBuZXR3b3JrID0ge1xuICAgICAgICAgIGNoYWluSWQ6IE51bWJlci5wYXJzZUludChfY2hhaW5JZCwgMTYpLFxuICAgICAgICAgIGhvc3Q6IHJwY1RhcmdldCxcbiAgICAgICAgICBibG9ja0V4cGxvcmVyLFxuICAgICAgICAgIG5ldHdvcmtOYW1lOiBkaXNwbGF5TmFtZSxcbiAgICAgICAgICB0aWNrZXJOYW1lLFxuICAgICAgICAgIHRpY2tlclxuICAgICAgICB9OyAvLyBpbiBzb21lIGNhc2VzIHdoZW4gdXNlciBtYW51YWxseSBzd2l0Y2hlcyBjaGFpbiBhbmQgcmVsb2dpbiB0aGVuIGFkYXB0ZXIgd2lsbCBub3QgY29ubmVjdCB0byBpbml0aWFsbHkgcGFzc2VkXG4gICAgICAgIC8vIGNoYWluQ29uZmlnIGJ1dCB3aWxsIGNvbm5lY3QgdG8gdGhlIG9uZSB0aGF0IHVzZXIgc3dpdGNoZWQgdG8uXG4gICAgICAgIC8vIFNvIGhlcmUgdHJ5aW5nIHRvIHN3aXRjaCBuZXR3b3JrIHRvIHRoZSBvbmUgdGhhdCB3YXMgaW5pdGlhbGx5IHBhc3NlZCBpbiBjaGFpbkNvbmZpZy5cblxuICAgICAgICBhd2FpdCB0aGlzLnRvcnVzSW5zdGFuY2Uuc2V0UHJvdmlkZXIoX29iamVjdFNwcmVhZCh7fSwgbmV0d29yaykpO1xuICAgICAgICBjb25zdCB1cGRhdGVkQ2hhaW5JRCA9IGF3YWl0IHRoaXMudG9ydXNJbnN0YW5jZS5ldGhlcmV1bS5yZXF1ZXN0KHtcbiAgICAgICAgICBtZXRob2Q6IFwiZXRoX2NoYWluSWRcIlxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAodXBkYXRlZENoYWluSUQgJiYgcGFyc2VJbnQodXBkYXRlZENoYWluSUQpICE9PSBwYXJzZUludCh0aGlzLmNoYWluQ29uZmlnLmNoYWluSWQsIDE2KSkge1xuICAgICAgICAgIHRocm93IFdhbGxldEluaXRpYWxpemF0aW9uRXJyb3IuZnJvbUNvZGUoNTAwMCwgXCJOb3QgY29ubmVjdGVkIHRvIGNvcnJlY3QgY2hhaW5JZC4gRXhwZWN0ZWQ6IFwiLmNvbmNhdCh0aGlzLmNoYWluQ29uZmlnLmNoYWluSWQsIFwiLCBDdXJyZW50OiBcIikuY29uY2F0KHVwZGF0ZWRDaGFpbklEKSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5zdGF0dXMgPSBBREFQVEVSX1NUQVRVUy5DT05ORUNURUQ7XG4gICAgICB0aGlzLnRvcnVzSW5zdGFuY2Uuc2hvd1RvcnVzQnV0dG9uKCk7XG4gICAgICB0aGlzLmVtaXQoQURBUFRFUl9TVEFUVVMuQ09OTkVDVEVELCB7XG4gICAgICAgIGFkYXB0ZXI6IFdBTExFVF9BREFQVEVSUy5UT1JVU19FVk0sXG4gICAgICAgIHJlY29ubmVjdGVkOiB0aGlzLnJlaHlkcmF0ZWRcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRoaXMucHJvdmlkZXI7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIC8vIHJlYWR5IGFnYWluIHRvIGJlIGNvbm5lY3RlZFxuICAgICAgdGhpcy5zdGF0dXMgPSBBREFQVEVSX1NUQVRVUy5SRUFEWTtcbiAgICAgIHRoaXMucmVoeWRyYXRlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5lbWl0KEFEQVBURVJfU1RBVFVTLkVSUk9SRUQsIGVycm9yKTtcbiAgICAgIHRocm93IGVycm9yIGluc3RhbmNlb2YgV2ViM0F1dGhFcnJvciA/IGVycm9yIDogV2FsbGV0TG9naW5FcnJvci5jb25uZWN0aW9uRXJyb3IoXCJGYWlsZWQgdG8gbG9naW4gd2l0aCB0b3J1cyB3YWxsZXRcIik7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgZGlzY29ubmVjdCgpIHtcbiAgICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge1xuICAgICAgY2xlYW51cDogZmFsc2VcbiAgICB9O1xuICAgIGlmICghdGhpcy50b3J1c0luc3RhbmNlKSB0aHJvdyBXYWxsZXRJbml0aWFsaXphdGlvbkVycm9yLm5vdFJlYWR5KFwiVG9ydXMgd2FsbGV0IGlzIG5vdCBpbml0aWFsaXplZFwiKTtcbiAgICBhd2FpdCBzdXBlci5kaXNjb25uZWN0KCk7XG4gICAgYXdhaXQgdGhpcy50b3J1c0luc3RhbmNlLmxvZ291dCgpO1xuICAgIHRoaXMudG9ydXNJbnN0YW5jZS5oaWRlVG9ydXNCdXR0b24oKTtcblxuICAgIGlmIChvcHRpb25zLmNsZWFudXApIHtcbiAgICAgIHRoaXMuc3RhdHVzID0gQURBUFRFUl9TVEFUVVMuTk9UX1JFQURZO1xuICAgICAgdGhpcy50b3J1c0luc3RhbmNlID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gcmVhZHkgdG8gYmUgY29ubmVjdGVkIGFnYWluXG4gICAgICB0aGlzLnN0YXR1cyA9IEFEQVBURVJfU1RBVFVTLlJFQURZO1xuICAgIH1cblxuICAgIHRoaXMucmVoeWRyYXRlZCA9IGZhbHNlO1xuICAgIHRoaXMuZW1pdChBREFQVEVSX0VWRU5UUy5ESVNDT05ORUNURUQpO1xuICB9XG5cbiAgYXN5bmMgZ2V0VXNlckluZm8oKSB7XG4gICAgaWYgKHRoaXMuc3RhdHVzICE9PSBBREFQVEVSX1NUQVRVUy5DT05ORUNURUQpIHRocm93IFdhbGxldExvZ2luRXJyb3Iubm90Q29ubmVjdGVkRXJyb3IoXCJOb3QgY29ubmVjdGVkIHdpdGggd2FsbGV0XCIpO1xuICAgIGlmICghdGhpcy50b3J1c0luc3RhbmNlKSB0aHJvdyBXYWxsZXRJbml0aWFsaXphdGlvbkVycm9yLm5vdFJlYWR5KFwiVG9ydXMgd2FsbGV0IGlzIG5vdCBpbml0aWFsaXplZFwiKTtcbiAgICBjb25zdCB1c2VySW5mbyA9IGF3YWl0IHRoaXMudG9ydXNJbnN0YW5jZS5nZXRVc2VySW5mbyhcIlwiKTtcbiAgICByZXR1cm4gdXNlckluZm87XG4gIH1cblxuICBzZXRBZGFwdGVyU2V0dGluZ3Mob3B0aW9ucykge1xuICAgIGlmICh0aGlzLnN0YXR1cyA9PT0gQURBUFRFUl9TVEFUVVMuUkVBRFkpIHJldHVybjtcblxuICAgIGlmIChvcHRpb25zICE9PSBudWxsICYmIG9wdGlvbnMgIT09IHZvaWQgMCAmJiBvcHRpb25zLnNlc3Npb25UaW1lKSB7XG4gICAgICB0aGlzLnNlc3Npb25UaW1lID0gb3B0aW9ucy5zZXNzaW9uVGltZTtcbiAgICB9XG4gIH1cblxufVxuXG5leHBvcnQgeyBUb3J1c1dhbGxldEFkYXB0ZXIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRvcnVzRXZtQWRhcHRlci5lc20uanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@web3auth/torus-evm-adapter/dist/torusEvmAdapter.esm.js\n");

/***/ }),

/***/ "./node_modules/core-util-is/lib/util.js":
/*!***********************************************!*\
  !*** ./node_modules/core-util-is/lib/util.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// NOTE: These type checking functions intentionally don't use `instanceof`\n// because it is fragile and can be easily faked with `Object.create()`.\n\nfunction isArray(arg) {\n  if (Array.isArray) {\n    return Array.isArray(arg);\n  }\n  return objectToString(arg) === '[object Array]';\n}\nexports.isArray = isArray;\n\nfunction isBoolean(arg) {\n  return typeof arg === 'boolean';\n}\nexports.isBoolean = isBoolean;\n\nfunction isNull(arg) {\n  return arg === null;\n}\nexports.isNull = isNull;\n\nfunction isNullOrUndefined(arg) {\n  return arg == null;\n}\nexports.isNullOrUndefined = isNullOrUndefined;\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\nexports.isNumber = isNumber;\n\nfunction isString(arg) {\n  return typeof arg === 'string';\n}\nexports.isString = isString;\n\nfunction isSymbol(arg) {\n  return typeof arg === 'symbol';\n}\nexports.isSymbol = isSymbol;\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\nexports.isUndefined = isUndefined;\n\nfunction isRegExp(re) {\n  return objectToString(re) === '[object RegExp]';\n}\nexports.isRegExp = isRegExp;\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\nexports.isObject = isObject;\n\nfunction isDate(d) {\n  return objectToString(d) === '[object Date]';\n}\nexports.isDate = isDate;\n\nfunction isError(e) {\n  return (objectToString(e) === '[object Error]' || e instanceof Error);\n}\nexports.isError = isError;\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\nexports.isFunction = isFunction;\n\nfunction isPrimitive(arg) {\n  return arg === null ||\n         typeof arg === 'boolean' ||\n         typeof arg === 'number' ||\n         typeof arg === 'string' ||\n         typeof arg === 'symbol' ||  // ES6 symbol\n         typeof arg === 'undefined';\n}\nexports.isPrimitive = isPrimitive;\n\nexports.isBuffer = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\").Buffer.isBuffer;\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY29yZS11dGlsLWlzL2xpYi91dGlsLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlOztBQUVmO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBO0FBQ0EsY0FBYzs7QUFFZDtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7O0FBRXpCO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjs7QUFFaEI7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCOztBQUVoQjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7O0FBRWhCO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjs7QUFFbkI7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCOztBQUVoQjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7O0FBRWhCO0FBQ0E7QUFDQTtBQUNBLGNBQWM7O0FBRWQ7QUFDQTtBQUNBO0FBQ0EsZUFBZTs7QUFFZjtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7O0FBRWxCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7O0FBRW5CLHNHQUFvRDs7QUFFcEQ7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9jb3JlLXV0aWwtaXMvbGliL3V0aWwuanM/ZWJhOSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gTk9URTogVGhlc2UgdHlwZSBjaGVja2luZyBmdW5jdGlvbnMgaW50ZW50aW9uYWxseSBkb24ndCB1c2UgYGluc3RhbmNlb2ZgXG4vLyBiZWNhdXNlIGl0IGlzIGZyYWdpbGUgYW5kIGNhbiBiZSBlYXNpbHkgZmFrZWQgd2l0aCBgT2JqZWN0LmNyZWF0ZSgpYC5cblxuZnVuY3Rpb24gaXNBcnJheShhcmcpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheShhcmcpO1xuICB9XG4gIHJldHVybiBvYmplY3RUb1N0cmluZyhhcmcpID09PSAnW29iamVjdCBBcnJheV0nO1xufVxuZXhwb3J0cy5pc0FycmF5ID0gaXNBcnJheTtcblxuZnVuY3Rpb24gaXNCb29sZWFuKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nO1xufVxuZXhwb3J0cy5pc0Jvb2xlYW4gPSBpc0Jvb2xlYW47XG5cbmZ1bmN0aW9uIGlzTnVsbChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsID0gaXNOdWxsO1xuXG5mdW5jdGlvbiBpc051bGxPclVuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGxPclVuZGVmaW5lZCA9IGlzTnVsbE9yVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc051bWJlcihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInO1xufVxuZXhwb3J0cy5pc051bWJlciA9IGlzTnVtYmVyO1xuXG5mdW5jdGlvbiBpc1N0cmluZyhhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnO1xufVxuZXhwb3J0cy5pc1N0cmluZyA9IGlzU3RyaW5nO1xuXG5mdW5jdGlvbiBpc1N5bWJvbChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnO1xufVxuZXhwb3J0cy5pc1N5bWJvbCA9IGlzU3ltYm9sO1xuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gdm9pZCAwO1xufVxuZXhwb3J0cy5pc1VuZGVmaW5lZCA9IGlzVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc1JlZ0V4cChyZSkge1xuICByZXR1cm4gb2JqZWN0VG9TdHJpbmcocmUpID09PSAnW29iamVjdCBSZWdFeHBdJztcbn1cbmV4cG9ydHMuaXNSZWdFeHAgPSBpc1JlZ0V4cDtcblxuZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG59XG5leHBvcnRzLmlzT2JqZWN0ID0gaXNPYmplY3Q7XG5cbmZ1bmN0aW9uIGlzRGF0ZShkKSB7XG4gIHJldHVybiBvYmplY3RUb1N0cmluZyhkKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xufVxuZXhwb3J0cy5pc0RhdGUgPSBpc0RhdGU7XG5cbmZ1bmN0aW9uIGlzRXJyb3IoZSkge1xuICByZXR1cm4gKG9iamVjdFRvU3RyaW5nKGUpID09PSAnW29iamVjdCBFcnJvcl0nIHx8IGUgaW5zdGFuY2VvZiBFcnJvcik7XG59XG5leHBvcnRzLmlzRXJyb3IgPSBpc0Vycm9yO1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJztcbn1cbmV4cG9ydHMuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG5cbmZ1bmN0aW9uIGlzUHJpbWl0aXZlKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnYm9vbGVhbicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdudW1iZXInIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3RyaW5nJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCcgfHwgIC8vIEVTNiBzeW1ib2xcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICd1bmRlZmluZWQnO1xufVxuZXhwb3J0cy5pc1ByaW1pdGl2ZSA9IGlzUHJpbWl0aXZlO1xuXG5leHBvcnRzLmlzQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyLmlzQnVmZmVyO1xuXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyhvKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobyk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/core-util-is/lib/util.js\n");

/***/ }),

/***/ "./node_modules/fast-deep-equal/index.js":
/*!***********************************************!*\
  !*** ./node_modules/fast-deep-equal/index.js ***!
  \***********************************************/
/***/ (function(module) {

"use strict";
eval("\n\n// do not edit .js files directly - edit src/index.jst\n\n\n\nmodule.exports = function equal(a, b) {\n  if (a === b) return true;\n\n  if (a && b && typeof a == 'object' && typeof b == 'object') {\n    if (a.constructor !== b.constructor) return false;\n\n    var length, i, keys;\n    if (Array.isArray(a)) {\n      length = a.length;\n      if (length != b.length) return false;\n      for (i = length; i-- !== 0;)\n        if (!equal(a[i], b[i])) return false;\n      return true;\n    }\n\n\n\n    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;\n    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();\n    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();\n\n    keys = Object.keys(a);\n    length = keys.length;\n    if (length !== Object.keys(b).length) return false;\n\n    for (i = length; i-- !== 0;)\n      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;\n\n    for (i = length; i-- !== 0;) {\n      var key = keys[i];\n\n      if (!equal(a[key], b[key])) return false;\n    }\n\n    return true;\n  }\n\n  // true if both NaN, false otherwise\n  return a!==a && b!==b;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZmFzdC1kZWVwLWVxdWFsL2luZGV4LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViOzs7O0FBSUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFVBQVU7QUFDakM7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIsVUFBVTtBQUMvQjs7QUFFQSxxQkFBcUIsVUFBVTtBQUMvQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9mYXN0LWRlZXAtZXF1YWwvaW5kZXguanM/MGJjNSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8vIGRvIG5vdCBlZGl0IC5qcyBmaWxlcyBkaXJlY3RseSAtIGVkaXQgc3JjL2luZGV4LmpzdFxuXG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBlcXVhbChhLCBiKSB7XG4gIGlmIChhID09PSBiKSByZXR1cm4gdHJ1ZTtcblxuICBpZiAoYSAmJiBiICYmIHR5cGVvZiBhID09ICdvYmplY3QnICYmIHR5cGVvZiBiID09ICdvYmplY3QnKSB7XG4gICAgaWYgKGEuY29uc3RydWN0b3IgIT09IGIuY29uc3RydWN0b3IpIHJldHVybiBmYWxzZTtcblxuICAgIHZhciBsZW5ndGgsIGksIGtleXM7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYSkpIHtcbiAgICAgIGxlbmd0aCA9IGEubGVuZ3RoO1xuICAgICAgaWYgKGxlbmd0aCAhPSBiLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICAgICAgZm9yIChpID0gbGVuZ3RoOyBpLS0gIT09IDA7KVxuICAgICAgICBpZiAoIWVxdWFsKGFbaV0sIGJbaV0pKSByZXR1cm4gZmFsc2U7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cblxuXG4gICAgaWYgKGEuY29uc3RydWN0b3IgPT09IFJlZ0V4cCkgcmV0dXJuIGEuc291cmNlID09PSBiLnNvdXJjZSAmJiBhLmZsYWdzID09PSBiLmZsYWdzO1xuICAgIGlmIChhLnZhbHVlT2YgIT09IE9iamVjdC5wcm90b3R5cGUudmFsdWVPZikgcmV0dXJuIGEudmFsdWVPZigpID09PSBiLnZhbHVlT2YoKTtcbiAgICBpZiAoYS50b1N0cmluZyAhPT0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZykgcmV0dXJuIGEudG9TdHJpbmcoKSA9PT0gYi50b1N0cmluZygpO1xuXG4gICAga2V5cyA9IE9iamVjdC5rZXlzKGEpO1xuICAgIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgIGlmIChsZW5ndGggIT09IE9iamVjdC5rZXlzKGIpLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgZm9yIChpID0gbGVuZ3RoOyBpLS0gIT09IDA7KVxuICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwga2V5c1tpXSkpIHJldHVybiBmYWxzZTtcblxuICAgIGZvciAoaSA9IGxlbmd0aDsgaS0tICE9PSAwOykge1xuICAgICAgdmFyIGtleSA9IGtleXNbaV07XG5cbiAgICAgIGlmICghZXF1YWwoYVtrZXldLCBiW2tleV0pKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvLyB0cnVlIGlmIGJvdGggTmFOLCBmYWxzZSBvdGhlcndpc2VcbiAgcmV0dXJuIGEhPT1hICYmIGIhPT1iO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/fast-deep-equal/index.js\n");

/***/ }),

/***/ "./node_modules/is-stream/index.js":
/*!*****************************************!*\
  !*** ./node_modules/is-stream/index.js ***!
  \*****************************************/
/***/ (function(module) {

"use strict";
eval("\n\nconst isStream = stream =>\n\tstream !== null &&\n\ttypeof stream === 'object' &&\n\ttypeof stream.pipe === 'function';\n\nisStream.writable = stream =>\n\tisStream(stream) &&\n\tstream.writable !== false &&\n\ttypeof stream._write === 'function' &&\n\ttypeof stream._writableState === 'object';\n\nisStream.readable = stream =>\n\tisStream(stream) &&\n\tstream.readable !== false &&\n\ttypeof stream._read === 'function' &&\n\ttypeof stream._readableState === 'object';\n\nisStream.duplex = stream =>\n\tisStream.writable(stream) &&\n\tisStream.readable(stream);\n\nisStream.transform = stream =>\n\tisStream.duplex(stream) &&\n\ttypeof stream._transform === 'function';\n\nmodule.exports = isStream;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaXMtc3RyZWFtL2luZGV4LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9pcy1zdHJlYW0vaW5kZXguanM/MTlkOCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGlzU3RyZWFtID0gc3RyZWFtID0+XG5cdHN0cmVhbSAhPT0gbnVsbCAmJlxuXHR0eXBlb2Ygc3RyZWFtID09PSAnb2JqZWN0JyAmJlxuXHR0eXBlb2Ygc3RyZWFtLnBpcGUgPT09ICdmdW5jdGlvbic7XG5cbmlzU3RyZWFtLndyaXRhYmxlID0gc3RyZWFtID0+XG5cdGlzU3RyZWFtKHN0cmVhbSkgJiZcblx0c3RyZWFtLndyaXRhYmxlICE9PSBmYWxzZSAmJlxuXHR0eXBlb2Ygc3RyZWFtLl93cml0ZSA9PT0gJ2Z1bmN0aW9uJyAmJlxuXHR0eXBlb2Ygc3RyZWFtLl93cml0YWJsZVN0YXRlID09PSAnb2JqZWN0JztcblxuaXNTdHJlYW0ucmVhZGFibGUgPSBzdHJlYW0gPT5cblx0aXNTdHJlYW0oc3RyZWFtKSAmJlxuXHRzdHJlYW0ucmVhZGFibGUgIT09IGZhbHNlICYmXG5cdHR5cGVvZiBzdHJlYW0uX3JlYWQgPT09ICdmdW5jdGlvbicgJiZcblx0dHlwZW9mIHN0cmVhbS5fcmVhZGFibGVTdGF0ZSA9PT0gJ29iamVjdCc7XG5cbmlzU3RyZWFtLmR1cGxleCA9IHN0cmVhbSA9PlxuXHRpc1N0cmVhbS53cml0YWJsZShzdHJlYW0pICYmXG5cdGlzU3RyZWFtLnJlYWRhYmxlKHN0cmVhbSk7XG5cbmlzU3RyZWFtLnRyYW5zZm9ybSA9IHN0cmVhbSA9PlxuXHRpc1N0cmVhbS5kdXBsZXgoc3RyZWFtKSAmJlxuXHR0eXBlb2Ygc3RyZWFtLl90cmFuc2Zvcm0gPT09ICdmdW5jdGlvbic7XG5cbm1vZHVsZS5leHBvcnRzID0gaXNTdHJlYW07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/is-stream/index.js\n");

/***/ }),

/***/ "./node_modules/process-nextick-args/index.js":
/*!****************************************************!*\
  !*** ./node_modules/process-nextick-args/index.js ***!
  \****************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("/* provided dependency */ var process = __webpack_require__(/*! process */ \"./node_modules/process/browser.js\");\n\n\nif (typeof process === 'undefined' ||\n    !process.version ||\n    process.version.indexOf('v0.') === 0 ||\n    process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {\n  module.exports = { nextTick: nextTick };\n} else {\n  module.exports = process\n}\n\nfunction nextTick(fn, arg1, arg2, arg3) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('\"callback\" argument must be a function');\n  }\n  var len = arguments.length;\n  var args, i;\n  switch (len) {\n  case 0:\n  case 1:\n    return process.nextTick(fn);\n  case 2:\n    return process.nextTick(function afterTickOne() {\n      fn.call(null, arg1);\n    });\n  case 3:\n    return process.nextTick(function afterTickTwo() {\n      fn.call(null, arg1, arg2);\n    });\n  case 4:\n    return process.nextTick(function afterTickThree() {\n      fn.call(null, arg1, arg2, arg3);\n    });\n  default:\n    args = new Array(len - 1);\n    i = 0;\n    while (i < args.length) {\n      args[i++] = arguments[i];\n    }\n    return process.nextTick(function afterTick() {\n      fn.apply(null, args);\n    });\n  }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcHJvY2Vzcy1uZXh0aWNrLWFyZ3MvaW5kZXguanMuanMiLCJtYXBwaW5ncyI6IjtBQUFhOztBQUViLFdBQVcsT0FBTztBQUNsQixLQUFLLE9BQU87QUFDWixJQUFJLE9BQU87QUFDWCxJQUFJLE9BQU8saUNBQWlDLE9BQU87QUFDbkQscUJBQXFCO0FBQ3JCLEVBQUU7QUFDRixtQkFBbUIsT0FBTztBQUMxQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQSxLQUFLO0FBQ0w7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQSxLQUFLO0FBQ0w7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0EsS0FBSztBQUNMO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3Byb2Nlc3MtbmV4dGljay1hcmdzL2luZGV4LmpzP2ZjZTAiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5pZiAodHlwZW9mIHByb2Nlc3MgPT09ICd1bmRlZmluZWQnIHx8XG4gICAgIXByb2Nlc3MudmVyc2lvbiB8fFxuICAgIHByb2Nlc3MudmVyc2lvbi5pbmRleE9mKCd2MC4nKSA9PT0gMCB8fFxuICAgIHByb2Nlc3MudmVyc2lvbi5pbmRleE9mKCd2MS4nKSA9PT0gMCAmJiBwcm9jZXNzLnZlcnNpb24uaW5kZXhPZigndjEuOC4nKSAhPT0gMCkge1xuICBtb2R1bGUuZXhwb3J0cyA9IHsgbmV4dFRpY2s6IG5leHRUaWNrIH07XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHByb2Nlc3Ncbn1cblxuZnVuY3Rpb24gbmV4dFRpY2soZm4sIGFyZzEsIGFyZzIsIGFyZzMpIHtcbiAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiY2FsbGJhY2tcIiBhcmd1bWVudCBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgfVxuICB2YXIgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgdmFyIGFyZ3MsIGk7XG4gIHN3aXRjaCAobGVuKSB7XG4gIGNhc2UgMDpcbiAgY2FzZSAxOlxuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZuKTtcbiAgY2FzZSAyOlxuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uIGFmdGVyVGlja09uZSgpIHtcbiAgICAgIGZuLmNhbGwobnVsbCwgYXJnMSk7XG4gICAgfSk7XG4gIGNhc2UgMzpcbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiBhZnRlclRpY2tUd28oKSB7XG4gICAgICBmbi5jYWxsKG51bGwsIGFyZzEsIGFyZzIpO1xuICAgIH0pO1xuICBjYXNlIDQ6XG4gICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gYWZ0ZXJUaWNrVGhyZWUoKSB7XG4gICAgICBmbi5jYWxsKG51bGwsIGFyZzEsIGFyZzIsIGFyZzMpO1xuICAgIH0pO1xuICBkZWZhdWx0OlxuICAgIGFyZ3MgPSBuZXcgQXJyYXkobGVuIC0gMSk7XG4gICAgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBhcmdzLmxlbmd0aCkge1xuICAgICAgYXJnc1tpKytdID0gYXJndW1lbnRzW2ldO1xuICAgIH1cbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiBhZnRlclRpY2soKSB7XG4gICAgICBmbi5hcHBseShudWxsLCBhcmdzKTtcbiAgICB9KTtcbiAgfVxufVxuXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/process-nextick-args/index.js\n");

/***/ }),

/***/ "./node_modules/through2/node_modules/isarray/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/through2/node_modules/isarray/index.js ***!
  \*************************************************************/
/***/ (function(module) {

eval("var toString = {}.toString;\n\nmodule.exports = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGhyb3VnaDIvbm9kZV9tb2R1bGVzL2lzYXJyYXkvaW5kZXguanMuanMiLCJtYXBwaW5ncyI6IkFBQUEsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3Rocm91Z2gyL25vZGVfbW9kdWxlcy9pc2FycmF5L2luZGV4LmpzP2RjNDUiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XG5cbm1vZHVsZS5leHBvcnRzID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoYXJyKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKGFycikgPT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/through2/node_modules/isarray/index.js\n");

/***/ }),

/***/ "./node_modules/through2/node_modules/readable-stream/lib/_stream_duplex.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/through2/node_modules/readable-stream/lib/_stream_duplex.js ***!
  \**********************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a duplex stream is just a stream that is both readable and writable.\n// Since JS doesn't have multiple prototypal inheritance, this class\n// prototypally inherits from Readable, and then parasitically from\n// Writable.\n\n\n\n/*<replacement>*/\n\nvar pna = __webpack_require__(/*! process-nextick-args */ \"./node_modules/process-nextick-args/index.js\");\n/*</replacement>*/\n\n/*<replacement>*/\nvar objectKeys = Object.keys || function (obj) {\n  var keys = [];\n  for (var key in obj) {\n    keys.push(key);\n  }return keys;\n};\n/*</replacement>*/\n\nmodule.exports = Duplex;\n\n/*<replacement>*/\nvar util = Object.create(__webpack_require__(/*! core-util-is */ \"./node_modules/core-util-is/lib/util.js\"));\nutil.inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\");\n/*</replacement>*/\n\nvar Readable = __webpack_require__(/*! ./_stream_readable */ \"./node_modules/through2/node_modules/readable-stream/lib/_stream_readable.js\");\nvar Writable = __webpack_require__(/*! ./_stream_writable */ \"./node_modules/through2/node_modules/readable-stream/lib/_stream_writable.js\");\n\nutil.inherits(Duplex, Readable);\n\n{\n  // avoid scope creep, the keys array can then be collected\n  var keys = objectKeys(Writable.prototype);\n  for (var v = 0; v < keys.length; v++) {\n    var method = keys[v];\n    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];\n  }\n}\n\nfunction Duplex(options) {\n  if (!(this instanceof Duplex)) return new Duplex(options);\n\n  Readable.call(this, options);\n  Writable.call(this, options);\n\n  if (options && options.readable === false) this.readable = false;\n\n  if (options && options.writable === false) this.writable = false;\n\n  this.allowHalfOpen = true;\n  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;\n\n  this.once('end', onend);\n}\n\nObject.defineProperty(Duplex.prototype, 'writableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function () {\n    return this._writableState.highWaterMark;\n  }\n});\n\n// the no-half-open enforcer\nfunction onend() {\n  // if we allow half-open state, or if the writable side ended,\n  // then we're ok.\n  if (this.allowHalfOpen || this._writableState.ended) return;\n\n  // no more data can be written.\n  // But allow more writes to happen in this tick.\n  pna.nextTick(onEndNT, this);\n}\n\nfunction onEndNT(self) {\n  self.end();\n}\n\nObject.defineProperty(Duplex.prototype, 'destroyed', {\n  get: function () {\n    if (this._readableState === undefined || this._writableState === undefined) {\n      return false;\n    }\n    return this._readableState.destroyed && this._writableState.destroyed;\n  },\n  set: function (value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (this._readableState === undefined || this._writableState === undefined) {\n      return;\n    }\n\n    // backward compatibility, the user is explicitly\n    // managing destroyed\n    this._readableState.destroyed = value;\n    this._writableState.destroyed = value;\n  }\n});\n\nDuplex.prototype._destroy = function (err, cb) {\n  this.push(null);\n  this.end();\n\n  pna.nextTick(cb, err);\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGhyb3VnaDIvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9kdXBsZXguanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYjs7QUFFQSxVQUFVLG1CQUFPLENBQUMsMEVBQXNCO0FBQ3hDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLHlCQUF5QixtQkFBTyxDQUFDLDZEQUFjO0FBQy9DLGdCQUFnQixtQkFBTyxDQUFDLDZEQUFVO0FBQ2xDOztBQUVBLGVBQWUsbUJBQU8sQ0FBQyx3R0FBb0I7QUFDM0MsZUFBZSxtQkFBTyxDQUFDLHdHQUFvQjs7QUFFM0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGlCQUFpQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3Rocm91Z2gyL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fZHVwbGV4LmpzP2MzYTAiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIGEgZHVwbGV4IHN0cmVhbSBpcyBqdXN0IGEgc3RyZWFtIHRoYXQgaXMgYm90aCByZWFkYWJsZSBhbmQgd3JpdGFibGUuXG4vLyBTaW5jZSBKUyBkb2Vzbid0IGhhdmUgbXVsdGlwbGUgcHJvdG90eXBhbCBpbmhlcml0YW5jZSwgdGhpcyBjbGFzc1xuLy8gcHJvdG90eXBhbGx5IGluaGVyaXRzIGZyb20gUmVhZGFibGUsIGFuZCB0aGVuIHBhcmFzaXRpY2FsbHkgZnJvbVxuLy8gV3JpdGFibGUuXG5cbid1c2Ugc3RyaWN0JztcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIHBuYSA9IHJlcXVpcmUoJ3Byb2Nlc3MtbmV4dGljay1hcmdzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBvYmplY3RLZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24gKG9iaikge1xuICB2YXIga2V5cyA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAga2V5cy5wdXNoKGtleSk7XG4gIH1yZXR1cm4ga2V5cztcbn07XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxubW9kdWxlLmV4cG9ydHMgPSBEdXBsZXg7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IE9iamVjdC5jcmVhdGUocmVxdWlyZSgnY29yZS11dGlsLWlzJykpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudmFyIFJlYWRhYmxlID0gcmVxdWlyZSgnLi9fc3RyZWFtX3JlYWRhYmxlJyk7XG52YXIgV3JpdGFibGUgPSByZXF1aXJlKCcuL19zdHJlYW1fd3JpdGFibGUnKTtcblxudXRpbC5pbmhlcml0cyhEdXBsZXgsIFJlYWRhYmxlKTtcblxue1xuICAvLyBhdm9pZCBzY29wZSBjcmVlcCwgdGhlIGtleXMgYXJyYXkgY2FuIHRoZW4gYmUgY29sbGVjdGVkXG4gIHZhciBrZXlzID0gb2JqZWN0S2V5cyhXcml0YWJsZS5wcm90b3R5cGUpO1xuICBmb3IgKHZhciB2ID0gMDsgdiA8IGtleXMubGVuZ3RoOyB2KyspIHtcbiAgICB2YXIgbWV0aG9kID0ga2V5c1t2XTtcbiAgICBpZiAoIUR1cGxleC5wcm90b3R5cGVbbWV0aG9kXSkgRHVwbGV4LnByb3RvdHlwZVttZXRob2RdID0gV3JpdGFibGUucHJvdG90eXBlW21ldGhvZF07XG4gIH1cbn1cblxuZnVuY3Rpb24gRHVwbGV4KG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIER1cGxleCkpIHJldHVybiBuZXcgRHVwbGV4KG9wdGlvbnMpO1xuXG4gIFJlYWRhYmxlLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gIFdyaXRhYmxlLmNhbGwodGhpcywgb3B0aW9ucyk7XG5cbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5yZWFkYWJsZSA9PT0gZmFsc2UpIHRoaXMucmVhZGFibGUgPSBmYWxzZTtcblxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLndyaXRhYmxlID09PSBmYWxzZSkgdGhpcy53cml0YWJsZSA9IGZhbHNlO1xuXG4gIHRoaXMuYWxsb3dIYWxmT3BlbiA9IHRydWU7XG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMuYWxsb3dIYWxmT3BlbiA9PT0gZmFsc2UpIHRoaXMuYWxsb3dIYWxmT3BlbiA9IGZhbHNlO1xuXG4gIHRoaXMub25jZSgnZW5kJywgb25lbmQpO1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRHVwbGV4LnByb3RvdHlwZSwgJ3dyaXRhYmxlSGlnaFdhdGVyTWFyaycsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUuaGlnaFdhdGVyTWFyaztcbiAgfVxufSk7XG5cbi8vIHRoZSBuby1oYWxmLW9wZW4gZW5mb3JjZXJcbmZ1bmN0aW9uIG9uZW5kKCkge1xuICAvLyBpZiB3ZSBhbGxvdyBoYWxmLW9wZW4gc3RhdGUsIG9yIGlmIHRoZSB3cml0YWJsZSBzaWRlIGVuZGVkLFxuICAvLyB0aGVuIHdlJ3JlIG9rLlxuICBpZiAodGhpcy5hbGxvd0hhbGZPcGVuIHx8IHRoaXMuX3dyaXRhYmxlU3RhdGUuZW5kZWQpIHJldHVybjtcblxuICAvLyBubyBtb3JlIGRhdGEgY2FuIGJlIHdyaXR0ZW4uXG4gIC8vIEJ1dCBhbGxvdyBtb3JlIHdyaXRlcyB0byBoYXBwZW4gaW4gdGhpcyB0aWNrLlxuICBwbmEubmV4dFRpY2sob25FbmROVCwgdGhpcyk7XG59XG5cbmZ1bmN0aW9uIG9uRW5kTlQoc2VsZikge1xuICBzZWxmLmVuZCgpO1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRHVwbGV4LnByb3RvdHlwZSwgJ2Rlc3Ryb3llZCcsIHtcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCB8fCB0aGlzLl93cml0YWJsZVN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkICYmIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIC8vIHdlIGlnbm9yZSB0aGUgdmFsdWUgaWYgdGhlIHN0cmVhbVxuICAgIC8vIGhhcyBub3QgYmVlbiBpbml0aWFsaXplZCB5ZXRcbiAgICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkIHx8IHRoaXMuX3dyaXRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHRoZSB1c2VyIGlzIGV4cGxpY2l0bHlcbiAgICAvLyBtYW5hZ2luZyBkZXN0cm95ZWRcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCA9IHZhbHVlO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkID0gdmFsdWU7XG4gIH1cbn0pO1xuXG5EdXBsZXgucHJvdG90eXBlLl9kZXN0cm95ID0gZnVuY3Rpb24gKGVyciwgY2IpIHtcbiAgdGhpcy5wdXNoKG51bGwpO1xuICB0aGlzLmVuZCgpO1xuXG4gIHBuYS5uZXh0VGljayhjYiwgZXJyKTtcbn07Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/through2/node_modules/readable-stream/lib/_stream_duplex.js\n");

/***/ }),

/***/ "./node_modules/through2/node_modules/readable-stream/lib/_stream_passthrough.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/through2/node_modules/readable-stream/lib/_stream_passthrough.js ***!
  \***************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a passthrough stream.\n// basically just the most minimal sort of Transform stream.\n// Every written chunk gets output as-is.\n\n\n\nmodule.exports = PassThrough;\n\nvar Transform = __webpack_require__(/*! ./_stream_transform */ \"./node_modules/through2/node_modules/readable-stream/lib/_stream_transform.js\");\n\n/*<replacement>*/\nvar util = Object.create(__webpack_require__(/*! core-util-is */ \"./node_modules/core-util-is/lib/util.js\"));\nutil.inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\");\n/*</replacement>*/\n\nutil.inherits(PassThrough, Transform);\n\nfunction PassThrough(options) {\n  if (!(this instanceof PassThrough)) return new PassThrough(options);\n\n  Transform.call(this, options);\n}\n\nPassThrough.prototype._transform = function (chunk, encoding, cb) {\n  cb(null, chunk);\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGhyb3VnaDIvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9wYXNzdGhyb3VnaC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYjs7QUFFQSxnQkFBZ0IsbUJBQU8sQ0FBQywwR0FBcUI7O0FBRTdDO0FBQ0EseUJBQXlCLG1CQUFPLENBQUMsNkRBQWM7QUFDL0MsZ0JBQWdCLG1CQUFPLENBQUMsNkRBQVU7QUFDbEM7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdGhyb3VnaDIvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9wYXNzdGhyb3VnaC5qcz9jMDcxIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyBhIHBhc3N0aHJvdWdoIHN0cmVhbS5cbi8vIGJhc2ljYWxseSBqdXN0IHRoZSBtb3N0IG1pbmltYWwgc29ydCBvZiBUcmFuc2Zvcm0gc3RyZWFtLlxuLy8gRXZlcnkgd3JpdHRlbiBjaHVuayBnZXRzIG91dHB1dCBhcy1pcy5cblxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBhc3NUaHJvdWdoO1xuXG52YXIgVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9fc3RyZWFtX3RyYW5zZm9ybScpO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSBPYmplY3QuY3JlYXRlKHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnV0aWwuaW5oZXJpdHMoUGFzc1Rocm91Z2gsIFRyYW5zZm9ybSk7XG5cbmZ1bmN0aW9uIFBhc3NUaHJvdWdoKG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFBhc3NUaHJvdWdoKSkgcmV0dXJuIG5ldyBQYXNzVGhyb3VnaChvcHRpb25zKTtcblxuICBUcmFuc2Zvcm0uY2FsbCh0aGlzLCBvcHRpb25zKTtcbn1cblxuUGFzc1Rocm91Z2gucHJvdG90eXBlLl90cmFuc2Zvcm0gPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBjYihudWxsLCBjaHVuayk7XG59OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/through2/node_modules/readable-stream/lib/_stream_passthrough.js\n");

/***/ }),

/***/ "./node_modules/through2/node_modules/readable-stream/lib/_stream_readable.js":
/*!************************************************************************************!*\
  !*** ./node_modules/through2/node_modules/readable-stream/lib/_stream_readable.js ***!
  \************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("/* provided dependency */ var process = __webpack_require__(/*! process */ \"./node_modules/process/browser.js\");\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n/*<replacement>*/\n\nvar pna = __webpack_require__(/*! process-nextick-args */ \"./node_modules/process-nextick-args/index.js\");\n/*</replacement>*/\n\nmodule.exports = Readable;\n\n/*<replacement>*/\nvar isArray = __webpack_require__(/*! isarray */ \"./node_modules/through2/node_modules/isarray/index.js\");\n/*</replacement>*/\n\n/*<replacement>*/\nvar Duplex;\n/*</replacement>*/\n\nReadable.ReadableState = ReadableState;\n\n/*<replacement>*/\nvar EE = (__webpack_require__(/*! events */ \"./node_modules/events/events.js\").EventEmitter);\n\nvar EElistenerCount = function (emitter, type) {\n  return emitter.listeners(type).length;\n};\n/*</replacement>*/\n\n/*<replacement>*/\nvar Stream = __webpack_require__(/*! ./internal/streams/stream */ \"./node_modules/through2/node_modules/readable-stream/lib/internal/streams/stream-browser.js\");\n/*</replacement>*/\n\n/*<replacement>*/\n\nvar Buffer = (__webpack_require__(/*! safe-buffer */ \"./node_modules/through2/node_modules/safe-buffer/index.js\").Buffer);\nvar OurUint8Array = __webpack_require__.g.Uint8Array || function () {};\nfunction _uint8ArrayToBuffer(chunk) {\n  return Buffer.from(chunk);\n}\nfunction _isUint8Array(obj) {\n  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n}\n\n/*</replacement>*/\n\n/*<replacement>*/\nvar util = Object.create(__webpack_require__(/*! core-util-is */ \"./node_modules/core-util-is/lib/util.js\"));\nutil.inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\");\n/*</replacement>*/\n\n/*<replacement>*/\nvar debugUtil = __webpack_require__(/*! util */ \"?6818\");\nvar debug = void 0;\nif (debugUtil && debugUtil.debuglog) {\n  debug = debugUtil.debuglog('stream');\n} else {\n  debug = function () {};\n}\n/*</replacement>*/\n\nvar BufferList = __webpack_require__(/*! ./internal/streams/BufferList */ \"./node_modules/through2/node_modules/readable-stream/lib/internal/streams/BufferList.js\");\nvar destroyImpl = __webpack_require__(/*! ./internal/streams/destroy */ \"./node_modules/through2/node_modules/readable-stream/lib/internal/streams/destroy.js\");\nvar StringDecoder;\n\nutil.inherits(Readable, Stream);\n\nvar kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];\n\nfunction prependListener(emitter, event, fn) {\n  // Sadly this is not cacheable as some libraries bundle their own\n  // event emitter implementation with them.\n  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn);\n\n  // This is a hack to make sure that our error handler is attached before any\n  // userland ones.  NEVER DO THIS. This is here only because this code needs\n  // to continue to work with older versions of Node.js that do not include\n  // the prependListener() method. The goal is to eventually remove this hack.\n  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];\n}\n\nfunction ReadableState(options, stream) {\n  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ \"./node_modules/through2/node_modules/readable-stream/lib/_stream_duplex.js\");\n\n  options = options || {};\n\n  // Duplex streams are both readable and writable, but share\n  // the same options object.\n  // However, some cases require setting options to different\n  // values for the readable and the writable sides of the duplex stream.\n  // These options can be provided separately as readableXXX and writableXXX.\n  var isDuplex = stream instanceof Duplex;\n\n  // object stream flag. Used to make read(n) ignore n and to\n  // make all the buffer merging and length checks go away\n  this.objectMode = !!options.objectMode;\n\n  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;\n\n  // the point at which it stops calling _read() to fill the buffer\n  // Note: 0 is a valid value, means \"don't call _read preemptively ever\"\n  var hwm = options.highWaterMark;\n  var readableHwm = options.readableHighWaterMark;\n  var defaultHwm = this.objectMode ? 16 : 16 * 1024;\n\n  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (readableHwm || readableHwm === 0)) this.highWaterMark = readableHwm;else this.highWaterMark = defaultHwm;\n\n  // cast to ints.\n  this.highWaterMark = Math.floor(this.highWaterMark);\n\n  // A linked list is used to store data chunks instead of an array because the\n  // linked list can remove elements from the beginning faster than\n  // array.shift()\n  this.buffer = new BufferList();\n  this.length = 0;\n  this.pipes = null;\n  this.pipesCount = 0;\n  this.flowing = null;\n  this.ended = false;\n  this.endEmitted = false;\n  this.reading = false;\n\n  // a flag to be able to tell if the event 'readable'/'data' is emitted\n  // immediately, or on a later tick.  We set this to true at first, because\n  // any actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first read call.\n  this.sync = true;\n\n  // whenever we return null, then we set a flag to say\n  // that we're awaiting a 'readable' event emission.\n  this.needReadable = false;\n  this.emittedReadable = false;\n  this.readableListening = false;\n  this.resumeScheduled = false;\n\n  // has it been destroyed\n  this.destroyed = false;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  // the number of writers that are awaiting a drain event in .pipe()s\n  this.awaitDrain = 0;\n\n  // if true, a maybeReadMore has been scheduled\n  this.readingMore = false;\n\n  this.decoder = null;\n  this.encoding = null;\n  if (options.encoding) {\n    if (!StringDecoder) StringDecoder = (__webpack_require__(/*! string_decoder/ */ \"./node_modules/through2/node_modules/string_decoder/lib/string_decoder.js\").StringDecoder);\n    this.decoder = new StringDecoder(options.encoding);\n    this.encoding = options.encoding;\n  }\n}\n\nfunction Readable(options) {\n  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ \"./node_modules/through2/node_modules/readable-stream/lib/_stream_duplex.js\");\n\n  if (!(this instanceof Readable)) return new Readable(options);\n\n  this._readableState = new ReadableState(options, this);\n\n  // legacy\n  this.readable = true;\n\n  if (options) {\n    if (typeof options.read === 'function') this._read = options.read;\n\n    if (typeof options.destroy === 'function') this._destroy = options.destroy;\n  }\n\n  Stream.call(this);\n}\n\nObject.defineProperty(Readable.prototype, 'destroyed', {\n  get: function () {\n    if (this._readableState === undefined) {\n      return false;\n    }\n    return this._readableState.destroyed;\n  },\n  set: function (value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (!this._readableState) {\n      return;\n    }\n\n    // backward compatibility, the user is explicitly\n    // managing destroyed\n    this._readableState.destroyed = value;\n  }\n});\n\nReadable.prototype.destroy = destroyImpl.destroy;\nReadable.prototype._undestroy = destroyImpl.undestroy;\nReadable.prototype._destroy = function (err, cb) {\n  this.push(null);\n  cb(err);\n};\n\n// Manually shove something into the read() buffer.\n// This returns true if the highWaterMark has not been hit yet,\n// similar to how Writable.write() returns true if you should\n// write() some more.\nReadable.prototype.push = function (chunk, encoding) {\n  var state = this._readableState;\n  var skipChunkCheck;\n\n  if (!state.objectMode) {\n    if (typeof chunk === 'string') {\n      encoding = encoding || state.defaultEncoding;\n      if (encoding !== state.encoding) {\n        chunk = Buffer.from(chunk, encoding);\n        encoding = '';\n      }\n      skipChunkCheck = true;\n    }\n  } else {\n    skipChunkCheck = true;\n  }\n\n  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);\n};\n\n// Unshift should *always* be something directly out of read()\nReadable.prototype.unshift = function (chunk) {\n  return readableAddChunk(this, chunk, null, true, false);\n};\n\nfunction readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {\n  var state = stream._readableState;\n  if (chunk === null) {\n    state.reading = false;\n    onEofChunk(stream, state);\n  } else {\n    var er;\n    if (!skipChunkCheck) er = chunkInvalid(state, chunk);\n    if (er) {\n      stream.emit('error', er);\n    } else if (state.objectMode || chunk && chunk.length > 0) {\n      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {\n        chunk = _uint8ArrayToBuffer(chunk);\n      }\n\n      if (addToFront) {\n        if (state.endEmitted) stream.emit('error', new Error('stream.unshift() after end event'));else addChunk(stream, state, chunk, true);\n      } else if (state.ended) {\n        stream.emit('error', new Error('stream.push() after EOF'));\n      } else {\n        state.reading = false;\n        if (state.decoder && !encoding) {\n          chunk = state.decoder.write(chunk);\n          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);\n        } else {\n          addChunk(stream, state, chunk, false);\n        }\n      }\n    } else if (!addToFront) {\n      state.reading = false;\n    }\n  }\n\n  return needMoreData(state);\n}\n\nfunction addChunk(stream, state, chunk, addToFront) {\n  if (state.flowing && state.length === 0 && !state.sync) {\n    stream.emit('data', chunk);\n    stream.read(0);\n  } else {\n    // update the buffer info.\n    state.length += state.objectMode ? 1 : chunk.length;\n    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);\n\n    if (state.needReadable) emitReadable(stream);\n  }\n  maybeReadMore(stream, state);\n}\n\nfunction chunkInvalid(state, chunk) {\n  var er;\n  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {\n    er = new TypeError('Invalid non-string/buffer chunk');\n  }\n  return er;\n}\n\n// if it's past the high water mark, we can push in some more.\n// Also, if we have no data yet, we can stand some\n// more bytes.  This is to work around cases where hwm=0,\n// such as the repl.  Also, if the push() triggered a\n// readable event, and the user called read(largeNumber) such that\n// needReadable was set, then we ought to push more, so that another\n// 'readable' event will be triggered.\nfunction needMoreData(state) {\n  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);\n}\n\nReadable.prototype.isPaused = function () {\n  return this._readableState.flowing === false;\n};\n\n// backwards compatibility.\nReadable.prototype.setEncoding = function (enc) {\n  if (!StringDecoder) StringDecoder = (__webpack_require__(/*! string_decoder/ */ \"./node_modules/through2/node_modules/string_decoder/lib/string_decoder.js\").StringDecoder);\n  this._readableState.decoder = new StringDecoder(enc);\n  this._readableState.encoding = enc;\n  return this;\n};\n\n// Don't raise the hwm > 8MB\nvar MAX_HWM = 0x800000;\nfunction computeNewHighWaterMark(n) {\n  if (n >= MAX_HWM) {\n    n = MAX_HWM;\n  } else {\n    // Get the next highest power of 2 to prevent increasing hwm excessively in\n    // tiny amounts\n    n--;\n    n |= n >>> 1;\n    n |= n >>> 2;\n    n |= n >>> 4;\n    n |= n >>> 8;\n    n |= n >>> 16;\n    n++;\n  }\n  return n;\n}\n\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction howMuchToRead(n, state) {\n  if (n <= 0 || state.length === 0 && state.ended) return 0;\n  if (state.objectMode) return 1;\n  if (n !== n) {\n    // Only flow one buffer at a time\n    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;\n  }\n  // If we're asking for more than the current hwm, then raise the hwm.\n  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);\n  if (n <= state.length) return n;\n  // Don't have enough\n  if (!state.ended) {\n    state.needReadable = true;\n    return 0;\n  }\n  return state.length;\n}\n\n// you can override either this method, or the async _read(n) below.\nReadable.prototype.read = function (n) {\n  debug('read', n);\n  n = parseInt(n, 10);\n  var state = this._readableState;\n  var nOrig = n;\n\n  if (n !== 0) state.emittedReadable = false;\n\n  // if we're doing read(0) to trigger a readable event, but we\n  // already have a bunch of data in the buffer, then just trigger\n  // the 'readable' event and move on.\n  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {\n    debug('read: emitReadable', state.length, state.ended);\n    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);\n    return null;\n  }\n\n  n = howMuchToRead(n, state);\n\n  // if we've ended, and we're now clear, then finish it up.\n  if (n === 0 && state.ended) {\n    if (state.length === 0) endReadable(this);\n    return null;\n  }\n\n  // All the actual chunk generation logic needs to be\n  // *below* the call to _read.  The reason is that in certain\n  // synthetic stream cases, such as passthrough streams, _read\n  // may be a completely synchronous operation which may change\n  // the state of the read buffer, providing enough data when\n  // before there was *not* enough.\n  //\n  // So, the steps are:\n  // 1. Figure out what the state of things will be after we do\n  // a read from the buffer.\n  //\n  // 2. If that resulting state will trigger a _read, then call _read.\n  // Note that this may be asynchronous, or synchronous.  Yes, it is\n  // deeply ugly to write APIs this way, but that still doesn't mean\n  // that the Readable class should behave improperly, as streams are\n  // designed to be sync/async agnostic.\n  // Take note if the _read call is sync or async (ie, if the read call\n  // has returned yet), so that we know whether or not it's safe to emit\n  // 'readable' etc.\n  //\n  // 3. Actually pull the requested chunks out of the buffer and return.\n\n  // if we need a readable event, then we need to do some reading.\n  var doRead = state.needReadable;\n  debug('need readable', doRead);\n\n  // if we currently have less than the highWaterMark, then also read some\n  if (state.length === 0 || state.length - n < state.highWaterMark) {\n    doRead = true;\n    debug('length less than watermark', doRead);\n  }\n\n  // however, if we've ended, then there's no point, and if we're already\n  // reading, then it's unnecessary.\n  if (state.ended || state.reading) {\n    doRead = false;\n    debug('reading or ended', doRead);\n  } else if (doRead) {\n    debug('do read');\n    state.reading = true;\n    state.sync = true;\n    // if the length is currently zero, then we *need* a readable event.\n    if (state.length === 0) state.needReadable = true;\n    // call internal read method\n    this._read(state.highWaterMark);\n    state.sync = false;\n    // If _read pushed data synchronously, then `reading` will be false,\n    // and we need to re-evaluate how much data we can return to the user.\n    if (!state.reading) n = howMuchToRead(nOrig, state);\n  }\n\n  var ret;\n  if (n > 0) ret = fromList(n, state);else ret = null;\n\n  if (ret === null) {\n    state.needReadable = true;\n    n = 0;\n  } else {\n    state.length -= n;\n  }\n\n  if (state.length === 0) {\n    // If we have nothing in the buffer, then we want to know\n    // as soon as we *do* get something into the buffer.\n    if (!state.ended) state.needReadable = true;\n\n    // If we tried to read() past the EOF, then emit end on the next tick.\n    if (nOrig !== n && state.ended) endReadable(this);\n  }\n\n  if (ret !== null) this.emit('data', ret);\n\n  return ret;\n};\n\nfunction onEofChunk(stream, state) {\n  if (state.ended) return;\n  if (state.decoder) {\n    var chunk = state.decoder.end();\n    if (chunk && chunk.length) {\n      state.buffer.push(chunk);\n      state.length += state.objectMode ? 1 : chunk.length;\n    }\n  }\n  state.ended = true;\n\n  // emit 'readable' now to make sure it gets picked up.\n  emitReadable(stream);\n}\n\n// Don't emit readable right away in sync mode, because this can trigger\n// another read() call => stack overflow.  This way, it might trigger\n// a nextTick recursion warning, but that's not so bad.\nfunction emitReadable(stream) {\n  var state = stream._readableState;\n  state.needReadable = false;\n  if (!state.emittedReadable) {\n    debug('emitReadable', state.flowing);\n    state.emittedReadable = true;\n    if (state.sync) pna.nextTick(emitReadable_, stream);else emitReadable_(stream);\n  }\n}\n\nfunction emitReadable_(stream) {\n  debug('emit readable');\n  stream.emit('readable');\n  flow(stream);\n}\n\n// at this point, the user has presumably seen the 'readable' event,\n// and called read() to consume some data.  that may have triggered\n// in turn another _read(n) call, in which case reading = true if\n// it's in progress.\n// However, if we're not ended, or reading, and the length < hwm,\n// then go ahead and try to read some more preemptively.\nfunction maybeReadMore(stream, state) {\n  if (!state.readingMore) {\n    state.readingMore = true;\n    pna.nextTick(maybeReadMore_, stream, state);\n  }\n}\n\nfunction maybeReadMore_(stream, state) {\n  var len = state.length;\n  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {\n    debug('maybeReadMore read 0');\n    stream.read(0);\n    if (len === state.length)\n      // didn't get any data, stop spinning.\n      break;else len = state.length;\n  }\n  state.readingMore = false;\n}\n\n// abstract method.  to be overridden in specific implementation classes.\n// call cb(er, data) where data is <= n in length.\n// for virtual (non-string, non-buffer) streams, \"length\" is somewhat\n// arbitrary, and perhaps not very meaningful.\nReadable.prototype._read = function (n) {\n  this.emit('error', new Error('_read() is not implemented'));\n};\n\nReadable.prototype.pipe = function (dest, pipeOpts) {\n  var src = this;\n  var state = this._readableState;\n\n  switch (state.pipesCount) {\n    case 0:\n      state.pipes = dest;\n      break;\n    case 1:\n      state.pipes = [state.pipes, dest];\n      break;\n    default:\n      state.pipes.push(dest);\n      break;\n  }\n  state.pipesCount += 1;\n  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);\n\n  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;\n\n  var endFn = doEnd ? onend : unpipe;\n  if (state.endEmitted) pna.nextTick(endFn);else src.once('end', endFn);\n\n  dest.on('unpipe', onunpipe);\n  function onunpipe(readable, unpipeInfo) {\n    debug('onunpipe');\n    if (readable === src) {\n      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {\n        unpipeInfo.hasUnpiped = true;\n        cleanup();\n      }\n    }\n  }\n\n  function onend() {\n    debug('onend');\n    dest.end();\n  }\n\n  // when the dest drains, it reduces the awaitDrain counter\n  // on the source.  This would be more elegant with a .once()\n  // handler in flow(), but adding and removing repeatedly is\n  // too slow.\n  var ondrain = pipeOnDrain(src);\n  dest.on('drain', ondrain);\n\n  var cleanedUp = false;\n  function cleanup() {\n    debug('cleanup');\n    // cleanup event handlers once the pipe is broken\n    dest.removeListener('close', onclose);\n    dest.removeListener('finish', onfinish);\n    dest.removeListener('drain', ondrain);\n    dest.removeListener('error', onerror);\n    dest.removeListener('unpipe', onunpipe);\n    src.removeListener('end', onend);\n    src.removeListener('end', unpipe);\n    src.removeListener('data', ondata);\n\n    cleanedUp = true;\n\n    // if the reader is waiting for a drain event from this\n    // specific writer, then it would cause it to never start\n    // flowing again.\n    // So, if this is awaiting a drain, then we just call it now.\n    // If we don't know, then assume that we are waiting for one.\n    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();\n  }\n\n  // If the user pushes more data while we're writing to dest then we'll end up\n  // in ondata again. However, we only want to increase awaitDrain once because\n  // dest will only emit one 'drain' event for the multiple writes.\n  // => Introduce a guard on increasing awaitDrain.\n  var increasedAwaitDrain = false;\n  src.on('data', ondata);\n  function ondata(chunk) {\n    debug('ondata');\n    increasedAwaitDrain = false;\n    var ret = dest.write(chunk);\n    if (false === ret && !increasedAwaitDrain) {\n      // If the user unpiped during `dest.write()`, it is possible\n      // to get stuck in a permanently paused state if that write\n      // also returned false.\n      // => Check whether `dest` is still a piping destination.\n      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {\n        debug('false write response, pause', src._readableState.awaitDrain);\n        src._readableState.awaitDrain++;\n        increasedAwaitDrain = true;\n      }\n      src.pause();\n    }\n  }\n\n  // if the dest has an error, then stop piping into it.\n  // however, don't suppress the throwing behavior for this.\n  function onerror(er) {\n    debug('onerror', er);\n    unpipe();\n    dest.removeListener('error', onerror);\n    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);\n  }\n\n  // Make sure our error handler is attached before userland ones.\n  prependListener(dest, 'error', onerror);\n\n  // Both close and finish should trigger unpipe, but only once.\n  function onclose() {\n    dest.removeListener('finish', onfinish);\n    unpipe();\n  }\n  dest.once('close', onclose);\n  function onfinish() {\n    debug('onfinish');\n    dest.removeListener('close', onclose);\n    unpipe();\n  }\n  dest.once('finish', onfinish);\n\n  function unpipe() {\n    debug('unpipe');\n    src.unpipe(dest);\n  }\n\n  // tell the dest that it's being piped to\n  dest.emit('pipe', src);\n\n  // start the flow if it hasn't been started already.\n  if (!state.flowing) {\n    debug('pipe resume');\n    src.resume();\n  }\n\n  return dest;\n};\n\nfunction pipeOnDrain(src) {\n  return function () {\n    var state = src._readableState;\n    debug('pipeOnDrain', state.awaitDrain);\n    if (state.awaitDrain) state.awaitDrain--;\n    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {\n      state.flowing = true;\n      flow(src);\n    }\n  };\n}\n\nReadable.prototype.unpipe = function (dest) {\n  var state = this._readableState;\n  var unpipeInfo = { hasUnpiped: false };\n\n  // if we're not piping anywhere, then do nothing.\n  if (state.pipesCount === 0) return this;\n\n  // just one destination.  most common case.\n  if (state.pipesCount === 1) {\n    // passed in one, but it's not the right one.\n    if (dest && dest !== state.pipes) return this;\n\n    if (!dest) dest = state.pipes;\n\n    // got a match.\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n    if (dest) dest.emit('unpipe', this, unpipeInfo);\n    return this;\n  }\n\n  // slow case. multiple pipe destinations.\n\n  if (!dest) {\n    // remove all.\n    var dests = state.pipes;\n    var len = state.pipesCount;\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n\n    for (var i = 0; i < len; i++) {\n      dests[i].emit('unpipe', this, unpipeInfo);\n    }return this;\n  }\n\n  // try to find the right one.\n  var index = indexOf(state.pipes, dest);\n  if (index === -1) return this;\n\n  state.pipes.splice(index, 1);\n  state.pipesCount -= 1;\n  if (state.pipesCount === 1) state.pipes = state.pipes[0];\n\n  dest.emit('unpipe', this, unpipeInfo);\n\n  return this;\n};\n\n// set up data events if they are asked for\n// Ensure readable listeners eventually get something\nReadable.prototype.on = function (ev, fn) {\n  var res = Stream.prototype.on.call(this, ev, fn);\n\n  if (ev === 'data') {\n    // Start flowing on next tick if stream isn't explicitly paused\n    if (this._readableState.flowing !== false) this.resume();\n  } else if (ev === 'readable') {\n    var state = this._readableState;\n    if (!state.endEmitted && !state.readableListening) {\n      state.readableListening = state.needReadable = true;\n      state.emittedReadable = false;\n      if (!state.reading) {\n        pna.nextTick(nReadingNextTick, this);\n      } else if (state.length) {\n        emitReadable(this);\n      }\n    }\n  }\n\n  return res;\n};\nReadable.prototype.addListener = Readable.prototype.on;\n\nfunction nReadingNextTick(self) {\n  debug('readable nexttick read 0');\n  self.read(0);\n}\n\n// pause() and resume() are remnants of the legacy readable stream API\n// If the user uses them, then switch into old mode.\nReadable.prototype.resume = function () {\n  var state = this._readableState;\n  if (!state.flowing) {\n    debug('resume');\n    state.flowing = true;\n    resume(this, state);\n  }\n  return this;\n};\n\nfunction resume(stream, state) {\n  if (!state.resumeScheduled) {\n    state.resumeScheduled = true;\n    pna.nextTick(resume_, stream, state);\n  }\n}\n\nfunction resume_(stream, state) {\n  if (!state.reading) {\n    debug('resume read 0');\n    stream.read(0);\n  }\n\n  state.resumeScheduled = false;\n  state.awaitDrain = 0;\n  stream.emit('resume');\n  flow(stream);\n  if (state.flowing && !state.reading) stream.read(0);\n}\n\nReadable.prototype.pause = function () {\n  debug('call pause flowing=%j', this._readableState.flowing);\n  if (false !== this._readableState.flowing) {\n    debug('pause');\n    this._readableState.flowing = false;\n    this.emit('pause');\n  }\n  return this;\n};\n\nfunction flow(stream) {\n  var state = stream._readableState;\n  debug('flow', state.flowing);\n  while (state.flowing && stream.read() !== null) {}\n}\n\n// wrap an old-style stream as the async data source.\n// This is *not* part of the readable stream interface.\n// It is an ugly unfortunate mess of history.\nReadable.prototype.wrap = function (stream) {\n  var _this = this;\n\n  var state = this._readableState;\n  var paused = false;\n\n  stream.on('end', function () {\n    debug('wrapped end');\n    if (state.decoder && !state.ended) {\n      var chunk = state.decoder.end();\n      if (chunk && chunk.length) _this.push(chunk);\n    }\n\n    _this.push(null);\n  });\n\n  stream.on('data', function (chunk) {\n    debug('wrapped data');\n    if (state.decoder) chunk = state.decoder.write(chunk);\n\n    // don't skip over falsy values in objectMode\n    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;\n\n    var ret = _this.push(chunk);\n    if (!ret) {\n      paused = true;\n      stream.pause();\n    }\n  });\n\n  // proxy all the other methods.\n  // important when wrapping filters and duplexes.\n  for (var i in stream) {\n    if (this[i] === undefined && typeof stream[i] === 'function') {\n      this[i] = function (method) {\n        return function () {\n          return stream[method].apply(stream, arguments);\n        };\n      }(i);\n    }\n  }\n\n  // proxy certain important events.\n  for (var n = 0; n < kProxyEvents.length; n++) {\n    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));\n  }\n\n  // when we try to consume some more bytes, simply unpause the\n  // underlying stream.\n  this._read = function (n) {\n    debug('wrapped _read', n);\n    if (paused) {\n      paused = false;\n      stream.resume();\n    }\n  };\n\n  return this;\n};\n\nObject.defineProperty(Readable.prototype, 'readableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function () {\n    return this._readableState.highWaterMark;\n  }\n});\n\n// exposed for testing purposes only.\nReadable._fromList = fromList;\n\n// Pluck off n bytes from an array of buffers.\n// Length is the combined lengths of all the buffers in the list.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction fromList(n, state) {\n  // nothing buffered\n  if (state.length === 0) return null;\n\n  var ret;\n  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {\n    // read it all, truncate the list\n    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);\n    state.buffer.clear();\n  } else {\n    // read part of list\n    ret = fromListPartial(n, state.buffer, state.decoder);\n  }\n\n  return ret;\n}\n\n// Extracts only enough buffered data to satisfy the amount requested.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction fromListPartial(n, list, hasStrings) {\n  var ret;\n  if (n < list.head.data.length) {\n    // slice is the same for buffers and strings\n    ret = list.head.data.slice(0, n);\n    list.head.data = list.head.data.slice(n);\n  } else if (n === list.head.data.length) {\n    // first chunk is a perfect match\n    ret = list.shift();\n  } else {\n    // result spans more than one buffer\n    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);\n  }\n  return ret;\n}\n\n// Copies a specified amount of characters from the list of buffered data\n// chunks.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction copyFromBufferString(n, list) {\n  var p = list.head;\n  var c = 1;\n  var ret = p.data;\n  n -= ret.length;\n  while (p = p.next) {\n    var str = p.data;\n    var nb = n > str.length ? str.length : n;\n    if (nb === str.length) ret += str;else ret += str.slice(0, n);\n    n -= nb;\n    if (n === 0) {\n      if (nb === str.length) {\n        ++c;\n        if (p.next) list.head = p.next;else list.head = list.tail = null;\n      } else {\n        list.head = p;\n        p.data = str.slice(nb);\n      }\n      break;\n    }\n    ++c;\n  }\n  list.length -= c;\n  return ret;\n}\n\n// Copies a specified amount of bytes from the list of buffered data chunks.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction copyFromBuffer(n, list) {\n  var ret = Buffer.allocUnsafe(n);\n  var p = list.head;\n  var c = 1;\n  p.data.copy(ret);\n  n -= p.data.length;\n  while (p = p.next) {\n    var buf = p.data;\n    var nb = n > buf.length ? buf.length : n;\n    buf.copy(ret, ret.length - n, 0, nb);\n    n -= nb;\n    if (n === 0) {\n      if (nb === buf.length) {\n        ++c;\n        if (p.next) list.head = p.next;else list.head = list.tail = null;\n      } else {\n        list.head = p;\n        p.data = buf.slice(nb);\n      }\n      break;\n    }\n    ++c;\n  }\n  list.length -= c;\n  return ret;\n}\n\nfunction endReadable(stream) {\n  var state = stream._readableState;\n\n  // If we get here before consuming all the bytes, then that is a\n  // bug in node.  Should never happen.\n  if (state.length > 0) throw new Error('\"endReadable()\" called on non-empty stream');\n\n  if (!state.endEmitted) {\n    state.ended = true;\n    pna.nextTick(endReadableNT, state, stream);\n  }\n}\n\nfunction endReadableNT(state, stream) {\n  // Check that we didn't get one last unshift.\n  if (!state.endEmitted && state.length === 0) {\n    state.endEmitted = true;\n    stream.readable = false;\n    stream.emit('end');\n  }\n}\n\nfunction indexOf(xs, x) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    if (xs[i] === x) return i;\n  }\n  return -1;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGhyb3VnaDIvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9yZWFkYWJsZS5qcy5qcyIsIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYjs7QUFFQSxVQUFVLG1CQUFPLENBQUMsMEVBQXNCO0FBQ3hDOztBQUVBOztBQUVBO0FBQ0EsY0FBYyxtQkFBTyxDQUFDLHNFQUFTO0FBQy9COztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFNBQVMsbUZBQThCOztBQUV2QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsbUJBQU8sQ0FBQyw4SEFBMkI7QUFDaEQ7O0FBRUE7O0FBRUEsYUFBYSw0R0FBNkI7QUFDMUMsb0JBQW9CLHFCQUFNO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLHlCQUF5QixtQkFBTyxDQUFDLDZEQUFjO0FBQy9DLGdCQUFnQixtQkFBTyxDQUFDLDZEQUFVO0FBQ2xDOztBQUVBO0FBQ0EsZ0JBQWdCLG1CQUFPLENBQUMsbUJBQU07QUFDOUI7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsbUJBQU8sQ0FBQyw4SEFBK0I7QUFDeEQsa0JBQWtCLG1CQUFPLENBQUMsd0hBQTRCO0FBQ3REOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUVBQXlFLDZFQUE2RTtBQUN0Sjs7QUFFQTtBQUNBLHFCQUFxQixtQkFBTyxDQUFDLG9HQUFrQjs7QUFFL0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlEQUFpRCwwRkFBMEY7O0FBRTNJO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsdUlBQXdDO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUJBQXFCLG1CQUFPLENBQUMsb0dBQWtCOztBQUUvQzs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0dBQWtHO0FBQ2xHLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSw0RkFBNEY7QUFDNUYsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsZ0RBQWdEOztBQUVoRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNDQUFzQyx1SUFBd0M7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBNEU7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RDtBQUM3RDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0NBQXNDOztBQUV0QztBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnRUFBZ0UsT0FBTyxvQkFBb0IsT0FBTzs7QUFFbEc7QUFDQSw0Q0FBNEM7O0FBRTVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQjs7QUFFckI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNEVBQTRFOztBQUU1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IseUJBQXlCO0FBQzNDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBLG1EQUFtRCxpRUFBaUU7QUFDcEg7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkMsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkMsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlDQUFpQyxPQUFPO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90aHJvdWdoMi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3JlYWRhYmxlLmpzPzRlOTEiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIHBuYSA9IHJlcXVpcmUoJ3Byb2Nlc3MtbmV4dGljay1hcmdzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxubW9kdWxlLmV4cG9ydHMgPSBSZWFkYWJsZTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnaXNhcnJheScpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgRHVwbGV4O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cblJlYWRhYmxlLlJlYWRhYmxlU3RhdGUgPSBSZWFkYWJsZVN0YXRlO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIEVFID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xuXG52YXIgRUVsaXN0ZW5lckNvdW50ID0gZnVuY3Rpb24gKGVtaXR0ZXIsIHR5cGUpIHtcbiAgcmV0dXJuIGVtaXR0ZXIubGlzdGVuZXJzKHR5cGUpLmxlbmd0aDtcbn07XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBTdHJlYW0gPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvc3RyZWFtJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyO1xudmFyIE91clVpbnQ4QXJyYXkgPSBnbG9iYWwuVWludDhBcnJheSB8fCBmdW5jdGlvbiAoKSB7fTtcbmZ1bmN0aW9uIF91aW50OEFycmF5VG9CdWZmZXIoY2h1bmspIHtcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKGNodW5rKTtcbn1cbmZ1bmN0aW9uIF9pc1VpbnQ4QXJyYXkob2JqKSB7XG4gIHJldHVybiBCdWZmZXIuaXNCdWZmZXIob2JqKSB8fCBvYmogaW5zdGFuY2VvZiBPdXJVaW50OEFycmF5O1xufVxuXG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gT2JqZWN0LmNyZWF0ZShyZXF1aXJlKCdjb3JlLXV0aWwtaXMnKSk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIGRlYnVnVXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcbnZhciBkZWJ1ZyA9IHZvaWQgMDtcbmlmIChkZWJ1Z1V0aWwgJiYgZGVidWdVdGlsLmRlYnVnbG9nKSB7XG4gIGRlYnVnID0gZGVidWdVdGlsLmRlYnVnbG9nKCdzdHJlYW0nKTtcbn0gZWxzZSB7XG4gIGRlYnVnID0gZnVuY3Rpb24gKCkge307XG59XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudmFyIEJ1ZmZlckxpc3QgPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvQnVmZmVyTGlzdCcpO1xudmFyIGRlc3Ryb3lJbXBsID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL2Rlc3Ryb3knKTtcbnZhciBTdHJpbmdEZWNvZGVyO1xuXG51dGlsLmluaGVyaXRzKFJlYWRhYmxlLCBTdHJlYW0pO1xuXG52YXIga1Byb3h5RXZlbnRzID0gWydlcnJvcicsICdjbG9zZScsICdkZXN0cm95JywgJ3BhdXNlJywgJ3Jlc3VtZSddO1xuXG5mdW5jdGlvbiBwcmVwZW5kTGlzdGVuZXIoZW1pdHRlciwgZXZlbnQsIGZuKSB7XG4gIC8vIFNhZGx5IHRoaXMgaXMgbm90IGNhY2hlYWJsZSBhcyBzb21lIGxpYnJhcmllcyBidW5kbGUgdGhlaXIgb3duXG4gIC8vIGV2ZW50IGVtaXR0ZXIgaW1wbGVtZW50YXRpb24gd2l0aCB0aGVtLlxuICBpZiAodHlwZW9mIGVtaXR0ZXIucHJlcGVuZExpc3RlbmVyID09PSAnZnVuY3Rpb24nKSByZXR1cm4gZW1pdHRlci5wcmVwZW5kTGlzdGVuZXIoZXZlbnQsIGZuKTtcblxuICAvLyBUaGlzIGlzIGEgaGFjayB0byBtYWtlIHN1cmUgdGhhdCBvdXIgZXJyb3IgaGFuZGxlciBpcyBhdHRhY2hlZCBiZWZvcmUgYW55XG4gIC8vIHVzZXJsYW5kIG9uZXMuICBORVZFUiBETyBUSElTLiBUaGlzIGlzIGhlcmUgb25seSBiZWNhdXNlIHRoaXMgY29kZSBuZWVkc1xuICAvLyB0byBjb250aW51ZSB0byB3b3JrIHdpdGggb2xkZXIgdmVyc2lvbnMgb2YgTm9kZS5qcyB0aGF0IGRvIG5vdCBpbmNsdWRlXG4gIC8vIHRoZSBwcmVwZW5kTGlzdGVuZXIoKSBtZXRob2QuIFRoZSBnb2FsIGlzIHRvIGV2ZW50dWFsbHkgcmVtb3ZlIHRoaXMgaGFjay5cbiAgaWYgKCFlbWl0dGVyLl9ldmVudHMgfHwgIWVtaXR0ZXIuX2V2ZW50c1tldmVudF0pIGVtaXR0ZXIub24oZXZlbnQsIGZuKTtlbHNlIGlmIChpc0FycmF5KGVtaXR0ZXIuX2V2ZW50c1tldmVudF0pKSBlbWl0dGVyLl9ldmVudHNbZXZlbnRdLnVuc2hpZnQoZm4pO2Vsc2UgZW1pdHRlci5fZXZlbnRzW2V2ZW50XSA9IFtmbiwgZW1pdHRlci5fZXZlbnRzW2V2ZW50XV07XG59XG5cbmZ1bmN0aW9uIFJlYWRhYmxlU3RhdGUob3B0aW9ucywgc3RyZWFtKSB7XG4gIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgLy8gRHVwbGV4IHN0cmVhbXMgYXJlIGJvdGggcmVhZGFibGUgYW5kIHdyaXRhYmxlLCBidXQgc2hhcmVcbiAgLy8gdGhlIHNhbWUgb3B0aW9ucyBvYmplY3QuXG4gIC8vIEhvd2V2ZXIsIHNvbWUgY2FzZXMgcmVxdWlyZSBzZXR0aW5nIG9wdGlvbnMgdG8gZGlmZmVyZW50XG4gIC8vIHZhbHVlcyBmb3IgdGhlIHJlYWRhYmxlIGFuZCB0aGUgd3JpdGFibGUgc2lkZXMgb2YgdGhlIGR1cGxleCBzdHJlYW0uXG4gIC8vIFRoZXNlIG9wdGlvbnMgY2FuIGJlIHByb3ZpZGVkIHNlcGFyYXRlbHkgYXMgcmVhZGFibGVYWFggYW5kIHdyaXRhYmxlWFhYLlxuICB2YXIgaXNEdXBsZXggPSBzdHJlYW0gaW5zdGFuY2VvZiBEdXBsZXg7XG5cbiAgLy8gb2JqZWN0IHN0cmVhbSBmbGFnLiBVc2VkIHRvIG1ha2UgcmVhZChuKSBpZ25vcmUgbiBhbmQgdG9cbiAgLy8gbWFrZSBhbGwgdGhlIGJ1ZmZlciBtZXJnaW5nIGFuZCBsZW5ndGggY2hlY2tzIGdvIGF3YXlcbiAgdGhpcy5vYmplY3RNb2RlID0gISFvcHRpb25zLm9iamVjdE1vZGU7XG5cbiAgaWYgKGlzRHVwbGV4KSB0aGlzLm9iamVjdE1vZGUgPSB0aGlzLm9iamVjdE1vZGUgfHwgISFvcHRpb25zLnJlYWRhYmxlT2JqZWN0TW9kZTtcblxuICAvLyB0aGUgcG9pbnQgYXQgd2hpY2ggaXQgc3RvcHMgY2FsbGluZyBfcmVhZCgpIHRvIGZpbGwgdGhlIGJ1ZmZlclxuICAvLyBOb3RlOiAwIGlzIGEgdmFsaWQgdmFsdWUsIG1lYW5zIFwiZG9uJ3QgY2FsbCBfcmVhZCBwcmVlbXB0aXZlbHkgZXZlclwiXG4gIHZhciBod20gPSBvcHRpb25zLmhpZ2hXYXRlck1hcms7XG4gIHZhciByZWFkYWJsZUh3bSA9IG9wdGlvbnMucmVhZGFibGVIaWdoV2F0ZXJNYXJrO1xuICB2YXIgZGVmYXVsdEh3bSA9IHRoaXMub2JqZWN0TW9kZSA/IDE2IDogMTYgKiAxMDI0O1xuXG4gIGlmIChod20gfHwgaHdtID09PSAwKSB0aGlzLmhpZ2hXYXRlck1hcmsgPSBod207ZWxzZSBpZiAoaXNEdXBsZXggJiYgKHJlYWRhYmxlSHdtIHx8IHJlYWRhYmxlSHdtID09PSAwKSkgdGhpcy5oaWdoV2F0ZXJNYXJrID0gcmVhZGFibGVId207ZWxzZSB0aGlzLmhpZ2hXYXRlck1hcmsgPSBkZWZhdWx0SHdtO1xuXG4gIC8vIGNhc3QgdG8gaW50cy5cbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gTWF0aC5mbG9vcih0aGlzLmhpZ2hXYXRlck1hcmspO1xuXG4gIC8vIEEgbGlua2VkIGxpc3QgaXMgdXNlZCB0byBzdG9yZSBkYXRhIGNodW5rcyBpbnN0ZWFkIG9mIGFuIGFycmF5IGJlY2F1c2UgdGhlXG4gIC8vIGxpbmtlZCBsaXN0IGNhbiByZW1vdmUgZWxlbWVudHMgZnJvbSB0aGUgYmVnaW5uaW5nIGZhc3RlciB0aGFuXG4gIC8vIGFycmF5LnNoaWZ0KClcbiAgdGhpcy5idWZmZXIgPSBuZXcgQnVmZmVyTGlzdCgpO1xuICB0aGlzLmxlbmd0aCA9IDA7XG4gIHRoaXMucGlwZXMgPSBudWxsO1xuICB0aGlzLnBpcGVzQ291bnQgPSAwO1xuICB0aGlzLmZsb3dpbmcgPSBudWxsO1xuICB0aGlzLmVuZGVkID0gZmFsc2U7XG4gIHRoaXMuZW5kRW1pdHRlZCA9IGZhbHNlO1xuICB0aGlzLnJlYWRpbmcgPSBmYWxzZTtcblxuICAvLyBhIGZsYWcgdG8gYmUgYWJsZSB0byB0ZWxsIGlmIHRoZSBldmVudCAncmVhZGFibGUnLydkYXRhJyBpcyBlbWl0dGVkXG4gIC8vIGltbWVkaWF0ZWx5LCBvciBvbiBhIGxhdGVyIHRpY2suICBXZSBzZXQgdGhpcyB0byB0cnVlIGF0IGZpcnN0LCBiZWNhdXNlXG4gIC8vIGFueSBhY3Rpb25zIHRoYXQgc2hvdWxkbid0IGhhcHBlbiB1bnRpbCBcImxhdGVyXCIgc2hvdWxkIGdlbmVyYWxseSBhbHNvXG4gIC8vIG5vdCBoYXBwZW4gYmVmb3JlIHRoZSBmaXJzdCByZWFkIGNhbGwuXG4gIHRoaXMuc3luYyA9IHRydWU7XG5cbiAgLy8gd2hlbmV2ZXIgd2UgcmV0dXJuIG51bGwsIHRoZW4gd2Ugc2V0IGEgZmxhZyB0byBzYXlcbiAgLy8gdGhhdCB3ZSdyZSBhd2FpdGluZyBhICdyZWFkYWJsZScgZXZlbnQgZW1pc3Npb24uXG4gIHRoaXMubmVlZFJlYWRhYmxlID0gZmFsc2U7XG4gIHRoaXMuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XG4gIHRoaXMucmVhZGFibGVMaXN0ZW5pbmcgPSBmYWxzZTtcbiAgdGhpcy5yZXN1bWVTY2hlZHVsZWQgPSBmYWxzZTtcblxuICAvLyBoYXMgaXQgYmVlbiBkZXN0cm95ZWRcbiAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcblxuICAvLyBDcnlwdG8gaXMga2luZCBvZiBvbGQgYW5kIGNydXN0eS4gIEhpc3RvcmljYWxseSwgaXRzIGRlZmF1bHQgc3RyaW5nXG4gIC8vIGVuY29kaW5nIGlzICdiaW5hcnknIHNvIHdlIGhhdmUgdG8gbWFrZSB0aGlzIGNvbmZpZ3VyYWJsZS5cbiAgLy8gRXZlcnl0aGluZyBlbHNlIGluIHRoZSB1bml2ZXJzZSB1c2VzICd1dGY4JywgdGhvdWdoLlxuICB0aGlzLmRlZmF1bHRFbmNvZGluZyA9IG9wdGlvbnMuZGVmYXVsdEVuY29kaW5nIHx8ICd1dGY4JztcblxuICAvLyB0aGUgbnVtYmVyIG9mIHdyaXRlcnMgdGhhdCBhcmUgYXdhaXRpbmcgYSBkcmFpbiBldmVudCBpbiAucGlwZSgpc1xuICB0aGlzLmF3YWl0RHJhaW4gPSAwO1xuXG4gIC8vIGlmIHRydWUsIGEgbWF5YmVSZWFkTW9yZSBoYXMgYmVlbiBzY2hlZHVsZWRcbiAgdGhpcy5yZWFkaW5nTW9yZSA9IGZhbHNlO1xuXG4gIHRoaXMuZGVjb2RlciA9IG51bGw7XG4gIHRoaXMuZW5jb2RpbmcgPSBudWxsO1xuICBpZiAob3B0aW9ucy5lbmNvZGluZykge1xuICAgIGlmICghU3RyaW5nRGVjb2RlcikgU3RyaW5nRGVjb2RlciA9IHJlcXVpcmUoJ3N0cmluZ19kZWNvZGVyLycpLlN0cmluZ0RlY29kZXI7XG4gICAgdGhpcy5kZWNvZGVyID0gbmV3IFN0cmluZ0RlY29kZXIob3B0aW9ucy5lbmNvZGluZyk7XG4gICAgdGhpcy5lbmNvZGluZyA9IG9wdGlvbnMuZW5jb2Rpbmc7XG4gIH1cbn1cblxuZnVuY3Rpb24gUmVhZGFibGUob3B0aW9ucykge1xuICBEdXBsZXggPSBEdXBsZXggfHwgcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBSZWFkYWJsZSkpIHJldHVybiBuZXcgUmVhZGFibGUob3B0aW9ucyk7XG5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZSA9IG5ldyBSZWFkYWJsZVN0YXRlKG9wdGlvbnMsIHRoaXMpO1xuXG4gIC8vIGxlZ2FjeVxuICB0aGlzLnJlYWRhYmxlID0gdHJ1ZTtcblxuICBpZiAob3B0aW9ucykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5yZWFkID09PSAnZnVuY3Rpb24nKSB0aGlzLl9yZWFkID0gb3B0aW9ucy5yZWFkO1xuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmRlc3Ryb3kgPT09ICdmdW5jdGlvbicpIHRoaXMuX2Rlc3Ryb3kgPSBvcHRpb25zLmRlc3Ryb3k7XG4gIH1cblxuICBTdHJlYW0uY2FsbCh0aGlzKTtcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlYWRhYmxlLnByb3RvdHlwZSwgJ2Rlc3Ryb3llZCcsIHtcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQ7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgLy8gd2UgaWdub3JlIHRoZSB2YWx1ZSBpZiB0aGUgc3RyZWFtXG4gICAgLy8gaGFzIG5vdCBiZWVuIGluaXRpYWxpemVkIHlldFxuICAgIGlmICghdGhpcy5fcmVhZGFibGVTdGF0ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHRoZSB1c2VyIGlzIGV4cGxpY2l0bHlcbiAgICAvLyBtYW5hZ2luZyBkZXN0cm95ZWRcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCA9IHZhbHVlO1xuICB9XG59KTtcblxuUmVhZGFibGUucHJvdG90eXBlLmRlc3Ryb3kgPSBkZXN0cm95SW1wbC5kZXN0cm95O1xuUmVhZGFibGUucHJvdG90eXBlLl91bmRlc3Ryb3kgPSBkZXN0cm95SW1wbC51bmRlc3Ryb3k7XG5SZWFkYWJsZS5wcm90b3R5cGUuX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyLCBjYikge1xuICB0aGlzLnB1c2gobnVsbCk7XG4gIGNiKGVycik7XG59O1xuXG4vLyBNYW51YWxseSBzaG92ZSBzb21ldGhpbmcgaW50byB0aGUgcmVhZCgpIGJ1ZmZlci5cbi8vIFRoaXMgcmV0dXJucyB0cnVlIGlmIHRoZSBoaWdoV2F0ZXJNYXJrIGhhcyBub3QgYmVlbiBoaXQgeWV0LFxuLy8gc2ltaWxhciB0byBob3cgV3JpdGFibGUud3JpdGUoKSByZXR1cm5zIHRydWUgaWYgeW91IHNob3VsZFxuLy8gd3JpdGUoKSBzb21lIG1vcmUuXG5SZWFkYWJsZS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIHNraXBDaHVua0NoZWNrO1xuXG4gIGlmICghc3RhdGUub2JqZWN0TW9kZSkge1xuICAgIGlmICh0eXBlb2YgY2h1bmsgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IGVuY29kaW5nIHx8IHN0YXRlLmRlZmF1bHRFbmNvZGluZztcbiAgICAgIGlmIChlbmNvZGluZyAhPT0gc3RhdGUuZW5jb2RpbmcpIHtcbiAgICAgICAgY2h1bmsgPSBCdWZmZXIuZnJvbShjaHVuaywgZW5jb2RpbmcpO1xuICAgICAgICBlbmNvZGluZyA9ICcnO1xuICAgICAgfVxuICAgICAgc2tpcENodW5rQ2hlY2sgPSB0cnVlO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBza2lwQ2h1bmtDaGVjayA9IHRydWU7XG4gIH1cblxuICByZXR1cm4gcmVhZGFibGVBZGRDaHVuayh0aGlzLCBjaHVuaywgZW5jb2RpbmcsIGZhbHNlLCBza2lwQ2h1bmtDaGVjayk7XG59O1xuXG4vLyBVbnNoaWZ0IHNob3VsZCAqYWx3YXlzKiBiZSBzb21ldGhpbmcgZGlyZWN0bHkgb3V0IG9mIHJlYWQoKVxuUmVhZGFibGUucHJvdG90eXBlLnVuc2hpZnQgPSBmdW5jdGlvbiAoY2h1bmspIHtcbiAgcmV0dXJuIHJlYWRhYmxlQWRkQ2h1bmsodGhpcywgY2h1bmssIG51bGwsIHRydWUsIGZhbHNlKTtcbn07XG5cbmZ1bmN0aW9uIHJlYWRhYmxlQWRkQ2h1bmsoc3RyZWFtLCBjaHVuaywgZW5jb2RpbmcsIGFkZFRvRnJvbnQsIHNraXBDaHVua0NoZWNrKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgaWYgKGNodW5rID09PSBudWxsKSB7XG4gICAgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICAgIG9uRW9mQ2h1bmsoc3RyZWFtLCBzdGF0ZSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGVyO1xuICAgIGlmICghc2tpcENodW5rQ2hlY2spIGVyID0gY2h1bmtJbnZhbGlkKHN0YXRlLCBjaHVuayk7XG4gICAgaWYgKGVyKSB7XG4gICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gICAgfSBlbHNlIGlmIChzdGF0ZS5vYmplY3RNb2RlIHx8IGNodW5rICYmIGNodW5rLmxlbmd0aCA+IDApIHtcbiAgICAgIGlmICh0eXBlb2YgY2h1bmsgIT09ICdzdHJpbmcnICYmICFzdGF0ZS5vYmplY3RNb2RlICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZihjaHVuaykgIT09IEJ1ZmZlci5wcm90b3R5cGUpIHtcbiAgICAgICAgY2h1bmsgPSBfdWludDhBcnJheVRvQnVmZmVyKGNodW5rKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGFkZFRvRnJvbnQpIHtcbiAgICAgICAgaWYgKHN0YXRlLmVuZEVtaXR0ZWQpIHN0cmVhbS5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignc3RyZWFtLnVuc2hpZnQoKSBhZnRlciBlbmQgZXZlbnQnKSk7ZWxzZSBhZGRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgdHJ1ZSk7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlLmVuZGVkKSB7XG4gICAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignc3RyZWFtLnB1c2goKSBhZnRlciBFT0YnKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gICAgICAgIGlmIChzdGF0ZS5kZWNvZGVyICYmICFlbmNvZGluZykge1xuICAgICAgICAgIGNodW5rID0gc3RhdGUuZGVjb2Rlci53cml0ZShjaHVuayk7XG4gICAgICAgICAgaWYgKHN0YXRlLm9iamVjdE1vZGUgfHwgY2h1bmsubGVuZ3RoICE9PSAwKSBhZGRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgZmFsc2UpO2Vsc2UgbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhZGRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghYWRkVG9Gcm9udCkge1xuICAgICAgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZWVkTW9yZURhdGEoc3RhdGUpO1xufVxuXG5mdW5jdGlvbiBhZGRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgYWRkVG9Gcm9udCkge1xuICBpZiAoc3RhdGUuZmxvd2luZyAmJiBzdGF0ZS5sZW5ndGggPT09IDAgJiYgIXN0YXRlLnN5bmMpIHtcbiAgICBzdHJlYW0uZW1pdCgnZGF0YScsIGNodW5rKTtcbiAgICBzdHJlYW0ucmVhZCgwKTtcbiAgfSBlbHNlIHtcbiAgICAvLyB1cGRhdGUgdGhlIGJ1ZmZlciBpbmZvLlxuICAgIHN0YXRlLmxlbmd0aCArPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcbiAgICBpZiAoYWRkVG9Gcm9udCkgc3RhdGUuYnVmZmVyLnVuc2hpZnQoY2h1bmspO2Vsc2Ugc3RhdGUuYnVmZmVyLnB1c2goY2h1bmspO1xuXG4gICAgaWYgKHN0YXRlLm5lZWRSZWFkYWJsZSkgZW1pdFJlYWRhYmxlKHN0cmVhbSk7XG4gIH1cbiAgbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlKTtcbn1cblxuZnVuY3Rpb24gY2h1bmtJbnZhbGlkKHN0YXRlLCBjaHVuaykge1xuICB2YXIgZXI7XG4gIGlmICghX2lzVWludDhBcnJheShjaHVuaykgJiYgdHlwZW9mIGNodW5rICE9PSAnc3RyaW5nJyAmJiBjaHVuayAhPT0gdW5kZWZpbmVkICYmICFzdGF0ZS5vYmplY3RNb2RlKSB7XG4gICAgZXIgPSBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIG5vbi1zdHJpbmcvYnVmZmVyIGNodW5rJyk7XG4gIH1cbiAgcmV0dXJuIGVyO1xufVxuXG4vLyBpZiBpdCdzIHBhc3QgdGhlIGhpZ2ggd2F0ZXIgbWFyaywgd2UgY2FuIHB1c2ggaW4gc29tZSBtb3JlLlxuLy8gQWxzbywgaWYgd2UgaGF2ZSBubyBkYXRhIHlldCwgd2UgY2FuIHN0YW5kIHNvbWVcbi8vIG1vcmUgYnl0ZXMuICBUaGlzIGlzIHRvIHdvcmsgYXJvdW5kIGNhc2VzIHdoZXJlIGh3bT0wLFxuLy8gc3VjaCBhcyB0aGUgcmVwbC4gIEFsc28sIGlmIHRoZSBwdXNoKCkgdHJpZ2dlcmVkIGFcbi8vIHJlYWRhYmxlIGV2ZW50LCBhbmQgdGhlIHVzZXIgY2FsbGVkIHJlYWQobGFyZ2VOdW1iZXIpIHN1Y2ggdGhhdFxuLy8gbmVlZFJlYWRhYmxlIHdhcyBzZXQsIHRoZW4gd2Ugb3VnaHQgdG8gcHVzaCBtb3JlLCBzbyB0aGF0IGFub3RoZXJcbi8vICdyZWFkYWJsZScgZXZlbnQgd2lsbCBiZSB0cmlnZ2VyZWQuXG5mdW5jdGlvbiBuZWVkTW9yZURhdGEoc3RhdGUpIHtcbiAgcmV0dXJuICFzdGF0ZS5lbmRlZCAmJiAoc3RhdGUubmVlZFJlYWRhYmxlIHx8IHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcmsgfHwgc3RhdGUubGVuZ3RoID09PSAwKTtcbn1cblxuUmVhZGFibGUucHJvdG90eXBlLmlzUGF1c2VkID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nID09PSBmYWxzZTtcbn07XG5cbi8vIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxuUmVhZGFibGUucHJvdG90eXBlLnNldEVuY29kaW5nID0gZnVuY3Rpb24gKGVuYykge1xuICBpZiAoIVN0cmluZ0RlY29kZXIpIFN0cmluZ0RlY29kZXIgPSByZXF1aXJlKCdzdHJpbmdfZGVjb2Rlci8nKS5TdHJpbmdEZWNvZGVyO1xuICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlY29kZXIgPSBuZXcgU3RyaW5nRGVjb2RlcihlbmMpO1xuICB0aGlzLl9yZWFkYWJsZVN0YXRlLmVuY29kaW5nID0gZW5jO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIERvbid0IHJhaXNlIHRoZSBod20gPiA4TUJcbnZhciBNQVhfSFdNID0gMHg4MDAwMDA7XG5mdW5jdGlvbiBjb21wdXRlTmV3SGlnaFdhdGVyTWFyayhuKSB7XG4gIGlmIChuID49IE1BWF9IV00pIHtcbiAgICBuID0gTUFYX0hXTTtcbiAgfSBlbHNlIHtcbiAgICAvLyBHZXQgdGhlIG5leHQgaGlnaGVzdCBwb3dlciBvZiAyIHRvIHByZXZlbnQgaW5jcmVhc2luZyBod20gZXhjZXNzaXZlbHkgaW5cbiAgICAvLyB0aW55IGFtb3VudHNcbiAgICBuLS07XG4gICAgbiB8PSBuID4+PiAxO1xuICAgIG4gfD0gbiA+Pj4gMjtcbiAgICBuIHw9IG4gPj4+IDQ7XG4gICAgbiB8PSBuID4+PiA4O1xuICAgIG4gfD0gbiA+Pj4gMTY7XG4gICAgbisrO1xuICB9XG4gIHJldHVybiBuO1xufVxuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGhvd011Y2hUb1JlYWQobiwgc3RhdGUpIHtcbiAgaWYgKG4gPD0gMCB8fCBzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUuZW5kZWQpIHJldHVybiAwO1xuICBpZiAoc3RhdGUub2JqZWN0TW9kZSkgcmV0dXJuIDE7XG4gIGlmIChuICE9PSBuKSB7XG4gICAgLy8gT25seSBmbG93IG9uZSBidWZmZXIgYXQgYSB0aW1lXG4gICAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgc3RhdGUubGVuZ3RoKSByZXR1cm4gc3RhdGUuYnVmZmVyLmhlYWQuZGF0YS5sZW5ndGg7ZWxzZSByZXR1cm4gc3RhdGUubGVuZ3RoO1xuICB9XG4gIC8vIElmIHdlJ3JlIGFza2luZyBmb3IgbW9yZSB0aGFuIHRoZSBjdXJyZW50IGh3bSwgdGhlbiByYWlzZSB0aGUgaHdtLlxuICBpZiAobiA+IHN0YXRlLmhpZ2hXYXRlck1hcmspIHN0YXRlLmhpZ2hXYXRlck1hcmsgPSBjb21wdXRlTmV3SGlnaFdhdGVyTWFyayhuKTtcbiAgaWYgKG4gPD0gc3RhdGUubGVuZ3RoKSByZXR1cm4gbjtcbiAgLy8gRG9uJ3QgaGF2ZSBlbm91Z2hcbiAgaWYgKCFzdGF0ZS5lbmRlZCkge1xuICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgcmV0dXJuIHN0YXRlLmxlbmd0aDtcbn1cblxuLy8geW91IGNhbiBvdmVycmlkZSBlaXRoZXIgdGhpcyBtZXRob2QsIG9yIHRoZSBhc3luYyBfcmVhZChuKSBiZWxvdy5cblJlYWRhYmxlLnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24gKG4pIHtcbiAgZGVidWcoJ3JlYWQnLCBuKTtcbiAgbiA9IHBhcnNlSW50KG4sIDEwKTtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIG5PcmlnID0gbjtcblxuICBpZiAobiAhPT0gMCkgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XG5cbiAgLy8gaWYgd2UncmUgZG9pbmcgcmVhZCgwKSB0byB0cmlnZ2VyIGEgcmVhZGFibGUgZXZlbnQsIGJ1dCB3ZVxuICAvLyBhbHJlYWR5IGhhdmUgYSBidW5jaCBvZiBkYXRhIGluIHRoZSBidWZmZXIsIHRoZW4ganVzdCB0cmlnZ2VyXG4gIC8vIHRoZSAncmVhZGFibGUnIGV2ZW50IGFuZCBtb3ZlIG9uLlxuICBpZiAobiA9PT0gMCAmJiBzdGF0ZS5uZWVkUmVhZGFibGUgJiYgKHN0YXRlLmxlbmd0aCA+PSBzdGF0ZS5oaWdoV2F0ZXJNYXJrIHx8IHN0YXRlLmVuZGVkKSkge1xuICAgIGRlYnVnKCdyZWFkOiBlbWl0UmVhZGFibGUnLCBzdGF0ZS5sZW5ndGgsIHN0YXRlLmVuZGVkKTtcbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmVuZGVkKSBlbmRSZWFkYWJsZSh0aGlzKTtlbHNlIGVtaXRSZWFkYWJsZSh0aGlzKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIG4gPSBob3dNdWNoVG9SZWFkKG4sIHN0YXRlKTtcblxuICAvLyBpZiB3ZSd2ZSBlbmRlZCwgYW5kIHdlJ3JlIG5vdyBjbGVhciwgdGhlbiBmaW5pc2ggaXQgdXAuXG4gIGlmIChuID09PSAwICYmIHN0YXRlLmVuZGVkKSB7XG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgZW5kUmVhZGFibGUodGhpcyk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBBbGwgdGhlIGFjdHVhbCBjaHVuayBnZW5lcmF0aW9uIGxvZ2ljIG5lZWRzIHRvIGJlXG4gIC8vICpiZWxvdyogdGhlIGNhbGwgdG8gX3JlYWQuICBUaGUgcmVhc29uIGlzIHRoYXQgaW4gY2VydGFpblxuICAvLyBzeW50aGV0aWMgc3RyZWFtIGNhc2VzLCBzdWNoIGFzIHBhc3N0aHJvdWdoIHN0cmVhbXMsIF9yZWFkXG4gIC8vIG1heSBiZSBhIGNvbXBsZXRlbHkgc3luY2hyb25vdXMgb3BlcmF0aW9uIHdoaWNoIG1heSBjaGFuZ2VcbiAgLy8gdGhlIHN0YXRlIG9mIHRoZSByZWFkIGJ1ZmZlciwgcHJvdmlkaW5nIGVub3VnaCBkYXRhIHdoZW5cbiAgLy8gYmVmb3JlIHRoZXJlIHdhcyAqbm90KiBlbm91Z2guXG4gIC8vXG4gIC8vIFNvLCB0aGUgc3RlcHMgYXJlOlxuICAvLyAxLiBGaWd1cmUgb3V0IHdoYXQgdGhlIHN0YXRlIG9mIHRoaW5ncyB3aWxsIGJlIGFmdGVyIHdlIGRvXG4gIC8vIGEgcmVhZCBmcm9tIHRoZSBidWZmZXIuXG4gIC8vXG4gIC8vIDIuIElmIHRoYXQgcmVzdWx0aW5nIHN0YXRlIHdpbGwgdHJpZ2dlciBhIF9yZWFkLCB0aGVuIGNhbGwgX3JlYWQuXG4gIC8vIE5vdGUgdGhhdCB0aGlzIG1heSBiZSBhc3luY2hyb25vdXMsIG9yIHN5bmNocm9ub3VzLiAgWWVzLCBpdCBpc1xuICAvLyBkZWVwbHkgdWdseSB0byB3cml0ZSBBUElzIHRoaXMgd2F5LCBidXQgdGhhdCBzdGlsbCBkb2Vzbid0IG1lYW5cbiAgLy8gdGhhdCB0aGUgUmVhZGFibGUgY2xhc3Mgc2hvdWxkIGJlaGF2ZSBpbXByb3Blcmx5LCBhcyBzdHJlYW1zIGFyZVxuICAvLyBkZXNpZ25lZCB0byBiZSBzeW5jL2FzeW5jIGFnbm9zdGljLlxuICAvLyBUYWtlIG5vdGUgaWYgdGhlIF9yZWFkIGNhbGwgaXMgc3luYyBvciBhc3luYyAoaWUsIGlmIHRoZSByZWFkIGNhbGxcbiAgLy8gaGFzIHJldHVybmVkIHlldCksIHNvIHRoYXQgd2Uga25vdyB3aGV0aGVyIG9yIG5vdCBpdCdzIHNhZmUgdG8gZW1pdFxuICAvLyAncmVhZGFibGUnIGV0Yy5cbiAgLy9cbiAgLy8gMy4gQWN0dWFsbHkgcHVsbCB0aGUgcmVxdWVzdGVkIGNodW5rcyBvdXQgb2YgdGhlIGJ1ZmZlciBhbmQgcmV0dXJuLlxuXG4gIC8vIGlmIHdlIG5lZWQgYSByZWFkYWJsZSBldmVudCwgdGhlbiB3ZSBuZWVkIHRvIGRvIHNvbWUgcmVhZGluZy5cbiAgdmFyIGRvUmVhZCA9IHN0YXRlLm5lZWRSZWFkYWJsZTtcbiAgZGVidWcoJ25lZWQgcmVhZGFibGUnLCBkb1JlYWQpO1xuXG4gIC8vIGlmIHdlIGN1cnJlbnRseSBoYXZlIGxlc3MgdGhhbiB0aGUgaGlnaFdhdGVyTWFyaywgdGhlbiBhbHNvIHJlYWQgc29tZVxuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwIHx8IHN0YXRlLmxlbmd0aCAtIG4gPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrKSB7XG4gICAgZG9SZWFkID0gdHJ1ZTtcbiAgICBkZWJ1ZygnbGVuZ3RoIGxlc3MgdGhhbiB3YXRlcm1hcmsnLCBkb1JlYWQpO1xuICB9XG5cbiAgLy8gaG93ZXZlciwgaWYgd2UndmUgZW5kZWQsIHRoZW4gdGhlcmUncyBubyBwb2ludCwgYW5kIGlmIHdlJ3JlIGFscmVhZHlcbiAgLy8gcmVhZGluZywgdGhlbiBpdCdzIHVubmVjZXNzYXJ5LlxuICBpZiAoc3RhdGUuZW5kZWQgfHwgc3RhdGUucmVhZGluZykge1xuICAgIGRvUmVhZCA9IGZhbHNlO1xuICAgIGRlYnVnKCdyZWFkaW5nIG9yIGVuZGVkJywgZG9SZWFkKTtcbiAgfSBlbHNlIGlmIChkb1JlYWQpIHtcbiAgICBkZWJ1ZygnZG8gcmVhZCcpO1xuICAgIHN0YXRlLnJlYWRpbmcgPSB0cnVlO1xuICAgIHN0YXRlLnN5bmMgPSB0cnVlO1xuICAgIC8vIGlmIHRoZSBsZW5ndGggaXMgY3VycmVudGx5IHplcm8sIHRoZW4gd2UgKm5lZWQqIGEgcmVhZGFibGUgZXZlbnQuXG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICAvLyBjYWxsIGludGVybmFsIHJlYWQgbWV0aG9kXG4gICAgdGhpcy5fcmVhZChzdGF0ZS5oaWdoV2F0ZXJNYXJrKTtcbiAgICBzdGF0ZS5zeW5jID0gZmFsc2U7XG4gICAgLy8gSWYgX3JlYWQgcHVzaGVkIGRhdGEgc3luY2hyb25vdXNseSwgdGhlbiBgcmVhZGluZ2Agd2lsbCBiZSBmYWxzZSxcbiAgICAvLyBhbmQgd2UgbmVlZCB0byByZS1ldmFsdWF0ZSBob3cgbXVjaCBkYXRhIHdlIGNhbiByZXR1cm4gdG8gdGhlIHVzZXIuXG4gICAgaWYgKCFzdGF0ZS5yZWFkaW5nKSBuID0gaG93TXVjaFRvUmVhZChuT3JpZywgc3RhdGUpO1xuICB9XG5cbiAgdmFyIHJldDtcbiAgaWYgKG4gPiAwKSByZXQgPSBmcm9tTGlzdChuLCBzdGF0ZSk7ZWxzZSByZXQgPSBudWxsO1xuXG4gIGlmIChyZXQgPT09IG51bGwpIHtcbiAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgIG4gPSAwO1xuICB9IGVsc2Uge1xuICAgIHN0YXRlLmxlbmd0aCAtPSBuO1xuICB9XG5cbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkge1xuICAgIC8vIElmIHdlIGhhdmUgbm90aGluZyBpbiB0aGUgYnVmZmVyLCB0aGVuIHdlIHdhbnQgdG8ga25vd1xuICAgIC8vIGFzIHNvb24gYXMgd2UgKmRvKiBnZXQgc29tZXRoaW5nIGludG8gdGhlIGJ1ZmZlci5cbiAgICBpZiAoIXN0YXRlLmVuZGVkKSBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuXG4gICAgLy8gSWYgd2UgdHJpZWQgdG8gcmVhZCgpIHBhc3QgdGhlIEVPRiwgdGhlbiBlbWl0IGVuZCBvbiB0aGUgbmV4dCB0aWNrLlxuICAgIGlmIChuT3JpZyAhPT0gbiAmJiBzdGF0ZS5lbmRlZCkgZW5kUmVhZGFibGUodGhpcyk7XG4gIH1cblxuICBpZiAocmV0ICE9PSBudWxsKSB0aGlzLmVtaXQoJ2RhdGEnLCByZXQpO1xuXG4gIHJldHVybiByZXQ7XG59O1xuXG5mdW5jdGlvbiBvbkVvZkNodW5rKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKHN0YXRlLmVuZGVkKSByZXR1cm47XG4gIGlmIChzdGF0ZS5kZWNvZGVyKSB7XG4gICAgdmFyIGNodW5rID0gc3RhdGUuZGVjb2Rlci5lbmQoKTtcbiAgICBpZiAoY2h1bmsgJiYgY2h1bmsubGVuZ3RoKSB7XG4gICAgICBzdGF0ZS5idWZmZXIucHVzaChjaHVuayk7XG4gICAgICBzdGF0ZS5sZW5ndGggKz0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG4gICAgfVxuICB9XG4gIHN0YXRlLmVuZGVkID0gdHJ1ZTtcblxuICAvLyBlbWl0ICdyZWFkYWJsZScgbm93IHRvIG1ha2Ugc3VyZSBpdCBnZXRzIHBpY2tlZCB1cC5cbiAgZW1pdFJlYWRhYmxlKHN0cmVhbSk7XG59XG5cbi8vIERvbid0IGVtaXQgcmVhZGFibGUgcmlnaHQgYXdheSBpbiBzeW5jIG1vZGUsIGJlY2F1c2UgdGhpcyBjYW4gdHJpZ2dlclxuLy8gYW5vdGhlciByZWFkKCkgY2FsbCA9PiBzdGFjayBvdmVyZmxvdy4gIFRoaXMgd2F5LCBpdCBtaWdodCB0cmlnZ2VyXG4vLyBhIG5leHRUaWNrIHJlY3Vyc2lvbiB3YXJuaW5nLCBidXQgdGhhdCdzIG5vdCBzbyBiYWQuXG5mdW5jdGlvbiBlbWl0UmVhZGFibGUoc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgc3RhdGUubmVlZFJlYWRhYmxlID0gZmFsc2U7XG4gIGlmICghc3RhdGUuZW1pdHRlZFJlYWRhYmxlKSB7XG4gICAgZGVidWcoJ2VtaXRSZWFkYWJsZScsIHN0YXRlLmZsb3dpbmcpO1xuICAgIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgaWYgKHN0YXRlLnN5bmMpIHBuYS5uZXh0VGljayhlbWl0UmVhZGFibGVfLCBzdHJlYW0pO2Vsc2UgZW1pdFJlYWRhYmxlXyhzdHJlYW0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGVtaXRSZWFkYWJsZV8oc3RyZWFtKSB7XG4gIGRlYnVnKCdlbWl0IHJlYWRhYmxlJyk7XG4gIHN0cmVhbS5lbWl0KCdyZWFkYWJsZScpO1xuICBmbG93KHN0cmVhbSk7XG59XG5cbi8vIGF0IHRoaXMgcG9pbnQsIHRoZSB1c2VyIGhhcyBwcmVzdW1hYmx5IHNlZW4gdGhlICdyZWFkYWJsZScgZXZlbnQsXG4vLyBhbmQgY2FsbGVkIHJlYWQoKSB0byBjb25zdW1lIHNvbWUgZGF0YS4gIHRoYXQgbWF5IGhhdmUgdHJpZ2dlcmVkXG4vLyBpbiB0dXJuIGFub3RoZXIgX3JlYWQobikgY2FsbCwgaW4gd2hpY2ggY2FzZSByZWFkaW5nID0gdHJ1ZSBpZlxuLy8gaXQncyBpbiBwcm9ncmVzcy5cbi8vIEhvd2V2ZXIsIGlmIHdlJ3JlIG5vdCBlbmRlZCwgb3IgcmVhZGluZywgYW5kIHRoZSBsZW5ndGggPCBod20sXG4vLyB0aGVuIGdvIGFoZWFkIGFuZCB0cnkgdG8gcmVhZCBzb21lIG1vcmUgcHJlZW1wdGl2ZWx5LlxuZnVuY3Rpb24gbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucmVhZGluZ01vcmUpIHtcbiAgICBzdGF0ZS5yZWFkaW5nTW9yZSA9IHRydWU7XG4gICAgcG5hLm5leHRUaWNrKG1heWJlUmVhZE1vcmVfLCBzdHJlYW0sIHN0YXRlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXliZVJlYWRNb3JlXyhzdHJlYW0sIHN0YXRlKSB7XG4gIHZhciBsZW4gPSBzdGF0ZS5sZW5ndGg7XG4gIHdoaWxlICghc3RhdGUucmVhZGluZyAmJiAhc3RhdGUuZmxvd2luZyAmJiAhc3RhdGUuZW5kZWQgJiYgc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyaykge1xuICAgIGRlYnVnKCdtYXliZVJlYWRNb3JlIHJlYWQgMCcpO1xuICAgIHN0cmVhbS5yZWFkKDApO1xuICAgIGlmIChsZW4gPT09IHN0YXRlLmxlbmd0aClcbiAgICAgIC8vIGRpZG4ndCBnZXQgYW55IGRhdGEsIHN0b3Agc3Bpbm5pbmcuXG4gICAgICBicmVhaztlbHNlIGxlbiA9IHN0YXRlLmxlbmd0aDtcbiAgfVxuICBzdGF0ZS5yZWFkaW5nTW9yZSA9IGZhbHNlO1xufVxuXG4vLyBhYnN0cmFjdCBtZXRob2QuICB0byBiZSBvdmVycmlkZGVuIGluIHNwZWNpZmljIGltcGxlbWVudGF0aW9uIGNsYXNzZXMuXG4vLyBjYWxsIGNiKGVyLCBkYXRhKSB3aGVyZSBkYXRhIGlzIDw9IG4gaW4gbGVuZ3RoLlxuLy8gZm9yIHZpcnR1YWwgKG5vbi1zdHJpbmcsIG5vbi1idWZmZXIpIHN0cmVhbXMsIFwibGVuZ3RoXCIgaXMgc29tZXdoYXRcbi8vIGFyYml0cmFyeSwgYW5kIHBlcmhhcHMgbm90IHZlcnkgbWVhbmluZ2Z1bC5cblJlYWRhYmxlLnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ19yZWFkKCkgaXMgbm90IGltcGxlbWVudGVkJykpO1xufTtcblxuUmVhZGFibGUucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbiAoZGVzdCwgcGlwZU9wdHMpIHtcbiAgdmFyIHNyYyA9IHRoaXM7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG5cbiAgc3dpdGNoIChzdGF0ZS5waXBlc0NvdW50KSB7XG4gICAgY2FzZSAwOlxuICAgICAgc3RhdGUucGlwZXMgPSBkZXN0O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAxOlxuICAgICAgc3RhdGUucGlwZXMgPSBbc3RhdGUucGlwZXMsIGRlc3RdO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHN0YXRlLnBpcGVzLnB1c2goZGVzdCk7XG4gICAgICBicmVhaztcbiAgfVxuICBzdGF0ZS5waXBlc0NvdW50ICs9IDE7XG4gIGRlYnVnKCdwaXBlIGNvdW50PSVkIG9wdHM9JWonLCBzdGF0ZS5waXBlc0NvdW50LCBwaXBlT3B0cyk7XG5cbiAgdmFyIGRvRW5kID0gKCFwaXBlT3B0cyB8fCBwaXBlT3B0cy5lbmQgIT09IGZhbHNlKSAmJiBkZXN0ICE9PSBwcm9jZXNzLnN0ZG91dCAmJiBkZXN0ICE9PSBwcm9jZXNzLnN0ZGVycjtcblxuICB2YXIgZW5kRm4gPSBkb0VuZCA/IG9uZW5kIDogdW5waXBlO1xuICBpZiAoc3RhdGUuZW5kRW1pdHRlZCkgcG5hLm5leHRUaWNrKGVuZEZuKTtlbHNlIHNyYy5vbmNlKCdlbmQnLCBlbmRGbik7XG5cbiAgZGVzdC5vbigndW5waXBlJywgb251bnBpcGUpO1xuICBmdW5jdGlvbiBvbnVucGlwZShyZWFkYWJsZSwgdW5waXBlSW5mbykge1xuICAgIGRlYnVnKCdvbnVucGlwZScpO1xuICAgIGlmIChyZWFkYWJsZSA9PT0gc3JjKSB7XG4gICAgICBpZiAodW5waXBlSW5mbyAmJiB1bnBpcGVJbmZvLmhhc1VucGlwZWQgPT09IGZhbHNlKSB7XG4gICAgICAgIHVucGlwZUluZm8uaGFzVW5waXBlZCA9IHRydWU7XG4gICAgICAgIGNsZWFudXAoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBvbmVuZCgpIHtcbiAgICBkZWJ1Zygnb25lbmQnKTtcbiAgICBkZXN0LmVuZCgpO1xuICB9XG5cbiAgLy8gd2hlbiB0aGUgZGVzdCBkcmFpbnMsIGl0IHJlZHVjZXMgdGhlIGF3YWl0RHJhaW4gY291bnRlclxuICAvLyBvbiB0aGUgc291cmNlLiAgVGhpcyB3b3VsZCBiZSBtb3JlIGVsZWdhbnQgd2l0aCBhIC5vbmNlKClcbiAgLy8gaGFuZGxlciBpbiBmbG93KCksIGJ1dCBhZGRpbmcgYW5kIHJlbW92aW5nIHJlcGVhdGVkbHkgaXNcbiAgLy8gdG9vIHNsb3cuXG4gIHZhciBvbmRyYWluID0gcGlwZU9uRHJhaW4oc3JjKTtcbiAgZGVzdC5vbignZHJhaW4nLCBvbmRyYWluKTtcblxuICB2YXIgY2xlYW5lZFVwID0gZmFsc2U7XG4gIGZ1bmN0aW9uIGNsZWFudXAoKSB7XG4gICAgZGVidWcoJ2NsZWFudXAnKTtcbiAgICAvLyBjbGVhbnVwIGV2ZW50IGhhbmRsZXJzIG9uY2UgdGhlIHBpcGUgaXMgYnJva2VuXG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZHJhaW4nLCBvbmRyYWluKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ3VucGlwZScsIG9udW5waXBlKTtcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIG9uZW5kKTtcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIHVucGlwZSk7XG4gICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgb25kYXRhKTtcblxuICAgIGNsZWFuZWRVcCA9IHRydWU7XG5cbiAgICAvLyBpZiB0aGUgcmVhZGVyIGlzIHdhaXRpbmcgZm9yIGEgZHJhaW4gZXZlbnQgZnJvbSB0aGlzXG4gICAgLy8gc3BlY2lmaWMgd3JpdGVyLCB0aGVuIGl0IHdvdWxkIGNhdXNlIGl0IHRvIG5ldmVyIHN0YXJ0XG4gICAgLy8gZmxvd2luZyBhZ2Fpbi5cbiAgICAvLyBTbywgaWYgdGhpcyBpcyBhd2FpdGluZyBhIGRyYWluLCB0aGVuIHdlIGp1c3QgY2FsbCBpdCBub3cuXG4gICAgLy8gSWYgd2UgZG9uJ3Qga25vdywgdGhlbiBhc3N1bWUgdGhhdCB3ZSBhcmUgd2FpdGluZyBmb3Igb25lLlxuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluICYmICghZGVzdC5fd3JpdGFibGVTdGF0ZSB8fCBkZXN0Ll93cml0YWJsZVN0YXRlLm5lZWREcmFpbikpIG9uZHJhaW4oKTtcbiAgfVxuXG4gIC8vIElmIHRoZSB1c2VyIHB1c2hlcyBtb3JlIGRhdGEgd2hpbGUgd2UncmUgd3JpdGluZyB0byBkZXN0IHRoZW4gd2UnbGwgZW5kIHVwXG4gIC8vIGluIG9uZGF0YSBhZ2Fpbi4gSG93ZXZlciwgd2Ugb25seSB3YW50IHRvIGluY3JlYXNlIGF3YWl0RHJhaW4gb25jZSBiZWNhdXNlXG4gIC8vIGRlc3Qgd2lsbCBvbmx5IGVtaXQgb25lICdkcmFpbicgZXZlbnQgZm9yIHRoZSBtdWx0aXBsZSB3cml0ZXMuXG4gIC8vID0+IEludHJvZHVjZSBhIGd1YXJkIG9uIGluY3JlYXNpbmcgYXdhaXREcmFpbi5cbiAgdmFyIGluY3JlYXNlZEF3YWl0RHJhaW4gPSBmYWxzZTtcbiAgc3JjLm9uKCdkYXRhJywgb25kYXRhKTtcbiAgZnVuY3Rpb24gb25kYXRhKGNodW5rKSB7XG4gICAgZGVidWcoJ29uZGF0YScpO1xuICAgIGluY3JlYXNlZEF3YWl0RHJhaW4gPSBmYWxzZTtcbiAgICB2YXIgcmV0ID0gZGVzdC53cml0ZShjaHVuayk7XG4gICAgaWYgKGZhbHNlID09PSByZXQgJiYgIWluY3JlYXNlZEF3YWl0RHJhaW4pIHtcbiAgICAgIC8vIElmIHRoZSB1c2VyIHVucGlwZWQgZHVyaW5nIGBkZXN0LndyaXRlKClgLCBpdCBpcyBwb3NzaWJsZVxuICAgICAgLy8gdG8gZ2V0IHN0dWNrIGluIGEgcGVybWFuZW50bHkgcGF1c2VkIHN0YXRlIGlmIHRoYXQgd3JpdGVcbiAgICAgIC8vIGFsc28gcmV0dXJuZWQgZmFsc2UuXG4gICAgICAvLyA9PiBDaGVjayB3aGV0aGVyIGBkZXN0YCBpcyBzdGlsbCBhIHBpcGluZyBkZXN0aW5hdGlvbi5cbiAgICAgIGlmICgoc3RhdGUucGlwZXNDb3VudCA9PT0gMSAmJiBzdGF0ZS5waXBlcyA9PT0gZGVzdCB8fCBzdGF0ZS5waXBlc0NvdW50ID4gMSAmJiBpbmRleE9mKHN0YXRlLnBpcGVzLCBkZXN0KSAhPT0gLTEpICYmICFjbGVhbmVkVXApIHtcbiAgICAgICAgZGVidWcoJ2ZhbHNlIHdyaXRlIHJlc3BvbnNlLCBwYXVzZScsIHNyYy5fcmVhZGFibGVTdGF0ZS5hd2FpdERyYWluKTtcbiAgICAgICAgc3JjLl9yZWFkYWJsZVN0YXRlLmF3YWl0RHJhaW4rKztcbiAgICAgICAgaW5jcmVhc2VkQXdhaXREcmFpbiA9IHRydWU7XG4gICAgICB9XG4gICAgICBzcmMucGF1c2UoKTtcbiAgICB9XG4gIH1cblxuICAvLyBpZiB0aGUgZGVzdCBoYXMgYW4gZXJyb3IsIHRoZW4gc3RvcCBwaXBpbmcgaW50byBpdC5cbiAgLy8gaG93ZXZlciwgZG9uJ3Qgc3VwcHJlc3MgdGhlIHRocm93aW5nIGJlaGF2aW9yIGZvciB0aGlzLlxuICBmdW5jdGlvbiBvbmVycm9yKGVyKSB7XG4gICAgZGVidWcoJ29uZXJyb3InLCBlcik7XG4gICAgdW5waXBlKCk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcbiAgICBpZiAoRUVsaXN0ZW5lckNvdW50KGRlc3QsICdlcnJvcicpID09PSAwKSBkZXN0LmVtaXQoJ2Vycm9yJywgZXIpO1xuICB9XG5cbiAgLy8gTWFrZSBzdXJlIG91ciBlcnJvciBoYW5kbGVyIGlzIGF0dGFjaGVkIGJlZm9yZSB1c2VybGFuZCBvbmVzLlxuICBwcmVwZW5kTGlzdGVuZXIoZGVzdCwgJ2Vycm9yJywgb25lcnJvcik7XG5cbiAgLy8gQm90aCBjbG9zZSBhbmQgZmluaXNoIHNob3VsZCB0cmlnZ2VyIHVucGlwZSwgYnV0IG9ubHkgb25jZS5cbiAgZnVuY3Rpb24gb25jbG9zZSgpIHtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG4gICAgdW5waXBlKCk7XG4gIH1cbiAgZGVzdC5vbmNlKCdjbG9zZScsIG9uY2xvc2UpO1xuICBmdW5jdGlvbiBvbmZpbmlzaCgpIHtcbiAgICBkZWJ1Zygnb25maW5pc2gnKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuICAgIHVucGlwZSgpO1xuICB9XG4gIGRlc3Qub25jZSgnZmluaXNoJywgb25maW5pc2gpO1xuXG4gIGZ1bmN0aW9uIHVucGlwZSgpIHtcbiAgICBkZWJ1ZygndW5waXBlJyk7XG4gICAgc3JjLnVucGlwZShkZXN0KTtcbiAgfVxuXG4gIC8vIHRlbGwgdGhlIGRlc3QgdGhhdCBpdCdzIGJlaW5nIHBpcGVkIHRvXG4gIGRlc3QuZW1pdCgncGlwZScsIHNyYyk7XG5cbiAgLy8gc3RhcnQgdGhlIGZsb3cgaWYgaXQgaGFzbid0IGJlZW4gc3RhcnRlZCBhbHJlYWR5LlxuICBpZiAoIXN0YXRlLmZsb3dpbmcpIHtcbiAgICBkZWJ1ZygncGlwZSByZXN1bWUnKTtcbiAgICBzcmMucmVzdW1lKCk7XG4gIH1cblxuICByZXR1cm4gZGVzdDtcbn07XG5cbmZ1bmN0aW9uIHBpcGVPbkRyYWluKHNyYykge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzdGF0ZSA9IHNyYy5fcmVhZGFibGVTdGF0ZTtcbiAgICBkZWJ1ZygncGlwZU9uRHJhaW4nLCBzdGF0ZS5hd2FpdERyYWluKTtcbiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbikgc3RhdGUuYXdhaXREcmFpbi0tO1xuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluID09PSAwICYmIEVFbGlzdGVuZXJDb3VudChzcmMsICdkYXRhJykpIHtcbiAgICAgIHN0YXRlLmZsb3dpbmcgPSB0cnVlO1xuICAgICAgZmxvdyhzcmMpO1xuICAgIH1cbiAgfTtcbn1cblxuUmVhZGFibGUucHJvdG90eXBlLnVucGlwZSA9IGZ1bmN0aW9uIChkZXN0KSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHZhciB1bnBpcGVJbmZvID0geyBoYXNVbnBpcGVkOiBmYWxzZSB9O1xuXG4gIC8vIGlmIHdlJ3JlIG5vdCBwaXBpbmcgYW55d2hlcmUsIHRoZW4gZG8gbm90aGluZy5cbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDApIHJldHVybiB0aGlzO1xuXG4gIC8vIGp1c3Qgb25lIGRlc3RpbmF0aW9uLiAgbW9zdCBjb21tb24gY2FzZS5cbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDEpIHtcbiAgICAvLyBwYXNzZWQgaW4gb25lLCBidXQgaXQncyBub3QgdGhlIHJpZ2h0IG9uZS5cbiAgICBpZiAoZGVzdCAmJiBkZXN0ICE9PSBzdGF0ZS5waXBlcykgcmV0dXJuIHRoaXM7XG5cbiAgICBpZiAoIWRlc3QpIGRlc3QgPSBzdGF0ZS5waXBlcztcblxuICAgIC8vIGdvdCBhIG1hdGNoLlxuICAgIHN0YXRlLnBpcGVzID0gbnVsbDtcbiAgICBzdGF0ZS5waXBlc0NvdW50ID0gMDtcbiAgICBzdGF0ZS5mbG93aW5nID0gZmFsc2U7XG4gICAgaWYgKGRlc3QpIGRlc3QuZW1pdCgndW5waXBlJywgdGhpcywgdW5waXBlSW5mbyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBzbG93IGNhc2UuIG11bHRpcGxlIHBpcGUgZGVzdGluYXRpb25zLlxuXG4gIGlmICghZGVzdCkge1xuICAgIC8vIHJlbW92ZSBhbGwuXG4gICAgdmFyIGRlc3RzID0gc3RhdGUucGlwZXM7XG4gICAgdmFyIGxlbiA9IHN0YXRlLnBpcGVzQ291bnQ7XG4gICAgc3RhdGUucGlwZXMgPSBudWxsO1xuICAgIHN0YXRlLnBpcGVzQ291bnQgPSAwO1xuICAgIHN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGRlc3RzW2ldLmVtaXQoJ3VucGlwZScsIHRoaXMsIHVucGlwZUluZm8pO1xuICAgIH1yZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIHRyeSB0byBmaW5kIHRoZSByaWdodCBvbmUuXG4gIHZhciBpbmRleCA9IGluZGV4T2Yoc3RhdGUucGlwZXMsIGRlc3QpO1xuICBpZiAoaW5kZXggPT09IC0xKSByZXR1cm4gdGhpcztcblxuICBzdGF0ZS5waXBlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICBzdGF0ZS5waXBlc0NvdW50IC09IDE7XG4gIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAxKSBzdGF0ZS5waXBlcyA9IHN0YXRlLnBpcGVzWzBdO1xuXG4gIGRlc3QuZW1pdCgndW5waXBlJywgdGhpcywgdW5waXBlSW5mbyk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBzZXQgdXAgZGF0YSBldmVudHMgaWYgdGhleSBhcmUgYXNrZWQgZm9yXG4vLyBFbnN1cmUgcmVhZGFibGUgbGlzdGVuZXJzIGV2ZW50dWFsbHkgZ2V0IHNvbWV0aGluZ1xuUmVhZGFibGUucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gKGV2LCBmbikge1xuICB2YXIgcmVzID0gU3RyZWFtLnByb3RvdHlwZS5vbi5jYWxsKHRoaXMsIGV2LCBmbik7XG5cbiAgaWYgKGV2ID09PSAnZGF0YScpIHtcbiAgICAvLyBTdGFydCBmbG93aW5nIG9uIG5leHQgdGljayBpZiBzdHJlYW0gaXNuJ3QgZXhwbGljaXRseSBwYXVzZWRcbiAgICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nICE9PSBmYWxzZSkgdGhpcy5yZXN1bWUoKTtcbiAgfSBlbHNlIGlmIChldiA9PT0gJ3JlYWRhYmxlJykge1xuICAgIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gICAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkICYmICFzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZykge1xuICAgICAgc3RhdGUucmVhZGFibGVMaXN0ZW5pbmcgPSBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgICAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XG4gICAgICBpZiAoIXN0YXRlLnJlYWRpbmcpIHtcbiAgICAgICAgcG5hLm5leHRUaWNrKG5SZWFkaW5nTmV4dFRpY2ssIHRoaXMpO1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZS5sZW5ndGgpIHtcbiAgICAgICAgZW1pdFJlYWRhYmxlKHRoaXMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXM7XG59O1xuUmVhZGFibGUucHJvdG90eXBlLmFkZExpc3RlbmVyID0gUmVhZGFibGUucHJvdG90eXBlLm9uO1xuXG5mdW5jdGlvbiBuUmVhZGluZ05leHRUaWNrKHNlbGYpIHtcbiAgZGVidWcoJ3JlYWRhYmxlIG5leHR0aWNrIHJlYWQgMCcpO1xuICBzZWxmLnJlYWQoMCk7XG59XG5cbi8vIHBhdXNlKCkgYW5kIHJlc3VtZSgpIGFyZSByZW1uYW50cyBvZiB0aGUgbGVnYWN5IHJlYWRhYmxlIHN0cmVhbSBBUElcbi8vIElmIHRoZSB1c2VyIHVzZXMgdGhlbSwgdGhlbiBzd2l0Y2ggaW50byBvbGQgbW9kZS5cblJlYWRhYmxlLnByb3RvdHlwZS5yZXN1bWUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIGlmICghc3RhdGUuZmxvd2luZykge1xuICAgIGRlYnVnKCdyZXN1bWUnKTtcbiAgICBzdGF0ZS5mbG93aW5nID0gdHJ1ZTtcbiAgICByZXN1bWUodGhpcywgc3RhdGUpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gcmVzdW1lKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5yZXN1bWVTY2hlZHVsZWQpIHtcbiAgICBzdGF0ZS5yZXN1bWVTY2hlZHVsZWQgPSB0cnVlO1xuICAgIHBuYS5uZXh0VGljayhyZXN1bWVfLCBzdHJlYW0sIHN0YXRlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXN1bWVfKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5yZWFkaW5nKSB7XG4gICAgZGVidWcoJ3Jlc3VtZSByZWFkIDAnKTtcbiAgICBzdHJlYW0ucmVhZCgwKTtcbiAgfVxuXG4gIHN0YXRlLnJlc3VtZVNjaGVkdWxlZCA9IGZhbHNlO1xuICBzdGF0ZS5hd2FpdERyYWluID0gMDtcbiAgc3RyZWFtLmVtaXQoJ3Jlc3VtZScpO1xuICBmbG93KHN0cmVhbSk7XG4gIGlmIChzdGF0ZS5mbG93aW5nICYmICFzdGF0ZS5yZWFkaW5nKSBzdHJlYW0ucmVhZCgwKTtcbn1cblxuUmVhZGFibGUucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24gKCkge1xuICBkZWJ1ZygnY2FsbCBwYXVzZSBmbG93aW5nPSVqJywgdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nKTtcbiAgaWYgKGZhbHNlICE9PSB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcpIHtcbiAgICBkZWJ1ZygncGF1c2UnKTtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcbiAgICB0aGlzLmVtaXQoJ3BhdXNlJyk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiBmbG93KHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIGRlYnVnKCdmbG93Jywgc3RhdGUuZmxvd2luZyk7XG4gIHdoaWxlIChzdGF0ZS5mbG93aW5nICYmIHN0cmVhbS5yZWFkKCkgIT09IG51bGwpIHt9XG59XG5cbi8vIHdyYXAgYW4gb2xkLXN0eWxlIHN0cmVhbSBhcyB0aGUgYXN5bmMgZGF0YSBzb3VyY2UuXG4vLyBUaGlzIGlzICpub3QqIHBhcnQgb2YgdGhlIHJlYWRhYmxlIHN0cmVhbSBpbnRlcmZhY2UuXG4vLyBJdCBpcyBhbiB1Z2x5IHVuZm9ydHVuYXRlIG1lc3Mgb2YgaGlzdG9yeS5cblJlYWRhYmxlLnByb3RvdHlwZS53cmFwID0gZnVuY3Rpb24gKHN0cmVhbSkge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHZhciBwYXVzZWQgPSBmYWxzZTtcblxuICBzdHJlYW0ub24oJ2VuZCcsIGZ1bmN0aW9uICgpIHtcbiAgICBkZWJ1Zygnd3JhcHBlZCBlbmQnKTtcbiAgICBpZiAoc3RhdGUuZGVjb2RlciAmJiAhc3RhdGUuZW5kZWQpIHtcbiAgICAgIHZhciBjaHVuayA9IHN0YXRlLmRlY29kZXIuZW5kKCk7XG4gICAgICBpZiAoY2h1bmsgJiYgY2h1bmsubGVuZ3RoKSBfdGhpcy5wdXNoKGNodW5rKTtcbiAgICB9XG5cbiAgICBfdGhpcy5wdXNoKG51bGwpO1xuICB9KTtcblxuICBzdHJlYW0ub24oJ2RhdGEnLCBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICBkZWJ1Zygnd3JhcHBlZCBkYXRhJyk7XG4gICAgaWYgKHN0YXRlLmRlY29kZXIpIGNodW5rID0gc3RhdGUuZGVjb2Rlci53cml0ZShjaHVuayk7XG5cbiAgICAvLyBkb24ndCBza2lwIG92ZXIgZmFsc3kgdmFsdWVzIGluIG9iamVjdE1vZGVcbiAgICBpZiAoc3RhdGUub2JqZWN0TW9kZSAmJiAoY2h1bmsgPT09IG51bGwgfHwgY2h1bmsgPT09IHVuZGVmaW5lZCkpIHJldHVybjtlbHNlIGlmICghc3RhdGUub2JqZWN0TW9kZSAmJiAoIWNodW5rIHx8ICFjaHVuay5sZW5ndGgpKSByZXR1cm47XG5cbiAgICB2YXIgcmV0ID0gX3RoaXMucHVzaChjaHVuayk7XG4gICAgaWYgKCFyZXQpIHtcbiAgICAgIHBhdXNlZCA9IHRydWU7XG4gICAgICBzdHJlYW0ucGF1c2UoKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIHByb3h5IGFsbCB0aGUgb3RoZXIgbWV0aG9kcy5cbiAgLy8gaW1wb3J0YW50IHdoZW4gd3JhcHBpbmcgZmlsdGVycyBhbmQgZHVwbGV4ZXMuXG4gIGZvciAodmFyIGkgaW4gc3RyZWFtKSB7XG4gICAgaWYgKHRoaXNbaV0gPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygc3RyZWFtW2ldID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzW2ldID0gZnVuY3Rpb24gKG1ldGhvZCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBzdHJlYW1bbWV0aG9kXS5hcHBseShzdHJlYW0sIGFyZ3VtZW50cyk7XG4gICAgICAgIH07XG4gICAgICB9KGkpO1xuICAgIH1cbiAgfVxuXG4gIC8vIHByb3h5IGNlcnRhaW4gaW1wb3J0YW50IGV2ZW50cy5cbiAgZm9yICh2YXIgbiA9IDA7IG4gPCBrUHJveHlFdmVudHMubGVuZ3RoOyBuKyspIHtcbiAgICBzdHJlYW0ub24oa1Byb3h5RXZlbnRzW25dLCB0aGlzLmVtaXQuYmluZCh0aGlzLCBrUHJveHlFdmVudHNbbl0pKTtcbiAgfVxuXG4gIC8vIHdoZW4gd2UgdHJ5IHRvIGNvbnN1bWUgc29tZSBtb3JlIGJ5dGVzLCBzaW1wbHkgdW5wYXVzZSB0aGVcbiAgLy8gdW5kZXJseWluZyBzdHJlYW0uXG4gIHRoaXMuX3JlYWQgPSBmdW5jdGlvbiAobikge1xuICAgIGRlYnVnKCd3cmFwcGVkIF9yZWFkJywgbik7XG4gICAgaWYgKHBhdXNlZCkge1xuICAgICAgcGF1c2VkID0gZmFsc2U7XG4gICAgICBzdHJlYW0ucmVzdW1lKCk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlYWRhYmxlLnByb3RvdHlwZSwgJ3JlYWRhYmxlSGlnaFdhdGVyTWFyaycsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUuaGlnaFdhdGVyTWFyaztcbiAgfVxufSk7XG5cbi8vIGV4cG9zZWQgZm9yIHRlc3RpbmcgcHVycG9zZXMgb25seS5cblJlYWRhYmxlLl9mcm9tTGlzdCA9IGZyb21MaXN0O1xuXG4vLyBQbHVjayBvZmYgbiBieXRlcyBmcm9tIGFuIGFycmF5IG9mIGJ1ZmZlcnMuXG4vLyBMZW5ndGggaXMgdGhlIGNvbWJpbmVkIGxlbmd0aHMgb2YgYWxsIHRoZSBidWZmZXJzIGluIHRoZSBsaXN0LlxuLy8gVGhpcyBmdW5jdGlvbiBpcyBkZXNpZ25lZCB0byBiZSBpbmxpbmFibGUsIHNvIHBsZWFzZSB0YWtlIGNhcmUgd2hlbiBtYWtpbmdcbi8vIGNoYW5nZXMgdG8gdGhlIGZ1bmN0aW9uIGJvZHkuXG5mdW5jdGlvbiBmcm9tTGlzdChuLCBzdGF0ZSkge1xuICAvLyBub3RoaW5nIGJ1ZmZlcmVkXG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIHJldHVybiBudWxsO1xuXG4gIHZhciByZXQ7XG4gIGlmIChzdGF0ZS5vYmplY3RNb2RlKSByZXQgPSBzdGF0ZS5idWZmZXIuc2hpZnQoKTtlbHNlIGlmICghbiB8fCBuID49IHN0YXRlLmxlbmd0aCkge1xuICAgIC8vIHJlYWQgaXQgYWxsLCB0cnVuY2F0ZSB0aGUgbGlzdFxuICAgIGlmIChzdGF0ZS5kZWNvZGVyKSByZXQgPSBzdGF0ZS5idWZmZXIuam9pbignJyk7ZWxzZSBpZiAoc3RhdGUuYnVmZmVyLmxlbmd0aCA9PT0gMSkgcmV0ID0gc3RhdGUuYnVmZmVyLmhlYWQuZGF0YTtlbHNlIHJldCA9IHN0YXRlLmJ1ZmZlci5jb25jYXQoc3RhdGUubGVuZ3RoKTtcbiAgICBzdGF0ZS5idWZmZXIuY2xlYXIoKTtcbiAgfSBlbHNlIHtcbiAgICAvLyByZWFkIHBhcnQgb2YgbGlzdFxuICAgIHJldCA9IGZyb21MaXN0UGFydGlhbChuLCBzdGF0ZS5idWZmZXIsIHN0YXRlLmRlY29kZXIpO1xuICB9XG5cbiAgcmV0dXJuIHJldDtcbn1cblxuLy8gRXh0cmFjdHMgb25seSBlbm91Z2ggYnVmZmVyZWQgZGF0YSB0byBzYXRpc2Z5IHRoZSBhbW91bnQgcmVxdWVzdGVkLlxuLy8gVGhpcyBmdW5jdGlvbiBpcyBkZXNpZ25lZCB0byBiZSBpbmxpbmFibGUsIHNvIHBsZWFzZSB0YWtlIGNhcmUgd2hlbiBtYWtpbmdcbi8vIGNoYW5nZXMgdG8gdGhlIGZ1bmN0aW9uIGJvZHkuXG5mdW5jdGlvbiBmcm9tTGlzdFBhcnRpYWwobiwgbGlzdCwgaGFzU3RyaW5ncykge1xuICB2YXIgcmV0O1xuICBpZiAobiA8IGxpc3QuaGVhZC5kYXRhLmxlbmd0aCkge1xuICAgIC8vIHNsaWNlIGlzIHRoZSBzYW1lIGZvciBidWZmZXJzIGFuZCBzdHJpbmdzXG4gICAgcmV0ID0gbGlzdC5oZWFkLmRhdGEuc2xpY2UoMCwgbik7XG4gICAgbGlzdC5oZWFkLmRhdGEgPSBsaXN0LmhlYWQuZGF0YS5zbGljZShuKTtcbiAgfSBlbHNlIGlmIChuID09PSBsaXN0LmhlYWQuZGF0YS5sZW5ndGgpIHtcbiAgICAvLyBmaXJzdCBjaHVuayBpcyBhIHBlcmZlY3QgbWF0Y2hcbiAgICByZXQgPSBsaXN0LnNoaWZ0KCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gcmVzdWx0IHNwYW5zIG1vcmUgdGhhbiBvbmUgYnVmZmVyXG4gICAgcmV0ID0gaGFzU3RyaW5ncyA/IGNvcHlGcm9tQnVmZmVyU3RyaW5nKG4sIGxpc3QpIDogY29weUZyb21CdWZmZXIobiwgbGlzdCk7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuLy8gQ29waWVzIGEgc3BlY2lmaWVkIGFtb3VudCBvZiBjaGFyYWN0ZXJzIGZyb20gdGhlIGxpc3Qgb2YgYnVmZmVyZWQgZGF0YVxuLy8gY2h1bmtzLlxuLy8gVGhpcyBmdW5jdGlvbiBpcyBkZXNpZ25lZCB0byBiZSBpbmxpbmFibGUsIHNvIHBsZWFzZSB0YWtlIGNhcmUgd2hlbiBtYWtpbmdcbi8vIGNoYW5nZXMgdG8gdGhlIGZ1bmN0aW9uIGJvZHkuXG5mdW5jdGlvbiBjb3B5RnJvbUJ1ZmZlclN0cmluZyhuLCBsaXN0KSB7XG4gIHZhciBwID0gbGlzdC5oZWFkO1xuICB2YXIgYyA9IDE7XG4gIHZhciByZXQgPSBwLmRhdGE7XG4gIG4gLT0gcmV0Lmxlbmd0aDtcbiAgd2hpbGUgKHAgPSBwLm5leHQpIHtcbiAgICB2YXIgc3RyID0gcC5kYXRhO1xuICAgIHZhciBuYiA9IG4gPiBzdHIubGVuZ3RoID8gc3RyLmxlbmd0aCA6IG47XG4gICAgaWYgKG5iID09PSBzdHIubGVuZ3RoKSByZXQgKz0gc3RyO2Vsc2UgcmV0ICs9IHN0ci5zbGljZSgwLCBuKTtcbiAgICBuIC09IG5iO1xuICAgIGlmIChuID09PSAwKSB7XG4gICAgICBpZiAobmIgPT09IHN0ci5sZW5ndGgpIHtcbiAgICAgICAgKytjO1xuICAgICAgICBpZiAocC5uZXh0KSBsaXN0LmhlYWQgPSBwLm5leHQ7ZWxzZSBsaXN0LmhlYWQgPSBsaXN0LnRhaWwgPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGlzdC5oZWFkID0gcDtcbiAgICAgICAgcC5kYXRhID0gc3RyLnNsaWNlKG5iKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICArK2M7XG4gIH1cbiAgbGlzdC5sZW5ndGggLT0gYztcbiAgcmV0dXJuIHJldDtcbn1cblxuLy8gQ29waWVzIGEgc3BlY2lmaWVkIGFtb3VudCBvZiBieXRlcyBmcm9tIHRoZSBsaXN0IG9mIGJ1ZmZlcmVkIGRhdGEgY2h1bmtzLlxuLy8gVGhpcyBmdW5jdGlvbiBpcyBkZXNpZ25lZCB0byBiZSBpbmxpbmFibGUsIHNvIHBsZWFzZSB0YWtlIGNhcmUgd2hlbiBtYWtpbmdcbi8vIGNoYW5nZXMgdG8gdGhlIGZ1bmN0aW9uIGJvZHkuXG5mdW5jdGlvbiBjb3B5RnJvbUJ1ZmZlcihuLCBsaXN0KSB7XG4gIHZhciByZXQgPSBCdWZmZXIuYWxsb2NVbnNhZmUobik7XG4gIHZhciBwID0gbGlzdC5oZWFkO1xuICB2YXIgYyA9IDE7XG4gIHAuZGF0YS5jb3B5KHJldCk7XG4gIG4gLT0gcC5kYXRhLmxlbmd0aDtcbiAgd2hpbGUgKHAgPSBwLm5leHQpIHtcbiAgICB2YXIgYnVmID0gcC5kYXRhO1xuICAgIHZhciBuYiA9IG4gPiBidWYubGVuZ3RoID8gYnVmLmxlbmd0aCA6IG47XG4gICAgYnVmLmNvcHkocmV0LCByZXQubGVuZ3RoIC0gbiwgMCwgbmIpO1xuICAgIG4gLT0gbmI7XG4gICAgaWYgKG4gPT09IDApIHtcbiAgICAgIGlmIChuYiA9PT0gYnVmLmxlbmd0aCkge1xuICAgICAgICArK2M7XG4gICAgICAgIGlmIChwLm5leHQpIGxpc3QuaGVhZCA9IHAubmV4dDtlbHNlIGxpc3QuaGVhZCA9IGxpc3QudGFpbCA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsaXN0LmhlYWQgPSBwO1xuICAgICAgICBwLmRhdGEgPSBidWYuc2xpY2UobmIpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgICsrYztcbiAgfVxuICBsaXN0Lmxlbmd0aCAtPSBjO1xuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBlbmRSZWFkYWJsZShzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuXG4gIC8vIElmIHdlIGdldCBoZXJlIGJlZm9yZSBjb25zdW1pbmcgYWxsIHRoZSBieXRlcywgdGhlbiB0aGF0IGlzIGFcbiAgLy8gYnVnIGluIG5vZGUuICBTaG91bGQgbmV2ZXIgaGFwcGVuLlxuICBpZiAoc3RhdGUubGVuZ3RoID4gMCkgdGhyb3cgbmV3IEVycm9yKCdcImVuZFJlYWRhYmxlKClcIiBjYWxsZWQgb24gbm9uLWVtcHR5IHN0cmVhbScpO1xuXG4gIGlmICghc3RhdGUuZW5kRW1pdHRlZCkge1xuICAgIHN0YXRlLmVuZGVkID0gdHJ1ZTtcbiAgICBwbmEubmV4dFRpY2soZW5kUmVhZGFibGVOVCwgc3RhdGUsIHN0cmVhbSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZW5kUmVhZGFibGVOVChzdGF0ZSwgc3RyZWFtKSB7XG4gIC8vIENoZWNrIHRoYXQgd2UgZGlkbid0IGdldCBvbmUgbGFzdCB1bnNoaWZ0LlxuICBpZiAoIXN0YXRlLmVuZEVtaXR0ZWQgJiYgc3RhdGUubGVuZ3RoID09PSAwKSB7XG4gICAgc3RhdGUuZW5kRW1pdHRlZCA9IHRydWU7XG4gICAgc3RyZWFtLnJlYWRhYmxlID0gZmFsc2U7XG4gICAgc3RyZWFtLmVtaXQoJ2VuZCcpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluZGV4T2YoeHMsIHgpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB4cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBpZiAoeHNbaV0gPT09IHgpIHJldHVybiBpO1xuICB9XG4gIHJldHVybiAtMTtcbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/through2/node_modules/readable-stream/lib/_stream_readable.js\n");

/***/ }),

/***/ "./node_modules/through2/node_modules/readable-stream/lib/_stream_transform.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/through2/node_modules/readable-stream/lib/_stream_transform.js ***!
  \*************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a transform stream is a readable/writable stream where you do\n// something with the data.  Sometimes it's called a \"filter\",\n// but that's not a great name for it, since that implies a thing where\n// some bits pass through, and others are simply ignored.  (That would\n// be a valid example of a transform, of course.)\n//\n// While the output is causally related to the input, it's not a\n// necessarily symmetric or synchronous transformation.  For example,\n// a zlib stream might take multiple plain-text writes(), and then\n// emit a single compressed chunk some time in the future.\n//\n// Here's how this works:\n//\n// The Transform stream has all the aspects of the readable and writable\n// stream classes.  When you write(chunk), that calls _write(chunk,cb)\n// internally, and returns false if there's a lot of pending writes\n// buffered up.  When you call read(), that calls _read(n) until\n// there's enough pending readable data buffered up.\n//\n// In a transform stream, the written data is placed in a buffer.  When\n// _read(n) is called, it transforms the queued up data, calling the\n// buffered _write cb's as it consumes chunks.  If consuming a single\n// written chunk would result in multiple output chunks, then the first\n// outputted bit calls the readcb, and subsequent chunks just go into\n// the read buffer, and will cause it to emit 'readable' if necessary.\n//\n// This way, back-pressure is actually determined by the reading side,\n// since _read has to be called to start processing a new chunk.  However,\n// a pathological inflate type of transform can cause excessive buffering\n// here.  For example, imagine a stream where every byte of input is\n// interpreted as an integer from 0-255, and then results in that many\n// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in\n// 1kb of data being output.  In this case, you could write a very small\n// amount of input, and end up with a very large amount of output.  In\n// such a pathological inflating mechanism, there'd be no way to tell\n// the system to stop doing the transform.  A single 4MB write could\n// cause the system to run out of memory.\n//\n// However, even in such a pathological case, only a single written chunk\n// would be consumed, and then the rest would wait (un-transformed) until\n// the results of the previous transformed chunk were consumed.\n\n\n\nmodule.exports = Transform;\n\nvar Duplex = __webpack_require__(/*! ./_stream_duplex */ \"./node_modules/through2/node_modules/readable-stream/lib/_stream_duplex.js\");\n\n/*<replacement>*/\nvar util = Object.create(__webpack_require__(/*! core-util-is */ \"./node_modules/core-util-is/lib/util.js\"));\nutil.inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\");\n/*</replacement>*/\n\nutil.inherits(Transform, Duplex);\n\nfunction afterTransform(er, data) {\n  var ts = this._transformState;\n  ts.transforming = false;\n\n  var cb = ts.writecb;\n\n  if (!cb) {\n    return this.emit('error', new Error('write callback called multiple times'));\n  }\n\n  ts.writechunk = null;\n  ts.writecb = null;\n\n  if (data != null) // single equals check for both `null` and `undefined`\n    this.push(data);\n\n  cb(er);\n\n  var rs = this._readableState;\n  rs.reading = false;\n  if (rs.needReadable || rs.length < rs.highWaterMark) {\n    this._read(rs.highWaterMark);\n  }\n}\n\nfunction Transform(options) {\n  if (!(this instanceof Transform)) return new Transform(options);\n\n  Duplex.call(this, options);\n\n  this._transformState = {\n    afterTransform: afterTransform.bind(this),\n    needTransform: false,\n    transforming: false,\n    writecb: null,\n    writechunk: null,\n    writeencoding: null\n  };\n\n  // start out asking for a readable event once data is transformed.\n  this._readableState.needReadable = true;\n\n  // we have implemented the _read method, and done the other things\n  // that Readable wants before the first _read call, so unset the\n  // sync guard flag.\n  this._readableState.sync = false;\n\n  if (options) {\n    if (typeof options.transform === 'function') this._transform = options.transform;\n\n    if (typeof options.flush === 'function') this._flush = options.flush;\n  }\n\n  // When the writable side finishes, then flush out anything remaining.\n  this.on('prefinish', prefinish);\n}\n\nfunction prefinish() {\n  var _this = this;\n\n  if (typeof this._flush === 'function') {\n    this._flush(function (er, data) {\n      done(_this, er, data);\n    });\n  } else {\n    done(this, null, null);\n  }\n}\n\nTransform.prototype.push = function (chunk, encoding) {\n  this._transformState.needTransform = false;\n  return Duplex.prototype.push.call(this, chunk, encoding);\n};\n\n// This is the part where you do stuff!\n// override this function in implementation classes.\n// 'chunk' is an input chunk.\n//\n// Call `push(newChunk)` to pass along transformed output\n// to the readable side.  You may call 'push' zero or more times.\n//\n// Call `cb(err)` when you are done with this chunk.  If you pass\n// an error, then that'll put the hurt on the whole operation.  If you\n// never call cb(), then you'll never get another chunk.\nTransform.prototype._transform = function (chunk, encoding, cb) {\n  throw new Error('_transform() is not implemented');\n};\n\nTransform.prototype._write = function (chunk, encoding, cb) {\n  var ts = this._transformState;\n  ts.writecb = cb;\n  ts.writechunk = chunk;\n  ts.writeencoding = encoding;\n  if (!ts.transforming) {\n    var rs = this._readableState;\n    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);\n  }\n};\n\n// Doesn't matter what the args are here.\n// _transform does all the work.\n// That we got here means that the readable side wants more data.\nTransform.prototype._read = function (n) {\n  var ts = this._transformState;\n\n  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {\n    ts.transforming = true;\n    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);\n  } else {\n    // mark that we need a transform, so that any data that comes in\n    // will get processed, now that we've asked for it.\n    ts.needTransform = true;\n  }\n};\n\nTransform.prototype._destroy = function (err, cb) {\n  var _this2 = this;\n\n  Duplex.prototype._destroy.call(this, err, function (err2) {\n    cb(err2);\n    _this2.emit('close');\n  });\n};\n\nfunction done(stream, er, data) {\n  if (er) return stream.emit('error', er);\n\n  if (data != null) // single equals check for both `null` and `undefined`\n    stream.push(data);\n\n  // if there's nothing in the write buffer, then that means\n  // that nothing more will ever be provided\n  if (stream._writableState.length) throw new Error('Calling transform done when ws.length != 0');\n\n  if (stream._transformState.transforming) throw new Error('Calling transform done when still transforming');\n\n  return stream.push(null);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGhyb3VnaDIvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV90cmFuc2Zvcm0uanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxhQUFhO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYjs7QUFFQSxhQUFhLG1CQUFPLENBQUMsb0dBQWtCOztBQUV2QztBQUNBLHlCQUF5QixtQkFBTyxDQUFDLDZEQUFjO0FBQy9DLGdCQUFnQixtQkFBTyxDQUFDLDZEQUFVO0FBQ2xDOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3Rocm91Z2gyL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fdHJhbnNmb3JtLmpzPzQ5MmQiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIGEgdHJhbnNmb3JtIHN0cmVhbSBpcyBhIHJlYWRhYmxlL3dyaXRhYmxlIHN0cmVhbSB3aGVyZSB5b3UgZG9cbi8vIHNvbWV0aGluZyB3aXRoIHRoZSBkYXRhLiAgU29tZXRpbWVzIGl0J3MgY2FsbGVkIGEgXCJmaWx0ZXJcIixcbi8vIGJ1dCB0aGF0J3Mgbm90IGEgZ3JlYXQgbmFtZSBmb3IgaXQsIHNpbmNlIHRoYXQgaW1wbGllcyBhIHRoaW5nIHdoZXJlXG4vLyBzb21lIGJpdHMgcGFzcyB0aHJvdWdoLCBhbmQgb3RoZXJzIGFyZSBzaW1wbHkgaWdub3JlZC4gIChUaGF0IHdvdWxkXG4vLyBiZSBhIHZhbGlkIGV4YW1wbGUgb2YgYSB0cmFuc2Zvcm0sIG9mIGNvdXJzZS4pXG4vL1xuLy8gV2hpbGUgdGhlIG91dHB1dCBpcyBjYXVzYWxseSByZWxhdGVkIHRvIHRoZSBpbnB1dCwgaXQncyBub3QgYVxuLy8gbmVjZXNzYXJpbHkgc3ltbWV0cmljIG9yIHN5bmNocm9ub3VzIHRyYW5zZm9ybWF0aW9uLiAgRm9yIGV4YW1wbGUsXG4vLyBhIHpsaWIgc3RyZWFtIG1pZ2h0IHRha2UgbXVsdGlwbGUgcGxhaW4tdGV4dCB3cml0ZXMoKSwgYW5kIHRoZW5cbi8vIGVtaXQgYSBzaW5nbGUgY29tcHJlc3NlZCBjaHVuayBzb21lIHRpbWUgaW4gdGhlIGZ1dHVyZS5cbi8vXG4vLyBIZXJlJ3MgaG93IHRoaXMgd29ya3M6XG4vL1xuLy8gVGhlIFRyYW5zZm9ybSBzdHJlYW0gaGFzIGFsbCB0aGUgYXNwZWN0cyBvZiB0aGUgcmVhZGFibGUgYW5kIHdyaXRhYmxlXG4vLyBzdHJlYW0gY2xhc3Nlcy4gIFdoZW4geW91IHdyaXRlKGNodW5rKSwgdGhhdCBjYWxscyBfd3JpdGUoY2h1bmssY2IpXG4vLyBpbnRlcm5hbGx5LCBhbmQgcmV0dXJucyBmYWxzZSBpZiB0aGVyZSdzIGEgbG90IG9mIHBlbmRpbmcgd3JpdGVzXG4vLyBidWZmZXJlZCB1cC4gIFdoZW4geW91IGNhbGwgcmVhZCgpLCB0aGF0IGNhbGxzIF9yZWFkKG4pIHVudGlsXG4vLyB0aGVyZSdzIGVub3VnaCBwZW5kaW5nIHJlYWRhYmxlIGRhdGEgYnVmZmVyZWQgdXAuXG4vL1xuLy8gSW4gYSB0cmFuc2Zvcm0gc3RyZWFtLCB0aGUgd3JpdHRlbiBkYXRhIGlzIHBsYWNlZCBpbiBhIGJ1ZmZlci4gIFdoZW5cbi8vIF9yZWFkKG4pIGlzIGNhbGxlZCwgaXQgdHJhbnNmb3JtcyB0aGUgcXVldWVkIHVwIGRhdGEsIGNhbGxpbmcgdGhlXG4vLyBidWZmZXJlZCBfd3JpdGUgY2IncyBhcyBpdCBjb25zdW1lcyBjaHVua3MuICBJZiBjb25zdW1pbmcgYSBzaW5nbGVcbi8vIHdyaXR0ZW4gY2h1bmsgd291bGQgcmVzdWx0IGluIG11bHRpcGxlIG91dHB1dCBjaHVua3MsIHRoZW4gdGhlIGZpcnN0XG4vLyBvdXRwdXR0ZWQgYml0IGNhbGxzIHRoZSByZWFkY2IsIGFuZCBzdWJzZXF1ZW50IGNodW5rcyBqdXN0IGdvIGludG9cbi8vIHRoZSByZWFkIGJ1ZmZlciwgYW5kIHdpbGwgY2F1c2UgaXQgdG8gZW1pdCAncmVhZGFibGUnIGlmIG5lY2Vzc2FyeS5cbi8vXG4vLyBUaGlzIHdheSwgYmFjay1wcmVzc3VyZSBpcyBhY3R1YWxseSBkZXRlcm1pbmVkIGJ5IHRoZSByZWFkaW5nIHNpZGUsXG4vLyBzaW5jZSBfcmVhZCBoYXMgdG8gYmUgY2FsbGVkIHRvIHN0YXJ0IHByb2Nlc3NpbmcgYSBuZXcgY2h1bmsuICBIb3dldmVyLFxuLy8gYSBwYXRob2xvZ2ljYWwgaW5mbGF0ZSB0eXBlIG9mIHRyYW5zZm9ybSBjYW4gY2F1c2UgZXhjZXNzaXZlIGJ1ZmZlcmluZ1xuLy8gaGVyZS4gIEZvciBleGFtcGxlLCBpbWFnaW5lIGEgc3RyZWFtIHdoZXJlIGV2ZXJ5IGJ5dGUgb2YgaW5wdXQgaXNcbi8vIGludGVycHJldGVkIGFzIGFuIGludGVnZXIgZnJvbSAwLTI1NSwgYW5kIHRoZW4gcmVzdWx0cyBpbiB0aGF0IG1hbnlcbi8vIGJ5dGVzIG9mIG91dHB1dC4gIFdyaXRpbmcgdGhlIDQgYnl0ZXMge2ZmLGZmLGZmLGZmfSB3b3VsZCByZXN1bHQgaW5cbi8vIDFrYiBvZiBkYXRhIGJlaW5nIG91dHB1dC4gIEluIHRoaXMgY2FzZSwgeW91IGNvdWxkIHdyaXRlIGEgdmVyeSBzbWFsbFxuLy8gYW1vdW50IG9mIGlucHV0LCBhbmQgZW5kIHVwIHdpdGggYSB2ZXJ5IGxhcmdlIGFtb3VudCBvZiBvdXRwdXQuICBJblxuLy8gc3VjaCBhIHBhdGhvbG9naWNhbCBpbmZsYXRpbmcgbWVjaGFuaXNtLCB0aGVyZSdkIGJlIG5vIHdheSB0byB0ZWxsXG4vLyB0aGUgc3lzdGVtIHRvIHN0b3AgZG9pbmcgdGhlIHRyYW5zZm9ybS4gIEEgc2luZ2xlIDRNQiB3cml0ZSBjb3VsZFxuLy8gY2F1c2UgdGhlIHN5c3RlbSB0byBydW4gb3V0IG9mIG1lbW9yeS5cbi8vXG4vLyBIb3dldmVyLCBldmVuIGluIHN1Y2ggYSBwYXRob2xvZ2ljYWwgY2FzZSwgb25seSBhIHNpbmdsZSB3cml0dGVuIGNodW5rXG4vLyB3b3VsZCBiZSBjb25zdW1lZCwgYW5kIHRoZW4gdGhlIHJlc3Qgd291bGQgd2FpdCAodW4tdHJhbnNmb3JtZWQpIHVudGlsXG4vLyB0aGUgcmVzdWx0cyBvZiB0aGUgcHJldmlvdXMgdHJhbnNmb3JtZWQgY2h1bmsgd2VyZSBjb25zdW1lZC5cblxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRyYW5zZm9ybTtcblxudmFyIER1cGxleCA9IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gT2JqZWN0LmNyZWF0ZShyZXF1aXJlKCdjb3JlLXV0aWwtaXMnKSk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG51dGlsLmluaGVyaXRzKFRyYW5zZm9ybSwgRHVwbGV4KTtcblxuZnVuY3Rpb24gYWZ0ZXJUcmFuc2Zvcm0oZXIsIGRhdGEpIHtcbiAgdmFyIHRzID0gdGhpcy5fdHJhbnNmb3JtU3RhdGU7XG4gIHRzLnRyYW5zZm9ybWluZyA9IGZhbHNlO1xuXG4gIHZhciBjYiA9IHRzLndyaXRlY2I7XG5cbiAgaWYgKCFjYikge1xuICAgIHJldHVybiB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCd3cml0ZSBjYWxsYmFjayBjYWxsZWQgbXVsdGlwbGUgdGltZXMnKSk7XG4gIH1cblxuICB0cy53cml0ZWNodW5rID0gbnVsbDtcbiAgdHMud3JpdGVjYiA9IG51bGw7XG5cbiAgaWYgKGRhdGEgIT0gbnVsbCkgLy8gc2luZ2xlIGVxdWFscyBjaGVjayBmb3IgYm90aCBgbnVsbGAgYW5kIGB1bmRlZmluZWRgXG4gICAgdGhpcy5wdXNoKGRhdGEpO1xuXG4gIGNiKGVyKTtcblxuICB2YXIgcnMgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICBycy5yZWFkaW5nID0gZmFsc2U7XG4gIGlmIChycy5uZWVkUmVhZGFibGUgfHwgcnMubGVuZ3RoIDwgcnMuaGlnaFdhdGVyTWFyaykge1xuICAgIHRoaXMuX3JlYWQocnMuaGlnaFdhdGVyTWFyayk7XG4gIH1cbn1cblxuZnVuY3Rpb24gVHJhbnNmb3JtKG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFRyYW5zZm9ybSkpIHJldHVybiBuZXcgVHJhbnNmb3JtKG9wdGlvbnMpO1xuXG4gIER1cGxleC5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXG4gIHRoaXMuX3RyYW5zZm9ybVN0YXRlID0ge1xuICAgIGFmdGVyVHJhbnNmb3JtOiBhZnRlclRyYW5zZm9ybS5iaW5kKHRoaXMpLFxuICAgIG5lZWRUcmFuc2Zvcm06IGZhbHNlLFxuICAgIHRyYW5zZm9ybWluZzogZmFsc2UsXG4gICAgd3JpdGVjYjogbnVsbCxcbiAgICB3cml0ZWNodW5rOiBudWxsLFxuICAgIHdyaXRlZW5jb2Rpbmc6IG51bGxcbiAgfTtcblxuICAvLyBzdGFydCBvdXQgYXNraW5nIGZvciBhIHJlYWRhYmxlIGV2ZW50IG9uY2UgZGF0YSBpcyB0cmFuc2Zvcm1lZC5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuXG4gIC8vIHdlIGhhdmUgaW1wbGVtZW50ZWQgdGhlIF9yZWFkIG1ldGhvZCwgYW5kIGRvbmUgdGhlIG90aGVyIHRoaW5nc1xuICAvLyB0aGF0IFJlYWRhYmxlIHdhbnRzIGJlZm9yZSB0aGUgZmlyc3QgX3JlYWQgY2FsbCwgc28gdW5zZXQgdGhlXG4gIC8vIHN5bmMgZ3VhcmQgZmxhZy5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5zeW5jID0gZmFsc2U7XG5cbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMudHJhbnNmb3JtID09PSAnZnVuY3Rpb24nKSB0aGlzLl90cmFuc2Zvcm0gPSBvcHRpb25zLnRyYW5zZm9ybTtcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5mbHVzaCA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZmx1c2ggPSBvcHRpb25zLmZsdXNoO1xuICB9XG5cbiAgLy8gV2hlbiB0aGUgd3JpdGFibGUgc2lkZSBmaW5pc2hlcywgdGhlbiBmbHVzaCBvdXQgYW55dGhpbmcgcmVtYWluaW5nLlxuICB0aGlzLm9uKCdwcmVmaW5pc2gnLCBwcmVmaW5pc2gpO1xufVxuXG5mdW5jdGlvbiBwcmVmaW5pc2goKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgaWYgKHR5cGVvZiB0aGlzLl9mbHVzaCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRoaXMuX2ZsdXNoKGZ1bmN0aW9uIChlciwgZGF0YSkge1xuICAgICAgZG9uZShfdGhpcywgZXIsIGRhdGEpO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGRvbmUodGhpcywgbnVsbCwgbnVsbCk7XG4gIH1cbn1cblxuVHJhbnNmb3JtLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZykge1xuICB0aGlzLl90cmFuc2Zvcm1TdGF0ZS5uZWVkVHJhbnNmb3JtID0gZmFsc2U7XG4gIHJldHVybiBEdXBsZXgucHJvdG90eXBlLnB1c2guY2FsbCh0aGlzLCBjaHVuaywgZW5jb2RpbmcpO1xufTtcblxuLy8gVGhpcyBpcyB0aGUgcGFydCB3aGVyZSB5b3UgZG8gc3R1ZmYhXG4vLyBvdmVycmlkZSB0aGlzIGZ1bmN0aW9uIGluIGltcGxlbWVudGF0aW9uIGNsYXNzZXMuXG4vLyAnY2h1bmsnIGlzIGFuIGlucHV0IGNodW5rLlxuLy9cbi8vIENhbGwgYHB1c2gobmV3Q2h1bmspYCB0byBwYXNzIGFsb25nIHRyYW5zZm9ybWVkIG91dHB1dFxuLy8gdG8gdGhlIHJlYWRhYmxlIHNpZGUuICBZb3UgbWF5IGNhbGwgJ3B1c2gnIHplcm8gb3IgbW9yZSB0aW1lcy5cbi8vXG4vLyBDYWxsIGBjYihlcnIpYCB3aGVuIHlvdSBhcmUgZG9uZSB3aXRoIHRoaXMgY2h1bmsuICBJZiB5b3UgcGFzc1xuLy8gYW4gZXJyb3IsIHRoZW4gdGhhdCdsbCBwdXQgdGhlIGh1cnQgb24gdGhlIHdob2xlIG9wZXJhdGlvbi4gIElmIHlvdVxuLy8gbmV2ZXIgY2FsbCBjYigpLCB0aGVuIHlvdSdsbCBuZXZlciBnZXQgYW5vdGhlciBjaHVuay5cblRyYW5zZm9ybS5wcm90b3R5cGUuX3RyYW5zZm9ybSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHRocm93IG5ldyBFcnJvcignX3RyYW5zZm9ybSgpIGlzIG5vdCBpbXBsZW1lbnRlZCcpO1xufTtcblxuVHJhbnNmb3JtLnByb3RvdHlwZS5fd3JpdGUgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB2YXIgdHMgPSB0aGlzLl90cmFuc2Zvcm1TdGF0ZTtcbiAgdHMud3JpdGVjYiA9IGNiO1xuICB0cy53cml0ZWNodW5rID0gY2h1bms7XG4gIHRzLndyaXRlZW5jb2RpbmcgPSBlbmNvZGluZztcbiAgaWYgKCF0cy50cmFuc2Zvcm1pbmcpIHtcbiAgICB2YXIgcnMgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICAgIGlmICh0cy5uZWVkVHJhbnNmb3JtIHx8IHJzLm5lZWRSZWFkYWJsZSB8fCBycy5sZW5ndGggPCBycy5oaWdoV2F0ZXJNYXJrKSB0aGlzLl9yZWFkKHJzLmhpZ2hXYXRlck1hcmspO1xuICB9XG59O1xuXG4vLyBEb2Vzbid0IG1hdHRlciB3aGF0IHRoZSBhcmdzIGFyZSBoZXJlLlxuLy8gX3RyYW5zZm9ybSBkb2VzIGFsbCB0aGUgd29yay5cbi8vIFRoYXQgd2UgZ290IGhlcmUgbWVhbnMgdGhhdCB0aGUgcmVhZGFibGUgc2lkZSB3YW50cyBtb3JlIGRhdGEuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24gKG4pIHtcbiAgdmFyIHRzID0gdGhpcy5fdHJhbnNmb3JtU3RhdGU7XG5cbiAgaWYgKHRzLndyaXRlY2h1bmsgIT09IG51bGwgJiYgdHMud3JpdGVjYiAmJiAhdHMudHJhbnNmb3JtaW5nKSB7XG4gICAgdHMudHJhbnNmb3JtaW5nID0gdHJ1ZTtcbiAgICB0aGlzLl90cmFuc2Zvcm0odHMud3JpdGVjaHVuaywgdHMud3JpdGVlbmNvZGluZywgdHMuYWZ0ZXJUcmFuc2Zvcm0pO1xuICB9IGVsc2Uge1xuICAgIC8vIG1hcmsgdGhhdCB3ZSBuZWVkIGEgdHJhbnNmb3JtLCBzbyB0aGF0IGFueSBkYXRhIHRoYXQgY29tZXMgaW5cbiAgICAvLyB3aWxsIGdldCBwcm9jZXNzZWQsIG5vdyB0aGF0IHdlJ3ZlIGFza2VkIGZvciBpdC5cbiAgICB0cy5uZWVkVHJhbnNmb3JtID0gdHJ1ZTtcbiAgfVxufTtcblxuVHJhbnNmb3JtLnByb3RvdHlwZS5fZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIsIGNiKSB7XG4gIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gIER1cGxleC5wcm90b3R5cGUuX2Rlc3Ryb3kuY2FsbCh0aGlzLCBlcnIsIGZ1bmN0aW9uIChlcnIyKSB7XG4gICAgY2IoZXJyMik7XG4gICAgX3RoaXMyLmVtaXQoJ2Nsb3NlJyk7XG4gIH0pO1xufTtcblxuZnVuY3Rpb24gZG9uZShzdHJlYW0sIGVyLCBkYXRhKSB7XG4gIGlmIChlcikgcmV0dXJuIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcblxuICBpZiAoZGF0YSAhPSBudWxsKSAvLyBzaW5nbGUgZXF1YWxzIGNoZWNrIGZvciBib3RoIGBudWxsYCBhbmQgYHVuZGVmaW5lZGBcbiAgICBzdHJlYW0ucHVzaChkYXRhKTtcblxuICAvLyBpZiB0aGVyZSdzIG5vdGhpbmcgaW4gdGhlIHdyaXRlIGJ1ZmZlciwgdGhlbiB0aGF0IG1lYW5zXG4gIC8vIHRoYXQgbm90aGluZyBtb3JlIHdpbGwgZXZlciBiZSBwcm92aWRlZFxuICBpZiAoc3RyZWFtLl93cml0YWJsZVN0YXRlLmxlbmd0aCkgdGhyb3cgbmV3IEVycm9yKCdDYWxsaW5nIHRyYW5zZm9ybSBkb25lIHdoZW4gd3MubGVuZ3RoICE9IDAnKTtcblxuICBpZiAoc3RyZWFtLl90cmFuc2Zvcm1TdGF0ZS50cmFuc2Zvcm1pbmcpIHRocm93IG5ldyBFcnJvcignQ2FsbGluZyB0cmFuc2Zvcm0gZG9uZSB3aGVuIHN0aWxsIHRyYW5zZm9ybWluZycpO1xuXG4gIHJldHVybiBzdHJlYW0ucHVzaChudWxsKTtcbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/through2/node_modules/readable-stream/lib/_stream_transform.js\n");

/***/ }),

/***/ "./node_modules/through2/node_modules/readable-stream/lib/_stream_writable.js":
/*!************************************************************************************!*\
  !*** ./node_modules/through2/node_modules/readable-stream/lib/_stream_writable.js ***!
  \************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// A bit simpler than readable streams.\n// Implement an async ._write(chunk, encoding, cb), and it'll handle all\n// the drain event emission and buffering.\n\n\n\n/*<replacement>*/\n\nvar pna = __webpack_require__(/*! process-nextick-args */ \"./node_modules/process-nextick-args/index.js\");\n/*</replacement>*/\n\nmodule.exports = Writable;\n\n/* <replacement> */\nfunction WriteReq(chunk, encoding, cb) {\n  this.chunk = chunk;\n  this.encoding = encoding;\n  this.callback = cb;\n  this.next = null;\n}\n\n// It seems a linked list but it is not\n// there will be only 2 of these for each stream\nfunction CorkedRequest(state) {\n  var _this = this;\n\n  this.next = null;\n  this.entry = null;\n  this.finish = function () {\n    onCorkedFinish(_this, state);\n  };\n}\n/* </replacement> */\n\n/*<replacement>*/\nvar asyncWrite =  false ? 0 : pna.nextTick;\n/*</replacement>*/\n\n/*<replacement>*/\nvar Duplex;\n/*</replacement>*/\n\nWritable.WritableState = WritableState;\n\n/*<replacement>*/\nvar util = Object.create(__webpack_require__(/*! core-util-is */ \"./node_modules/core-util-is/lib/util.js\"));\nutil.inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\");\n/*</replacement>*/\n\n/*<replacement>*/\nvar internalUtil = {\n  deprecate: __webpack_require__(/*! util-deprecate */ \"./node_modules/util-deprecate/browser.js\")\n};\n/*</replacement>*/\n\n/*<replacement>*/\nvar Stream = __webpack_require__(/*! ./internal/streams/stream */ \"./node_modules/through2/node_modules/readable-stream/lib/internal/streams/stream-browser.js\");\n/*</replacement>*/\n\n/*<replacement>*/\n\nvar Buffer = (__webpack_require__(/*! safe-buffer */ \"./node_modules/through2/node_modules/safe-buffer/index.js\").Buffer);\nvar OurUint8Array = __webpack_require__.g.Uint8Array || function () {};\nfunction _uint8ArrayToBuffer(chunk) {\n  return Buffer.from(chunk);\n}\nfunction _isUint8Array(obj) {\n  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n}\n\n/*</replacement>*/\n\nvar destroyImpl = __webpack_require__(/*! ./internal/streams/destroy */ \"./node_modules/through2/node_modules/readable-stream/lib/internal/streams/destroy.js\");\n\nutil.inherits(Writable, Stream);\n\nfunction nop() {}\n\nfunction WritableState(options, stream) {\n  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ \"./node_modules/through2/node_modules/readable-stream/lib/_stream_duplex.js\");\n\n  options = options || {};\n\n  // Duplex streams are both readable and writable, but share\n  // the same options object.\n  // However, some cases require setting options to different\n  // values for the readable and the writable sides of the duplex stream.\n  // These options can be provided separately as readableXXX and writableXXX.\n  var isDuplex = stream instanceof Duplex;\n\n  // object stream flag to indicate whether or not this stream\n  // contains buffers or objects.\n  this.objectMode = !!options.objectMode;\n\n  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;\n\n  // the point at which write() starts returning false\n  // Note: 0 is a valid value, means that we always return false if\n  // the entire buffer is not flushed immediately on write()\n  var hwm = options.highWaterMark;\n  var writableHwm = options.writableHighWaterMark;\n  var defaultHwm = this.objectMode ? 16 : 16 * 1024;\n\n  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (writableHwm || writableHwm === 0)) this.highWaterMark = writableHwm;else this.highWaterMark = defaultHwm;\n\n  // cast to ints.\n  this.highWaterMark = Math.floor(this.highWaterMark);\n\n  // if _final has been called\n  this.finalCalled = false;\n\n  // drain event flag.\n  this.needDrain = false;\n  // at the start of calling end()\n  this.ending = false;\n  // when end() has been called, and returned\n  this.ended = false;\n  // when 'finish' is emitted\n  this.finished = false;\n\n  // has it been destroyed\n  this.destroyed = false;\n\n  // should we decode strings into buffers before passing to _write?\n  // this is here so that some node-core streams can optimize string\n  // handling at a lower level.\n  var noDecode = options.decodeStrings === false;\n  this.decodeStrings = !noDecode;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  // not an actual buffer we keep track of, but a measurement\n  // of how much we're waiting to get pushed to some underlying\n  // socket or file.\n  this.length = 0;\n\n  // a flag to see when we're in the middle of a write.\n  this.writing = false;\n\n  // when true all writes will be buffered until .uncork() call\n  this.corked = 0;\n\n  // a flag to be able to tell if the onwrite cb is called immediately,\n  // or on a later tick.  We set this to true at first, because any\n  // actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first write call.\n  this.sync = true;\n\n  // a flag to know if we're processing previously buffered items, which\n  // may call the _write() callback in the same tick, so that we don't\n  // end up in an overlapped onwrite situation.\n  this.bufferProcessing = false;\n\n  // the callback that's passed to _write(chunk,cb)\n  this.onwrite = function (er) {\n    onwrite(stream, er);\n  };\n\n  // the callback that the user supplies to write(chunk,encoding,cb)\n  this.writecb = null;\n\n  // the amount that is being written when _write is called.\n  this.writelen = 0;\n\n  this.bufferedRequest = null;\n  this.lastBufferedRequest = null;\n\n  // number of pending user-supplied write callbacks\n  // this must be 0 before 'finish' can be emitted\n  this.pendingcb = 0;\n\n  // emit prefinish if the only thing we're waiting for is _write cbs\n  // This is relevant for synchronous Transform streams\n  this.prefinished = false;\n\n  // True if the error was already emitted and should not be thrown again\n  this.errorEmitted = false;\n\n  // count buffered requests\n  this.bufferedRequestCount = 0;\n\n  // allocate the first CorkedRequest, there is always\n  // one allocated and free to use, and we maintain at most two\n  this.corkedRequestsFree = new CorkedRequest(this);\n}\n\nWritableState.prototype.getBuffer = function getBuffer() {\n  var current = this.bufferedRequest;\n  var out = [];\n  while (current) {\n    out.push(current);\n    current = current.next;\n  }\n  return out;\n};\n\n(function () {\n  try {\n    Object.defineProperty(WritableState.prototype, 'buffer', {\n      get: internalUtil.deprecate(function () {\n        return this.getBuffer();\n      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')\n    });\n  } catch (_) {}\n})();\n\n// Test _writableState for inheritance to account for Duplex streams,\n// whose prototype chain only points to Readable.\nvar realHasInstance;\nif (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {\n  realHasInstance = Function.prototype[Symbol.hasInstance];\n  Object.defineProperty(Writable, Symbol.hasInstance, {\n    value: function (object) {\n      if (realHasInstance.call(this, object)) return true;\n      if (this !== Writable) return false;\n\n      return object && object._writableState instanceof WritableState;\n    }\n  });\n} else {\n  realHasInstance = function (object) {\n    return object instanceof this;\n  };\n}\n\nfunction Writable(options) {\n  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ \"./node_modules/through2/node_modules/readable-stream/lib/_stream_duplex.js\");\n\n  // Writable ctor is applied to Duplexes, too.\n  // `realHasInstance` is necessary because using plain `instanceof`\n  // would return false, as no `_writableState` property is attached.\n\n  // Trying to use the custom `instanceof` for Writable here will also break the\n  // Node.js LazyTransform implementation, which has a non-trivial getter for\n  // `_writableState` that would lead to infinite recursion.\n  if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {\n    return new Writable(options);\n  }\n\n  this._writableState = new WritableState(options, this);\n\n  // legacy.\n  this.writable = true;\n\n  if (options) {\n    if (typeof options.write === 'function') this._write = options.write;\n\n    if (typeof options.writev === 'function') this._writev = options.writev;\n\n    if (typeof options.destroy === 'function') this._destroy = options.destroy;\n\n    if (typeof options.final === 'function') this._final = options.final;\n  }\n\n  Stream.call(this);\n}\n\n// Otherwise people can pipe Writable streams, which is just wrong.\nWritable.prototype.pipe = function () {\n  this.emit('error', new Error('Cannot pipe, not readable'));\n};\n\nfunction writeAfterEnd(stream, cb) {\n  var er = new Error('write after end');\n  // TODO: defer error events consistently everywhere, not just the cb\n  stream.emit('error', er);\n  pna.nextTick(cb, er);\n}\n\n// Checks that a user-supplied chunk is valid, especially for the particular\n// mode the stream is in. Currently this means that `null` is never accepted\n// and undefined/non-string values are only allowed in object mode.\nfunction validChunk(stream, state, chunk, cb) {\n  var valid = true;\n  var er = false;\n\n  if (chunk === null) {\n    er = new TypeError('May not write null values to stream');\n  } else if (typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {\n    er = new TypeError('Invalid non-string/buffer chunk');\n  }\n  if (er) {\n    stream.emit('error', er);\n    pna.nextTick(cb, er);\n    valid = false;\n  }\n  return valid;\n}\n\nWritable.prototype.write = function (chunk, encoding, cb) {\n  var state = this._writableState;\n  var ret = false;\n  var isBuf = !state.objectMode && _isUint8Array(chunk);\n\n  if (isBuf && !Buffer.isBuffer(chunk)) {\n    chunk = _uint8ArrayToBuffer(chunk);\n  }\n\n  if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;\n\n  if (typeof cb !== 'function') cb = nop;\n\n  if (state.ended) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {\n    state.pendingcb++;\n    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);\n  }\n\n  return ret;\n};\n\nWritable.prototype.cork = function () {\n  var state = this._writableState;\n\n  state.corked++;\n};\n\nWritable.prototype.uncork = function () {\n  var state = this._writableState;\n\n  if (state.corked) {\n    state.corked--;\n\n    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);\n  }\n};\n\nWritable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {\n  // node::ParseEncoding() requires lower case.\n  if (typeof encoding === 'string') encoding = encoding.toLowerCase();\n  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);\n  this._writableState.defaultEncoding = encoding;\n  return this;\n};\n\nfunction decodeChunk(state, chunk, encoding) {\n  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {\n    chunk = Buffer.from(chunk, encoding);\n  }\n  return chunk;\n}\n\nObject.defineProperty(Writable.prototype, 'writableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function () {\n    return this._writableState.highWaterMark;\n  }\n});\n\n// if we're already writing something, then just put this\n// in the queue, and wait our turn.  Otherwise, call _write\n// If we return false, then we need a drain event, so set that flag.\nfunction writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {\n  if (!isBuf) {\n    var newChunk = decodeChunk(state, chunk, encoding);\n    if (chunk !== newChunk) {\n      isBuf = true;\n      encoding = 'buffer';\n      chunk = newChunk;\n    }\n  }\n  var len = state.objectMode ? 1 : chunk.length;\n\n  state.length += len;\n\n  var ret = state.length < state.highWaterMark;\n  // we must ensure that previous needDrain will not be reset to false.\n  if (!ret) state.needDrain = true;\n\n  if (state.writing || state.corked) {\n    var last = state.lastBufferedRequest;\n    state.lastBufferedRequest = {\n      chunk: chunk,\n      encoding: encoding,\n      isBuf: isBuf,\n      callback: cb,\n      next: null\n    };\n    if (last) {\n      last.next = state.lastBufferedRequest;\n    } else {\n      state.bufferedRequest = state.lastBufferedRequest;\n    }\n    state.bufferedRequestCount += 1;\n  } else {\n    doWrite(stream, state, false, len, chunk, encoding, cb);\n  }\n\n  return ret;\n}\n\nfunction doWrite(stream, state, writev, len, chunk, encoding, cb) {\n  state.writelen = len;\n  state.writecb = cb;\n  state.writing = true;\n  state.sync = true;\n  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);\n  state.sync = false;\n}\n\nfunction onwriteError(stream, state, sync, er, cb) {\n  --state.pendingcb;\n\n  if (sync) {\n    // defer the callback if we are being called synchronously\n    // to avoid piling up things on the stack\n    pna.nextTick(cb, er);\n    // this can emit finish, and it will always happen\n    // after error\n    pna.nextTick(finishMaybe, stream, state);\n    stream._writableState.errorEmitted = true;\n    stream.emit('error', er);\n  } else {\n    // the caller expect this to happen before if\n    // it is async\n    cb(er);\n    stream._writableState.errorEmitted = true;\n    stream.emit('error', er);\n    // this can emit finish, but finish must\n    // always follow error\n    finishMaybe(stream, state);\n  }\n}\n\nfunction onwriteStateUpdate(state) {\n  state.writing = false;\n  state.writecb = null;\n  state.length -= state.writelen;\n  state.writelen = 0;\n}\n\nfunction onwrite(stream, er) {\n  var state = stream._writableState;\n  var sync = state.sync;\n  var cb = state.writecb;\n\n  onwriteStateUpdate(state);\n\n  if (er) onwriteError(stream, state, sync, er, cb);else {\n    // Check if we're actually ready to finish, but don't emit yet\n    var finished = needFinish(state);\n\n    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {\n      clearBuffer(stream, state);\n    }\n\n    if (sync) {\n      /*<replacement>*/\n      asyncWrite(afterWrite, stream, state, finished, cb);\n      /*</replacement>*/\n    } else {\n      afterWrite(stream, state, finished, cb);\n    }\n  }\n}\n\nfunction afterWrite(stream, state, finished, cb) {\n  if (!finished) onwriteDrain(stream, state);\n  state.pendingcb--;\n  cb();\n  finishMaybe(stream, state);\n}\n\n// Must force callback to be called on nextTick, so that we don't\n// emit 'drain' before the write() consumer gets the 'false' return\n// value, and has a chance to attach a 'drain' listener.\nfunction onwriteDrain(stream, state) {\n  if (state.length === 0 && state.needDrain) {\n    state.needDrain = false;\n    stream.emit('drain');\n  }\n}\n\n// if there's something in the buffer waiting, then process it\nfunction clearBuffer(stream, state) {\n  state.bufferProcessing = true;\n  var entry = state.bufferedRequest;\n\n  if (stream._writev && entry && entry.next) {\n    // Fast case, write everything using _writev()\n    var l = state.bufferedRequestCount;\n    var buffer = new Array(l);\n    var holder = state.corkedRequestsFree;\n    holder.entry = entry;\n\n    var count = 0;\n    var allBuffers = true;\n    while (entry) {\n      buffer[count] = entry;\n      if (!entry.isBuf) allBuffers = false;\n      entry = entry.next;\n      count += 1;\n    }\n    buffer.allBuffers = allBuffers;\n\n    doWrite(stream, state, true, state.length, buffer, '', holder.finish);\n\n    // doWrite is almost always async, defer these to save a bit of time\n    // as the hot path ends with doWrite\n    state.pendingcb++;\n    state.lastBufferedRequest = null;\n    if (holder.next) {\n      state.corkedRequestsFree = holder.next;\n      holder.next = null;\n    } else {\n      state.corkedRequestsFree = new CorkedRequest(state);\n    }\n    state.bufferedRequestCount = 0;\n  } else {\n    // Slow case, write chunks one-by-one\n    while (entry) {\n      var chunk = entry.chunk;\n      var encoding = entry.encoding;\n      var cb = entry.callback;\n      var len = state.objectMode ? 1 : chunk.length;\n\n      doWrite(stream, state, false, len, chunk, encoding, cb);\n      entry = entry.next;\n      state.bufferedRequestCount--;\n      // if we didn't call the onwrite immediately, then\n      // it means that we need to wait until it does.\n      // also, that means that the chunk and cb are currently\n      // being processed, so move the buffer counter past them.\n      if (state.writing) {\n        break;\n      }\n    }\n\n    if (entry === null) state.lastBufferedRequest = null;\n  }\n\n  state.bufferedRequest = entry;\n  state.bufferProcessing = false;\n}\n\nWritable.prototype._write = function (chunk, encoding, cb) {\n  cb(new Error('_write() is not implemented'));\n};\n\nWritable.prototype._writev = null;\n\nWritable.prototype.end = function (chunk, encoding, cb) {\n  var state = this._writableState;\n\n  if (typeof chunk === 'function') {\n    cb = chunk;\n    chunk = null;\n    encoding = null;\n  } else if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);\n\n  // .end() fully uncorks\n  if (state.corked) {\n    state.corked = 1;\n    this.uncork();\n  }\n\n  // ignore unnecessary end() calls.\n  if (!state.ending && !state.finished) endWritable(this, state, cb);\n};\n\nfunction needFinish(state) {\n  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;\n}\nfunction callFinal(stream, state) {\n  stream._final(function (err) {\n    state.pendingcb--;\n    if (err) {\n      stream.emit('error', err);\n    }\n    state.prefinished = true;\n    stream.emit('prefinish');\n    finishMaybe(stream, state);\n  });\n}\nfunction prefinish(stream, state) {\n  if (!state.prefinished && !state.finalCalled) {\n    if (typeof stream._final === 'function') {\n      state.pendingcb++;\n      state.finalCalled = true;\n      pna.nextTick(callFinal, stream, state);\n    } else {\n      state.prefinished = true;\n      stream.emit('prefinish');\n    }\n  }\n}\n\nfunction finishMaybe(stream, state) {\n  var need = needFinish(state);\n  if (need) {\n    prefinish(stream, state);\n    if (state.pendingcb === 0) {\n      state.finished = true;\n      stream.emit('finish');\n    }\n  }\n  return need;\n}\n\nfunction endWritable(stream, state, cb) {\n  state.ending = true;\n  finishMaybe(stream, state);\n  if (cb) {\n    if (state.finished) pna.nextTick(cb);else stream.once('finish', cb);\n  }\n  state.ended = true;\n  stream.writable = false;\n}\n\nfunction onCorkedFinish(corkReq, state, err) {\n  var entry = corkReq.entry;\n  corkReq.entry = null;\n  while (entry) {\n    var cb = entry.callback;\n    state.pendingcb--;\n    cb(err);\n    entry = entry.next;\n  }\n  if (state.corkedRequestsFree) {\n    state.corkedRequestsFree.next = corkReq;\n  } else {\n    state.corkedRequestsFree = corkReq;\n  }\n}\n\nObject.defineProperty(Writable.prototype, 'destroyed', {\n  get: function () {\n    if (this._writableState === undefined) {\n      return false;\n    }\n    return this._writableState.destroyed;\n  },\n  set: function (value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (!this._writableState) {\n      return;\n    }\n\n    // backward compatibility, the user is explicitly\n    // managing destroyed\n    this._writableState.destroyed = value;\n  }\n});\n\nWritable.prototype.destroy = destroyImpl.destroy;\nWritable.prototype._undestroy = destroyImpl.undestroy;\nWritable.prototype._destroy = function (err, cb) {\n  this.end();\n  cb(err);\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGhyb3VnaDIvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV93cml0YWJsZS5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYjs7QUFFQSxVQUFVLG1CQUFPLENBQUMsMEVBQXNCO0FBQ3hDOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLE1BQWdGLEdBQUcsQ0FBWTtBQUNoSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSx5QkFBeUIsbUJBQU8sQ0FBQyw2REFBYztBQUMvQyxnQkFBZ0IsbUJBQU8sQ0FBQyw2REFBVTtBQUNsQzs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxtQkFBTyxDQUFDLGdFQUFnQjtBQUNyQztBQUNBOztBQUVBO0FBQ0EsYUFBYSxtQkFBTyxDQUFDLDhIQUEyQjtBQUNoRDs7QUFFQTs7QUFFQSxhQUFhLDRHQUE2QjtBQUMxQyxvQkFBb0IscUJBQU07QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGtCQUFrQixtQkFBTyxDQUFDLHdIQUE0Qjs7QUFFdEQ7O0FBRUE7O0FBRUE7QUFDQSxxQkFBcUIsbUJBQU8sQ0FBQyxvR0FBa0I7O0FBRS9DOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlEQUFpRCwwRkFBMEY7O0FBRTNJO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0wsSUFBSTtBQUNKLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUJBQXFCLG1CQUFPLENBQUMsb0dBQWtCOztBQUUvQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUNBQWlDOztBQUVqQzs7QUFFQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxvREFBb0Q7QUFDcEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3Rocm91Z2gyL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fd3JpdGFibGUuanM/MTU5YSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gQSBiaXQgc2ltcGxlciB0aGFuIHJlYWRhYmxlIHN0cmVhbXMuXG4vLyBJbXBsZW1lbnQgYW4gYXN5bmMgLl93cml0ZShjaHVuaywgZW5jb2RpbmcsIGNiKSwgYW5kIGl0J2xsIGhhbmRsZSBhbGxcbi8vIHRoZSBkcmFpbiBldmVudCBlbWlzc2lvbiBhbmQgYnVmZmVyaW5nLlxuXG4ndXNlIHN0cmljdCc7XG5cbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBwbmEgPSByZXF1aXJlKCdwcm9jZXNzLW5leHRpY2stYXJncycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbm1vZHVsZS5leHBvcnRzID0gV3JpdGFibGU7XG5cbi8qIDxyZXBsYWNlbWVudD4gKi9cbmZ1bmN0aW9uIFdyaXRlUmVxKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdGhpcy5jaHVuayA9IGNodW5rO1xuICB0aGlzLmVuY29kaW5nID0gZW5jb2Rpbmc7XG4gIHRoaXMuY2FsbGJhY2sgPSBjYjtcbiAgdGhpcy5uZXh0ID0gbnVsbDtcbn1cblxuLy8gSXQgc2VlbXMgYSBsaW5rZWQgbGlzdCBidXQgaXQgaXMgbm90XG4vLyB0aGVyZSB3aWxsIGJlIG9ubHkgMiBvZiB0aGVzZSBmb3IgZWFjaCBzdHJlYW1cbmZ1bmN0aW9uIENvcmtlZFJlcXVlc3Qoc3RhdGUpIHtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICB0aGlzLm5leHQgPSBudWxsO1xuICB0aGlzLmVudHJ5ID0gbnVsbDtcbiAgdGhpcy5maW5pc2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgb25Db3JrZWRGaW5pc2goX3RoaXMsIHN0YXRlKTtcbiAgfTtcbn1cbi8qIDwvcmVwbGFjZW1lbnQ+ICovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgYXN5bmNXcml0ZSA9ICFwcm9jZXNzLmJyb3dzZXIgJiYgWyd2MC4xMCcsICd2MC45LiddLmluZGV4T2YocHJvY2Vzcy52ZXJzaW9uLnNsaWNlKDAsIDUpKSA+IC0xID8gc2V0SW1tZWRpYXRlIDogcG5hLm5leHRUaWNrO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgRHVwbGV4O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbldyaXRhYmxlLldyaXRhYmxlU3RhdGUgPSBXcml0YWJsZVN0YXRlO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSBPYmplY3QuY3JlYXRlKHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgaW50ZXJuYWxVdGlsID0ge1xuICBkZXByZWNhdGU6IHJlcXVpcmUoJ3V0aWwtZGVwcmVjYXRlJylcbn07XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBTdHJlYW0gPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvc3RyZWFtJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyO1xudmFyIE91clVpbnQ4QXJyYXkgPSBnbG9iYWwuVWludDhBcnJheSB8fCBmdW5jdGlvbiAoKSB7fTtcbmZ1bmN0aW9uIF91aW50OEFycmF5VG9CdWZmZXIoY2h1bmspIHtcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKGNodW5rKTtcbn1cbmZ1bmN0aW9uIF9pc1VpbnQ4QXJyYXkob2JqKSB7XG4gIHJldHVybiBCdWZmZXIuaXNCdWZmZXIob2JqKSB8fCBvYmogaW5zdGFuY2VvZiBPdXJVaW50OEFycmF5O1xufVxuXG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudmFyIGRlc3Ryb3lJbXBsID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL2Rlc3Ryb3knKTtcblxudXRpbC5pbmhlcml0cyhXcml0YWJsZSwgU3RyZWFtKTtcblxuZnVuY3Rpb24gbm9wKCkge31cblxuZnVuY3Rpb24gV3JpdGFibGVTdGF0ZShvcHRpb25zLCBzdHJlYW0pIHtcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAvLyBEdXBsZXggc3RyZWFtcyBhcmUgYm90aCByZWFkYWJsZSBhbmQgd3JpdGFibGUsIGJ1dCBzaGFyZVxuICAvLyB0aGUgc2FtZSBvcHRpb25zIG9iamVjdC5cbiAgLy8gSG93ZXZlciwgc29tZSBjYXNlcyByZXF1aXJlIHNldHRpbmcgb3B0aW9ucyB0byBkaWZmZXJlbnRcbiAgLy8gdmFsdWVzIGZvciB0aGUgcmVhZGFibGUgYW5kIHRoZSB3cml0YWJsZSBzaWRlcyBvZiB0aGUgZHVwbGV4IHN0cmVhbS5cbiAgLy8gVGhlc2Ugb3B0aW9ucyBjYW4gYmUgcHJvdmlkZWQgc2VwYXJhdGVseSBhcyByZWFkYWJsZVhYWCBhbmQgd3JpdGFibGVYWFguXG4gIHZhciBpc0R1cGxleCA9IHN0cmVhbSBpbnN0YW5jZW9mIER1cGxleDtcblxuICAvLyBvYmplY3Qgc3RyZWFtIGZsYWcgdG8gaW5kaWNhdGUgd2hldGhlciBvciBub3QgdGhpcyBzdHJlYW1cbiAgLy8gY29udGFpbnMgYnVmZmVycyBvciBvYmplY3RzLlxuICB0aGlzLm9iamVjdE1vZGUgPSAhIW9wdGlvbnMub2JqZWN0TW9kZTtcblxuICBpZiAoaXNEdXBsZXgpIHRoaXMub2JqZWN0TW9kZSA9IHRoaXMub2JqZWN0TW9kZSB8fCAhIW9wdGlvbnMud3JpdGFibGVPYmplY3RNb2RlO1xuXG4gIC8vIHRoZSBwb2ludCBhdCB3aGljaCB3cml0ZSgpIHN0YXJ0cyByZXR1cm5pbmcgZmFsc2VcbiAgLy8gTm90ZTogMCBpcyBhIHZhbGlkIHZhbHVlLCBtZWFucyB0aGF0IHdlIGFsd2F5cyByZXR1cm4gZmFsc2UgaWZcbiAgLy8gdGhlIGVudGlyZSBidWZmZXIgaXMgbm90IGZsdXNoZWQgaW1tZWRpYXRlbHkgb24gd3JpdGUoKVxuICB2YXIgaHdtID0gb3B0aW9ucy5oaWdoV2F0ZXJNYXJrO1xuICB2YXIgd3JpdGFibGVId20gPSBvcHRpb25zLndyaXRhYmxlSGlnaFdhdGVyTWFyaztcbiAgdmFyIGRlZmF1bHRId20gPSB0aGlzLm9iamVjdE1vZGUgPyAxNiA6IDE2ICogMTAyNDtcblxuICBpZiAoaHdtIHx8IGh3bSA9PT0gMCkgdGhpcy5oaWdoV2F0ZXJNYXJrID0gaHdtO2Vsc2UgaWYgKGlzRHVwbGV4ICYmICh3cml0YWJsZUh3bSB8fCB3cml0YWJsZUh3bSA9PT0gMCkpIHRoaXMuaGlnaFdhdGVyTWFyayA9IHdyaXRhYmxlSHdtO2Vsc2UgdGhpcy5oaWdoV2F0ZXJNYXJrID0gZGVmYXVsdEh3bTtcblxuICAvLyBjYXN0IHRvIGludHMuXG4gIHRoaXMuaGlnaFdhdGVyTWFyayA9IE1hdGguZmxvb3IodGhpcy5oaWdoV2F0ZXJNYXJrKTtcblxuICAvLyBpZiBfZmluYWwgaGFzIGJlZW4gY2FsbGVkXG4gIHRoaXMuZmluYWxDYWxsZWQgPSBmYWxzZTtcblxuICAvLyBkcmFpbiBldmVudCBmbGFnLlxuICB0aGlzLm5lZWREcmFpbiA9IGZhbHNlO1xuICAvLyBhdCB0aGUgc3RhcnQgb2YgY2FsbGluZyBlbmQoKVxuICB0aGlzLmVuZGluZyA9IGZhbHNlO1xuICAvLyB3aGVuIGVuZCgpIGhhcyBiZWVuIGNhbGxlZCwgYW5kIHJldHVybmVkXG4gIHRoaXMuZW5kZWQgPSBmYWxzZTtcbiAgLy8gd2hlbiAnZmluaXNoJyBpcyBlbWl0dGVkXG4gIHRoaXMuZmluaXNoZWQgPSBmYWxzZTtcblxuICAvLyBoYXMgaXQgYmVlbiBkZXN0cm95ZWRcbiAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcblxuICAvLyBzaG91bGQgd2UgZGVjb2RlIHN0cmluZ3MgaW50byBidWZmZXJzIGJlZm9yZSBwYXNzaW5nIHRvIF93cml0ZT9cbiAgLy8gdGhpcyBpcyBoZXJlIHNvIHRoYXQgc29tZSBub2RlLWNvcmUgc3RyZWFtcyBjYW4gb3B0aW1pemUgc3RyaW5nXG4gIC8vIGhhbmRsaW5nIGF0IGEgbG93ZXIgbGV2ZWwuXG4gIHZhciBub0RlY29kZSA9IG9wdGlvbnMuZGVjb2RlU3RyaW5ncyA9PT0gZmFsc2U7XG4gIHRoaXMuZGVjb2RlU3RyaW5ncyA9ICFub0RlY29kZTtcblxuICAvLyBDcnlwdG8gaXMga2luZCBvZiBvbGQgYW5kIGNydXN0eS4gIEhpc3RvcmljYWxseSwgaXRzIGRlZmF1bHQgc3RyaW5nXG4gIC8vIGVuY29kaW5nIGlzICdiaW5hcnknIHNvIHdlIGhhdmUgdG8gbWFrZSB0aGlzIGNvbmZpZ3VyYWJsZS5cbiAgLy8gRXZlcnl0aGluZyBlbHNlIGluIHRoZSB1bml2ZXJzZSB1c2VzICd1dGY4JywgdGhvdWdoLlxuICB0aGlzLmRlZmF1bHRFbmNvZGluZyA9IG9wdGlvbnMuZGVmYXVsdEVuY29kaW5nIHx8ICd1dGY4JztcblxuICAvLyBub3QgYW4gYWN0dWFsIGJ1ZmZlciB3ZSBrZWVwIHRyYWNrIG9mLCBidXQgYSBtZWFzdXJlbWVudFxuICAvLyBvZiBob3cgbXVjaCB3ZSdyZSB3YWl0aW5nIHRvIGdldCBwdXNoZWQgdG8gc29tZSB1bmRlcmx5aW5nXG4gIC8vIHNvY2tldCBvciBmaWxlLlxuICB0aGlzLmxlbmd0aCA9IDA7XG5cbiAgLy8gYSBmbGFnIHRvIHNlZSB3aGVuIHdlJ3JlIGluIHRoZSBtaWRkbGUgb2YgYSB3cml0ZS5cbiAgdGhpcy53cml0aW5nID0gZmFsc2U7XG5cbiAgLy8gd2hlbiB0cnVlIGFsbCB3cml0ZXMgd2lsbCBiZSBidWZmZXJlZCB1bnRpbCAudW5jb3JrKCkgY2FsbFxuICB0aGlzLmNvcmtlZCA9IDA7XG5cbiAgLy8gYSBmbGFnIHRvIGJlIGFibGUgdG8gdGVsbCBpZiB0aGUgb253cml0ZSBjYiBpcyBjYWxsZWQgaW1tZWRpYXRlbHksXG4gIC8vIG9yIG9uIGEgbGF0ZXIgdGljay4gIFdlIHNldCB0aGlzIHRvIHRydWUgYXQgZmlyc3QsIGJlY2F1c2UgYW55XG4gIC8vIGFjdGlvbnMgdGhhdCBzaG91bGRuJ3QgaGFwcGVuIHVudGlsIFwibGF0ZXJcIiBzaG91bGQgZ2VuZXJhbGx5IGFsc29cbiAgLy8gbm90IGhhcHBlbiBiZWZvcmUgdGhlIGZpcnN0IHdyaXRlIGNhbGwuXG4gIHRoaXMuc3luYyA9IHRydWU7XG5cbiAgLy8gYSBmbGFnIHRvIGtub3cgaWYgd2UncmUgcHJvY2Vzc2luZyBwcmV2aW91c2x5IGJ1ZmZlcmVkIGl0ZW1zLCB3aGljaFxuICAvLyBtYXkgY2FsbCB0aGUgX3dyaXRlKCkgY2FsbGJhY2sgaW4gdGhlIHNhbWUgdGljaywgc28gdGhhdCB3ZSBkb24ndFxuICAvLyBlbmQgdXAgaW4gYW4gb3ZlcmxhcHBlZCBvbndyaXRlIHNpdHVhdGlvbi5cbiAgdGhpcy5idWZmZXJQcm9jZXNzaW5nID0gZmFsc2U7XG5cbiAgLy8gdGhlIGNhbGxiYWNrIHRoYXQncyBwYXNzZWQgdG8gX3dyaXRlKGNodW5rLGNiKVxuICB0aGlzLm9ud3JpdGUgPSBmdW5jdGlvbiAoZXIpIHtcbiAgICBvbndyaXRlKHN0cmVhbSwgZXIpO1xuICB9O1xuXG4gIC8vIHRoZSBjYWxsYmFjayB0aGF0IHRoZSB1c2VyIHN1cHBsaWVzIHRvIHdyaXRlKGNodW5rLGVuY29kaW5nLGNiKVxuICB0aGlzLndyaXRlY2IgPSBudWxsO1xuXG4gIC8vIHRoZSBhbW91bnQgdGhhdCBpcyBiZWluZyB3cml0dGVuIHdoZW4gX3dyaXRlIGlzIGNhbGxlZC5cbiAgdGhpcy53cml0ZWxlbiA9IDA7XG5cbiAgdGhpcy5idWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuICB0aGlzLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuXG4gIC8vIG51bWJlciBvZiBwZW5kaW5nIHVzZXItc3VwcGxpZWQgd3JpdGUgY2FsbGJhY2tzXG4gIC8vIHRoaXMgbXVzdCBiZSAwIGJlZm9yZSAnZmluaXNoJyBjYW4gYmUgZW1pdHRlZFxuICB0aGlzLnBlbmRpbmdjYiA9IDA7XG5cbiAgLy8gZW1pdCBwcmVmaW5pc2ggaWYgdGhlIG9ubHkgdGhpbmcgd2UncmUgd2FpdGluZyBmb3IgaXMgX3dyaXRlIGNic1xuICAvLyBUaGlzIGlzIHJlbGV2YW50IGZvciBzeW5jaHJvbm91cyBUcmFuc2Zvcm0gc3RyZWFtc1xuICB0aGlzLnByZWZpbmlzaGVkID0gZmFsc2U7XG5cbiAgLy8gVHJ1ZSBpZiB0aGUgZXJyb3Igd2FzIGFscmVhZHkgZW1pdHRlZCBhbmQgc2hvdWxkIG5vdCBiZSB0aHJvd24gYWdhaW5cbiAgdGhpcy5lcnJvckVtaXR0ZWQgPSBmYWxzZTtcblxuICAvLyBjb3VudCBidWZmZXJlZCByZXF1ZXN0c1xuICB0aGlzLmJ1ZmZlcmVkUmVxdWVzdENvdW50ID0gMDtcblxuICAvLyBhbGxvY2F0ZSB0aGUgZmlyc3QgQ29ya2VkUmVxdWVzdCwgdGhlcmUgaXMgYWx3YXlzXG4gIC8vIG9uZSBhbGxvY2F0ZWQgYW5kIGZyZWUgdG8gdXNlLCBhbmQgd2UgbWFpbnRhaW4gYXQgbW9zdCB0d29cbiAgdGhpcy5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBuZXcgQ29ya2VkUmVxdWVzdCh0aGlzKTtcbn1cblxuV3JpdGFibGVTdGF0ZS5wcm90b3R5cGUuZ2V0QnVmZmVyID0gZnVuY3Rpb24gZ2V0QnVmZmVyKCkge1xuICB2YXIgY3VycmVudCA9IHRoaXMuYnVmZmVyZWRSZXF1ZXN0O1xuICB2YXIgb3V0ID0gW107XG4gIHdoaWxlIChjdXJyZW50KSB7XG4gICAgb3V0LnB1c2goY3VycmVudCk7XG4gICAgY3VycmVudCA9IGN1cnJlbnQubmV4dDtcbiAgfVxuICByZXR1cm4gb3V0O1xufTtcblxuKGZ1bmN0aW9uICgpIHtcbiAgdHJ5IHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGVTdGF0ZS5wcm90b3R5cGUsICdidWZmZXInLCB7XG4gICAgICBnZXQ6IGludGVybmFsVXRpbC5kZXByZWNhdGUoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRCdWZmZXIoKTtcbiAgICAgIH0sICdfd3JpdGFibGVTdGF0ZS5idWZmZXIgaXMgZGVwcmVjYXRlZC4gVXNlIF93cml0YWJsZVN0YXRlLmdldEJ1ZmZlciAnICsgJ2luc3RlYWQuJywgJ0RFUDAwMDMnKVxuICAgIH0pO1xuICB9IGNhdGNoIChfKSB7fVxufSkoKTtcblxuLy8gVGVzdCBfd3JpdGFibGVTdGF0ZSBmb3IgaW5oZXJpdGFuY2UgdG8gYWNjb3VudCBmb3IgRHVwbGV4IHN0cmVhbXMsXG4vLyB3aG9zZSBwcm90b3R5cGUgY2hhaW4gb25seSBwb2ludHMgdG8gUmVhZGFibGUuXG52YXIgcmVhbEhhc0luc3RhbmNlO1xuaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLmhhc0luc3RhbmNlICYmIHR5cGVvZiBGdW5jdGlvbi5wcm90b3R5cGVbU3ltYm9sLmhhc0luc3RhbmNlXSA9PT0gJ2Z1bmN0aW9uJykge1xuICByZWFsSGFzSW5zdGFuY2UgPSBGdW5jdGlvbi5wcm90b3R5cGVbU3ltYm9sLmhhc0luc3RhbmNlXTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlLCBTeW1ib2wuaGFzSW5zdGFuY2UsIHtcbiAgICB2YWx1ZTogZnVuY3Rpb24gKG9iamVjdCkge1xuICAgICAgaWYgKHJlYWxIYXNJbnN0YW5jZS5jYWxsKHRoaXMsIG9iamVjdCkpIHJldHVybiB0cnVlO1xuICAgICAgaWYgKHRoaXMgIT09IFdyaXRhYmxlKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgIHJldHVybiBvYmplY3QgJiYgb2JqZWN0Ll93cml0YWJsZVN0YXRlIGluc3RhbmNlb2YgV3JpdGFibGVTdGF0ZTtcbiAgICB9XG4gIH0pO1xufSBlbHNlIHtcbiAgcmVhbEhhc0luc3RhbmNlID0gZnVuY3Rpb24gKG9iamVjdCkge1xuICAgIHJldHVybiBvYmplY3QgaW5zdGFuY2VvZiB0aGlzO1xuICB9O1xufVxuXG5mdW5jdGlvbiBXcml0YWJsZShvcHRpb25zKSB7XG4gIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbiAgLy8gV3JpdGFibGUgY3RvciBpcyBhcHBsaWVkIHRvIER1cGxleGVzLCB0b28uXG4gIC8vIGByZWFsSGFzSW5zdGFuY2VgIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHVzaW5nIHBsYWluIGBpbnN0YW5jZW9mYFxuICAvLyB3b3VsZCByZXR1cm4gZmFsc2UsIGFzIG5vIGBfd3JpdGFibGVTdGF0ZWAgcHJvcGVydHkgaXMgYXR0YWNoZWQuXG5cbiAgLy8gVHJ5aW5nIHRvIHVzZSB0aGUgY3VzdG9tIGBpbnN0YW5jZW9mYCBmb3IgV3JpdGFibGUgaGVyZSB3aWxsIGFsc28gYnJlYWsgdGhlXG4gIC8vIE5vZGUuanMgTGF6eVRyYW5zZm9ybSBpbXBsZW1lbnRhdGlvbiwgd2hpY2ggaGFzIGEgbm9uLXRyaXZpYWwgZ2V0dGVyIGZvclxuICAvLyBgX3dyaXRhYmxlU3RhdGVgIHRoYXQgd291bGQgbGVhZCB0byBpbmZpbml0ZSByZWN1cnNpb24uXG4gIGlmICghcmVhbEhhc0luc3RhbmNlLmNhbGwoV3JpdGFibGUsIHRoaXMpICYmICEodGhpcyBpbnN0YW5jZW9mIER1cGxleCkpIHtcbiAgICByZXR1cm4gbmV3IFdyaXRhYmxlKG9wdGlvbnMpO1xuICB9XG5cbiAgdGhpcy5fd3JpdGFibGVTdGF0ZSA9IG5ldyBXcml0YWJsZVN0YXRlKG9wdGlvbnMsIHRoaXMpO1xuXG4gIC8vIGxlZ2FjeS5cbiAgdGhpcy53cml0YWJsZSA9IHRydWU7XG5cbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMud3JpdGUgPT09ICdmdW5jdGlvbicpIHRoaXMuX3dyaXRlID0gb3B0aW9ucy53cml0ZTtcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy53cml0ZXYgPT09ICdmdW5jdGlvbicpIHRoaXMuX3dyaXRldiA9IG9wdGlvbnMud3JpdGV2O1xuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmRlc3Ryb3kgPT09ICdmdW5jdGlvbicpIHRoaXMuX2Rlc3Ryb3kgPSBvcHRpb25zLmRlc3Ryb3k7XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZmluYWwgPT09ICdmdW5jdGlvbicpIHRoaXMuX2ZpbmFsID0gb3B0aW9ucy5maW5hbDtcbiAgfVxuXG4gIFN0cmVhbS5jYWxsKHRoaXMpO1xufVxuXG4vLyBPdGhlcndpc2UgcGVvcGxlIGNhbiBwaXBlIFdyaXRhYmxlIHN0cmVhbXMsIHdoaWNoIGlzIGp1c3Qgd3JvbmcuXG5Xcml0YWJsZS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignQ2Fubm90IHBpcGUsIG5vdCByZWFkYWJsZScpKTtcbn07XG5cbmZ1bmN0aW9uIHdyaXRlQWZ0ZXJFbmQoc3RyZWFtLCBjYikge1xuICB2YXIgZXIgPSBuZXcgRXJyb3IoJ3dyaXRlIGFmdGVyIGVuZCcpO1xuICAvLyBUT0RPOiBkZWZlciBlcnJvciBldmVudHMgY29uc2lzdGVudGx5IGV2ZXJ5d2hlcmUsIG5vdCBqdXN0IHRoZSBjYlxuICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gIHBuYS5uZXh0VGljayhjYiwgZXIpO1xufVxuXG4vLyBDaGVja3MgdGhhdCBhIHVzZXItc3VwcGxpZWQgY2h1bmsgaXMgdmFsaWQsIGVzcGVjaWFsbHkgZm9yIHRoZSBwYXJ0aWN1bGFyXG4vLyBtb2RlIHRoZSBzdHJlYW0gaXMgaW4uIEN1cnJlbnRseSB0aGlzIG1lYW5zIHRoYXQgYG51bGxgIGlzIG5ldmVyIGFjY2VwdGVkXG4vLyBhbmQgdW5kZWZpbmVkL25vbi1zdHJpbmcgdmFsdWVzIGFyZSBvbmx5IGFsbG93ZWQgaW4gb2JqZWN0IG1vZGUuXG5mdW5jdGlvbiB2YWxpZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBjYikge1xuICB2YXIgdmFsaWQgPSB0cnVlO1xuICB2YXIgZXIgPSBmYWxzZTtcblxuICBpZiAoY2h1bmsgPT09IG51bGwpIHtcbiAgICBlciA9IG5ldyBUeXBlRXJyb3IoJ01heSBub3Qgd3JpdGUgbnVsbCB2YWx1ZXMgdG8gc3RyZWFtJyk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGNodW5rICE9PSAnc3RyaW5nJyAmJiBjaHVuayAhPT0gdW5kZWZpbmVkICYmICFzdGF0ZS5vYmplY3RNb2RlKSB7XG4gICAgZXIgPSBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIG5vbi1zdHJpbmcvYnVmZmVyIGNodW5rJyk7XG4gIH1cbiAgaWYgKGVyKSB7XG4gICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICAgIHBuYS5uZXh0VGljayhjYiwgZXIpO1xuICAgIHZhbGlkID0gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHZhbGlkO1xufVxuXG5Xcml0YWJsZS5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuICB2YXIgcmV0ID0gZmFsc2U7XG4gIHZhciBpc0J1ZiA9ICFzdGF0ZS5vYmplY3RNb2RlICYmIF9pc1VpbnQ4QXJyYXkoY2h1bmspO1xuXG4gIGlmIChpc0J1ZiAmJiAhQnVmZmVyLmlzQnVmZmVyKGNodW5rKSkge1xuICAgIGNodW5rID0gX3VpbnQ4QXJyYXlUb0J1ZmZlcihjaHVuayk7XG4gIH1cblxuICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBlbmNvZGluZztcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH1cblxuICBpZiAoaXNCdWYpIGVuY29kaW5nID0gJ2J1ZmZlcic7ZWxzZSBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9IHN0YXRlLmRlZmF1bHRFbmNvZGluZztcblxuICBpZiAodHlwZW9mIGNiICE9PSAnZnVuY3Rpb24nKSBjYiA9IG5vcDtcblxuICBpZiAoc3RhdGUuZW5kZWQpIHdyaXRlQWZ0ZXJFbmQodGhpcywgY2IpO2Vsc2UgaWYgKGlzQnVmIHx8IHZhbGlkQ2h1bmsodGhpcywgc3RhdGUsIGNodW5rLCBjYikpIHtcbiAgICBzdGF0ZS5wZW5kaW5nY2IrKztcbiAgICByZXQgPSB3cml0ZU9yQnVmZmVyKHRoaXMsIHN0YXRlLCBpc0J1ZiwgY2h1bmssIGVuY29kaW5nLCBjYik7XG4gIH1cblxuICByZXR1cm4gcmV0O1xufTtcblxuV3JpdGFibGUucHJvdG90eXBlLmNvcmsgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG5cbiAgc3RhdGUuY29ya2VkKys7XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUudW5jb3JrID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuXG4gIGlmIChzdGF0ZS5jb3JrZWQpIHtcbiAgICBzdGF0ZS5jb3JrZWQtLTtcblxuICAgIGlmICghc3RhdGUud3JpdGluZyAmJiAhc3RhdGUuY29ya2VkICYmICFzdGF0ZS5maW5pc2hlZCAmJiAhc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyAmJiBzdGF0ZS5idWZmZXJlZFJlcXVlc3QpIGNsZWFyQnVmZmVyKHRoaXMsIHN0YXRlKTtcbiAgfVxufTtcblxuV3JpdGFibGUucHJvdG90eXBlLnNldERlZmF1bHRFbmNvZGluZyA9IGZ1bmN0aW9uIHNldERlZmF1bHRFbmNvZGluZyhlbmNvZGluZykge1xuICAvLyBub2RlOjpQYXJzZUVuY29kaW5nKCkgcmVxdWlyZXMgbG93ZXIgY2FzZS5cbiAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycpIGVuY29kaW5nID0gZW5jb2RpbmcudG9Mb3dlckNhc2UoKTtcbiAgaWYgKCEoWydoZXgnLCAndXRmOCcsICd1dGYtOCcsICdhc2NpaScsICdiaW5hcnknLCAnYmFzZTY0JywgJ3VjczInLCAndWNzLTInLCAndXRmMTZsZScsICd1dGYtMTZsZScsICdyYXcnXS5pbmRleE9mKChlbmNvZGluZyArICcnKS50b0xvd2VyQ2FzZSgpKSA+IC0xKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKTtcbiAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZWZhdWx0RW5jb2RpbmcgPSBlbmNvZGluZztcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiBkZWNvZGVDaHVuayhzdGF0ZSwgY2h1bmssIGVuY29kaW5nKSB7XG4gIGlmICghc3RhdGUub2JqZWN0TW9kZSAmJiBzdGF0ZS5kZWNvZGVTdHJpbmdzICE9PSBmYWxzZSAmJiB0eXBlb2YgY2h1bmsgPT09ICdzdHJpbmcnKSB7XG4gICAgY2h1bmsgPSBCdWZmZXIuZnJvbShjaHVuaywgZW5jb2RpbmcpO1xuICB9XG4gIHJldHVybiBjaHVuaztcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlLnByb3RvdHlwZSwgJ3dyaXRhYmxlSGlnaFdhdGVyTWFyaycsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUuaGlnaFdhdGVyTWFyaztcbiAgfVxufSk7XG5cbi8vIGlmIHdlJ3JlIGFscmVhZHkgd3JpdGluZyBzb21ldGhpbmcsIHRoZW4ganVzdCBwdXQgdGhpc1xuLy8gaW4gdGhlIHF1ZXVlLCBhbmQgd2FpdCBvdXIgdHVybi4gIE90aGVyd2lzZSwgY2FsbCBfd3JpdGVcbi8vIElmIHdlIHJldHVybiBmYWxzZSwgdGhlbiB3ZSBuZWVkIGEgZHJhaW4gZXZlbnQsIHNvIHNldCB0aGF0IGZsYWcuXG5mdW5jdGlvbiB3cml0ZU9yQnVmZmVyKHN0cmVhbSwgc3RhdGUsIGlzQnVmLCBjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIGlmICghaXNCdWYpIHtcbiAgICB2YXIgbmV3Q2h1bmsgPSBkZWNvZGVDaHVuayhzdGF0ZSwgY2h1bmssIGVuY29kaW5nKTtcbiAgICBpZiAoY2h1bmsgIT09IG5ld0NodW5rKSB7XG4gICAgICBpc0J1ZiA9IHRydWU7XG4gICAgICBlbmNvZGluZyA9ICdidWZmZXInO1xuICAgICAgY2h1bmsgPSBuZXdDaHVuaztcbiAgICB9XG4gIH1cbiAgdmFyIGxlbiA9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuXG4gIHN0YXRlLmxlbmd0aCArPSBsZW47XG5cbiAgdmFyIHJldCA9IHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcms7XG4gIC8vIHdlIG11c3QgZW5zdXJlIHRoYXQgcHJldmlvdXMgbmVlZERyYWluIHdpbGwgbm90IGJlIHJlc2V0IHRvIGZhbHNlLlxuICBpZiAoIXJldCkgc3RhdGUubmVlZERyYWluID0gdHJ1ZTtcblxuICBpZiAoc3RhdGUud3JpdGluZyB8fCBzdGF0ZS5jb3JrZWQpIHtcbiAgICB2YXIgbGFzdCA9IHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3Q7XG4gICAgc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IHtcbiAgICAgIGNodW5rOiBjaHVuayxcbiAgICAgIGVuY29kaW5nOiBlbmNvZGluZyxcbiAgICAgIGlzQnVmOiBpc0J1ZixcbiAgICAgIGNhbGxiYWNrOiBjYixcbiAgICAgIG5leHQ6IG51bGxcbiAgICB9O1xuICAgIGlmIChsYXN0KSB7XG4gICAgICBsYXN0Lm5leHQgPSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0O1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3QgPSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0O1xuICAgIH1cbiAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudCArPSAxO1xuICB9IGVsc2Uge1xuICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmFsc2UsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYik7XG4gIH1cblxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIHdyaXRldiwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHN0YXRlLndyaXRlbGVuID0gbGVuO1xuICBzdGF0ZS53cml0ZWNiID0gY2I7XG4gIHN0YXRlLndyaXRpbmcgPSB0cnVlO1xuICBzdGF0ZS5zeW5jID0gdHJ1ZTtcbiAgaWYgKHdyaXRldikgc3RyZWFtLl93cml0ZXYoY2h1bmssIHN0YXRlLm9ud3JpdGUpO2Vsc2Ugc3RyZWFtLl93cml0ZShjaHVuaywgZW5jb2RpbmcsIHN0YXRlLm9ud3JpdGUpO1xuICBzdGF0ZS5zeW5jID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIG9ud3JpdGVFcnJvcihzdHJlYW0sIHN0YXRlLCBzeW5jLCBlciwgY2IpIHtcbiAgLS1zdGF0ZS5wZW5kaW5nY2I7XG5cbiAgaWYgKHN5bmMpIHtcbiAgICAvLyBkZWZlciB0aGUgY2FsbGJhY2sgaWYgd2UgYXJlIGJlaW5nIGNhbGxlZCBzeW5jaHJvbm91c2x5XG4gICAgLy8gdG8gYXZvaWQgcGlsaW5nIHVwIHRoaW5ncyBvbiB0aGUgc3RhY2tcbiAgICBwbmEubmV4dFRpY2soY2IsIGVyKTtcbiAgICAvLyB0aGlzIGNhbiBlbWl0IGZpbmlzaCwgYW5kIGl0IHdpbGwgYWx3YXlzIGhhcHBlblxuICAgIC8vIGFmdGVyIGVycm9yXG4gICAgcG5hLm5leHRUaWNrKGZpbmlzaE1heWJlLCBzdHJlYW0sIHN0YXRlKTtcbiAgICBzdHJlYW0uX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gdHJ1ZTtcbiAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gIH0gZWxzZSB7XG4gICAgLy8gdGhlIGNhbGxlciBleHBlY3QgdGhpcyB0byBoYXBwZW4gYmVmb3JlIGlmXG4gICAgLy8gaXQgaXMgYXN5bmNcbiAgICBjYihlcik7XG4gICAgc3RyZWFtLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IHRydWU7XG4gICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICAgIC8vIHRoaXMgY2FuIGVtaXQgZmluaXNoLCBidXQgZmluaXNoIG11c3RcbiAgICAvLyBhbHdheXMgZm9sbG93IGVycm9yXG4gICAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gb253cml0ZVN0YXRlVXBkYXRlKHN0YXRlKSB7XG4gIHN0YXRlLndyaXRpbmcgPSBmYWxzZTtcbiAgc3RhdGUud3JpdGVjYiA9IG51bGw7XG4gIHN0YXRlLmxlbmd0aCAtPSBzdGF0ZS53cml0ZWxlbjtcbiAgc3RhdGUud3JpdGVsZW4gPSAwO1xufVxuXG5mdW5jdGlvbiBvbndyaXRlKHN0cmVhbSwgZXIpIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl93cml0YWJsZVN0YXRlO1xuICB2YXIgc3luYyA9IHN0YXRlLnN5bmM7XG4gIHZhciBjYiA9IHN0YXRlLndyaXRlY2I7XG5cbiAgb253cml0ZVN0YXRlVXBkYXRlKHN0YXRlKTtcblxuICBpZiAoZXIpIG9ud3JpdGVFcnJvcihzdHJlYW0sIHN0YXRlLCBzeW5jLCBlciwgY2IpO2Vsc2Uge1xuICAgIC8vIENoZWNrIGlmIHdlJ3JlIGFjdHVhbGx5IHJlYWR5IHRvIGZpbmlzaCwgYnV0IGRvbid0IGVtaXQgeWV0XG4gICAgdmFyIGZpbmlzaGVkID0gbmVlZEZpbmlzaChzdGF0ZSk7XG5cbiAgICBpZiAoIWZpbmlzaGVkICYmICFzdGF0ZS5jb3JrZWQgJiYgIXN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgJiYgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0KSB7XG4gICAgICBjbGVhckJ1ZmZlcihzdHJlYW0sIHN0YXRlKTtcbiAgICB9XG5cbiAgICBpZiAoc3luYykge1xuICAgICAgLyo8cmVwbGFjZW1lbnQ+Ki9cbiAgICAgIGFzeW5jV3JpdGUoYWZ0ZXJXcml0ZSwgc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKTtcbiAgICAgIC8qPC9yZXBsYWNlbWVudD4qL1xuICAgIH0gZWxzZSB7XG4gICAgICBhZnRlcldyaXRlKHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYik7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFmdGVyV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKSB7XG4gIGlmICghZmluaXNoZWQpIG9ud3JpdGVEcmFpbihzdHJlYW0sIHN0YXRlKTtcbiAgc3RhdGUucGVuZGluZ2NiLS07XG4gIGNiKCk7XG4gIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xufVxuXG4vLyBNdXN0IGZvcmNlIGNhbGxiYWNrIHRvIGJlIGNhbGxlZCBvbiBuZXh0VGljaywgc28gdGhhdCB3ZSBkb24ndFxuLy8gZW1pdCAnZHJhaW4nIGJlZm9yZSB0aGUgd3JpdGUoKSBjb25zdW1lciBnZXRzIHRoZSAnZmFsc2UnIHJldHVyblxuLy8gdmFsdWUsIGFuZCBoYXMgYSBjaGFuY2UgdG8gYXR0YWNoIGEgJ2RyYWluJyBsaXN0ZW5lci5cbmZ1bmN0aW9uIG9ud3JpdGVEcmFpbihzdHJlYW0sIHN0YXRlKSB7XG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUubmVlZERyYWluKSB7XG4gICAgc3RhdGUubmVlZERyYWluID0gZmFsc2U7XG4gICAgc3RyZWFtLmVtaXQoJ2RyYWluJyk7XG4gIH1cbn1cblxuLy8gaWYgdGhlcmUncyBzb21ldGhpbmcgaW4gdGhlIGJ1ZmZlciB3YWl0aW5nLCB0aGVuIHByb2Nlc3MgaXRcbmZ1bmN0aW9uIGNsZWFyQnVmZmVyKHN0cmVhbSwgc3RhdGUpIHtcbiAgc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyA9IHRydWU7XG4gIHZhciBlbnRyeSA9IHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdDtcblxuICBpZiAoc3RyZWFtLl93cml0ZXYgJiYgZW50cnkgJiYgZW50cnkubmV4dCkge1xuICAgIC8vIEZhc3QgY2FzZSwgd3JpdGUgZXZlcnl0aGluZyB1c2luZyBfd3JpdGV2KClcbiAgICB2YXIgbCA9IHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50O1xuICAgIHZhciBidWZmZXIgPSBuZXcgQXJyYXkobCk7XG4gICAgdmFyIGhvbGRlciA9IHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZTtcbiAgICBob2xkZXIuZW50cnkgPSBlbnRyeTtcblxuICAgIHZhciBjb3VudCA9IDA7XG4gICAgdmFyIGFsbEJ1ZmZlcnMgPSB0cnVlO1xuICAgIHdoaWxlIChlbnRyeSkge1xuICAgICAgYnVmZmVyW2NvdW50XSA9IGVudHJ5O1xuICAgICAgaWYgKCFlbnRyeS5pc0J1ZikgYWxsQnVmZmVycyA9IGZhbHNlO1xuICAgICAgZW50cnkgPSBlbnRyeS5uZXh0O1xuICAgICAgY291bnQgKz0gMTtcbiAgICB9XG4gICAgYnVmZmVyLmFsbEJ1ZmZlcnMgPSBhbGxCdWZmZXJzO1xuXG4gICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCB0cnVlLCBzdGF0ZS5sZW5ndGgsIGJ1ZmZlciwgJycsIGhvbGRlci5maW5pc2gpO1xuXG4gICAgLy8gZG9Xcml0ZSBpcyBhbG1vc3QgYWx3YXlzIGFzeW5jLCBkZWZlciB0aGVzZSB0byBzYXZlIGEgYml0IG9mIHRpbWVcbiAgICAvLyBhcyB0aGUgaG90IHBhdGggZW5kcyB3aXRoIGRvV3JpdGVcbiAgICBzdGF0ZS5wZW5kaW5nY2IrKztcbiAgICBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcbiAgICBpZiAoaG9sZGVyLm5leHQpIHtcbiAgICAgIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZSA9IGhvbGRlci5uZXh0O1xuICAgICAgaG9sZGVyLm5leHQgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBuZXcgQ29ya2VkUmVxdWVzdChzdGF0ZSk7XG4gICAgfVxuICAgIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50ID0gMDtcbiAgfSBlbHNlIHtcbiAgICAvLyBTbG93IGNhc2UsIHdyaXRlIGNodW5rcyBvbmUtYnktb25lXG4gICAgd2hpbGUgKGVudHJ5KSB7XG4gICAgICB2YXIgY2h1bmsgPSBlbnRyeS5jaHVuaztcbiAgICAgIHZhciBlbmNvZGluZyA9IGVudHJ5LmVuY29kaW5nO1xuICAgICAgdmFyIGNiID0gZW50cnkuY2FsbGJhY2s7XG4gICAgICB2YXIgbGVuID0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG5cbiAgICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmFsc2UsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYik7XG4gICAgICBlbnRyeSA9IGVudHJ5Lm5leHQ7XG4gICAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudC0tO1xuICAgICAgLy8gaWYgd2UgZGlkbid0IGNhbGwgdGhlIG9ud3JpdGUgaW1tZWRpYXRlbHksIHRoZW5cbiAgICAgIC8vIGl0IG1lYW5zIHRoYXQgd2UgbmVlZCB0byB3YWl0IHVudGlsIGl0IGRvZXMuXG4gICAgICAvLyBhbHNvLCB0aGF0IG1lYW5zIHRoYXQgdGhlIGNodW5rIGFuZCBjYiBhcmUgY3VycmVudGx5XG4gICAgICAvLyBiZWluZyBwcm9jZXNzZWQsIHNvIG1vdmUgdGhlIGJ1ZmZlciBjb3VudGVyIHBhc3QgdGhlbS5cbiAgICAgIGlmIChzdGF0ZS53cml0aW5nKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChlbnRyeSA9PT0gbnVsbCkgc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG4gIH1cblxuICBzdGF0ZS5idWZmZXJlZFJlcXVlc3QgPSBlbnRyeTtcbiAgc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyA9IGZhbHNlO1xufVxuXG5Xcml0YWJsZS5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgY2IobmV3IEVycm9yKCdfd3JpdGUoKSBpcyBub3QgaW1wbGVtZW50ZWQnKSk7XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuX3dyaXRldiA9IG51bGw7XG5cbldyaXRhYmxlLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuXG4gIGlmICh0eXBlb2YgY2h1bmsgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IGNodW5rO1xuICAgIGNodW5rID0gbnVsbDtcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBlbmNvZGluZztcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH1cblxuICBpZiAoY2h1bmsgIT09IG51bGwgJiYgY2h1bmsgIT09IHVuZGVmaW5lZCkgdGhpcy53cml0ZShjaHVuaywgZW5jb2RpbmcpO1xuXG4gIC8vIC5lbmQoKSBmdWxseSB1bmNvcmtzXG4gIGlmIChzdGF0ZS5jb3JrZWQpIHtcbiAgICBzdGF0ZS5jb3JrZWQgPSAxO1xuICAgIHRoaXMudW5jb3JrKCk7XG4gIH1cblxuICAvLyBpZ25vcmUgdW5uZWNlc3NhcnkgZW5kKCkgY2FsbHMuXG4gIGlmICghc3RhdGUuZW5kaW5nICYmICFzdGF0ZS5maW5pc2hlZCkgZW5kV3JpdGFibGUodGhpcywgc3RhdGUsIGNiKTtcbn07XG5cbmZ1bmN0aW9uIG5lZWRGaW5pc2goc3RhdGUpIHtcbiAgcmV0dXJuIHN0YXRlLmVuZGluZyAmJiBzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0ID09PSBudWxsICYmICFzdGF0ZS5maW5pc2hlZCAmJiAhc3RhdGUud3JpdGluZztcbn1cbmZ1bmN0aW9uIGNhbGxGaW5hbChzdHJlYW0sIHN0YXRlKSB7XG4gIHN0cmVhbS5fZmluYWwoZnVuY3Rpb24gKGVycikge1xuICAgIHN0YXRlLnBlbmRpbmdjYi0tO1xuICAgIGlmIChlcnIpIHtcbiAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVycik7XG4gICAgfVxuICAgIHN0YXRlLnByZWZpbmlzaGVkID0gdHJ1ZTtcbiAgICBzdHJlYW0uZW1pdCgncHJlZmluaXNoJyk7XG4gICAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG4gIH0pO1xufVxuZnVuY3Rpb24gcHJlZmluaXNoKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5wcmVmaW5pc2hlZCAmJiAhc3RhdGUuZmluYWxDYWxsZWQpIHtcbiAgICBpZiAodHlwZW9mIHN0cmVhbS5fZmluYWwgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHN0YXRlLnBlbmRpbmdjYisrO1xuICAgICAgc3RhdGUuZmluYWxDYWxsZWQgPSB0cnVlO1xuICAgICAgcG5hLm5leHRUaWNrKGNhbGxGaW5hbCwgc3RyZWFtLCBzdGF0ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLnByZWZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgIHN0cmVhbS5lbWl0KCdwcmVmaW5pc2gnKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSkge1xuICB2YXIgbmVlZCA9IG5lZWRGaW5pc2goc3RhdGUpO1xuICBpZiAobmVlZCkge1xuICAgIHByZWZpbmlzaChzdHJlYW0sIHN0YXRlKTtcbiAgICBpZiAoc3RhdGUucGVuZGluZ2NiID09PSAwKSB7XG4gICAgICBzdGF0ZS5maW5pc2hlZCA9IHRydWU7XG4gICAgICBzdHJlYW0uZW1pdCgnZmluaXNoJyk7XG4gICAgfVxuICB9XG4gIHJldHVybiBuZWVkO1xufVxuXG5mdW5jdGlvbiBlbmRXcml0YWJsZShzdHJlYW0sIHN0YXRlLCBjYikge1xuICBzdGF0ZS5lbmRpbmcgPSB0cnVlO1xuICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcbiAgaWYgKGNiKSB7XG4gICAgaWYgKHN0YXRlLmZpbmlzaGVkKSBwbmEubmV4dFRpY2soY2IpO2Vsc2Ugc3RyZWFtLm9uY2UoJ2ZpbmlzaCcsIGNiKTtcbiAgfVxuICBzdGF0ZS5lbmRlZCA9IHRydWU7XG4gIHN0cmVhbS53cml0YWJsZSA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBvbkNvcmtlZEZpbmlzaChjb3JrUmVxLCBzdGF0ZSwgZXJyKSB7XG4gIHZhciBlbnRyeSA9IGNvcmtSZXEuZW50cnk7XG4gIGNvcmtSZXEuZW50cnkgPSBudWxsO1xuICB3aGlsZSAoZW50cnkpIHtcbiAgICB2YXIgY2IgPSBlbnRyeS5jYWxsYmFjaztcbiAgICBzdGF0ZS5wZW5kaW5nY2ItLTtcbiAgICBjYihlcnIpO1xuICAgIGVudHJ5ID0gZW50cnkubmV4dDtcbiAgfVxuICBpZiAoc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlKSB7XG4gICAgc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlLm5leHQgPSBjb3JrUmVxO1xuICB9IGVsc2Uge1xuICAgIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZSA9IGNvcmtSZXE7XG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlLnByb3RvdHlwZSwgJ2Rlc3Ryb3llZCcsIHtcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuX3dyaXRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQ7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgLy8gd2UgaWdub3JlIHRoZSB2YWx1ZSBpZiB0aGUgc3RyZWFtXG4gICAgLy8gaGFzIG5vdCBiZWVuIGluaXRpYWxpemVkIHlldFxuICAgIGlmICghdGhpcy5fd3JpdGFibGVTdGF0ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHRoZSB1c2VyIGlzIGV4cGxpY2l0bHlcbiAgICAvLyBtYW5hZ2luZyBkZXN0cm95ZWRcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZCA9IHZhbHVlO1xuICB9XG59KTtcblxuV3JpdGFibGUucHJvdG90eXBlLmRlc3Ryb3kgPSBkZXN0cm95SW1wbC5kZXN0cm95O1xuV3JpdGFibGUucHJvdG90eXBlLl91bmRlc3Ryb3kgPSBkZXN0cm95SW1wbC51bmRlc3Ryb3k7XG5Xcml0YWJsZS5wcm90b3R5cGUuX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyLCBjYikge1xuICB0aGlzLmVuZCgpO1xuICBjYihlcnIpO1xufTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/through2/node_modules/readable-stream/lib/_stream_writable.js\n");

/***/ }),

/***/ "./node_modules/through2/node_modules/readable-stream/lib/internal/streams/BufferList.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/through2/node_modules/readable-stream/lib/internal/streams/BufferList.js ***!
  \***********************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Buffer = (__webpack_require__(/*! safe-buffer */ \"./node_modules/through2/node_modules/safe-buffer/index.js\").Buffer);\nvar util = __webpack_require__(/*! util */ \"?44e1\");\n\nfunction copyBuffer(src, target, offset) {\n  src.copy(target, offset);\n}\n\nmodule.exports = function () {\n  function BufferList() {\n    _classCallCheck(this, BufferList);\n\n    this.head = null;\n    this.tail = null;\n    this.length = 0;\n  }\n\n  BufferList.prototype.push = function push(v) {\n    var entry = { data: v, next: null };\n    if (this.length > 0) this.tail.next = entry;else this.head = entry;\n    this.tail = entry;\n    ++this.length;\n  };\n\n  BufferList.prototype.unshift = function unshift(v) {\n    var entry = { data: v, next: this.head };\n    if (this.length === 0) this.tail = entry;\n    this.head = entry;\n    ++this.length;\n  };\n\n  BufferList.prototype.shift = function shift() {\n    if (this.length === 0) return;\n    var ret = this.head.data;\n    if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;\n    --this.length;\n    return ret;\n  };\n\n  BufferList.prototype.clear = function clear() {\n    this.head = this.tail = null;\n    this.length = 0;\n  };\n\n  BufferList.prototype.join = function join(s) {\n    if (this.length === 0) return '';\n    var p = this.head;\n    var ret = '' + p.data;\n    while (p = p.next) {\n      ret += s + p.data;\n    }return ret;\n  };\n\n  BufferList.prototype.concat = function concat(n) {\n    if (this.length === 0) return Buffer.alloc(0);\n    if (this.length === 1) return this.head.data;\n    var ret = Buffer.allocUnsafe(n >>> 0);\n    var p = this.head;\n    var i = 0;\n    while (p) {\n      copyBuffer(p.data, ret, i);\n      i += p.data.length;\n      p = p.next;\n    }\n    return ret;\n  };\n\n  return BufferList;\n}();\n\nif (util && util.inspect && util.inspect.custom) {\n  module.exports.prototype[util.inspect.custom] = function () {\n    var obj = util.inspect({ length: this.length });\n    return this.constructor.name + ' ' + obj;\n  };\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGhyb3VnaDIvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9CdWZmZXJMaXN0LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLGtEQUFrRCwwQ0FBMEM7O0FBRTVGLGFBQWEsNEdBQTZCO0FBQzFDLFdBQVcsbUJBQU8sQ0FBQyxtQkFBTTs7QUFFekI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQjtBQUNsQixnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsNkJBQTZCLHFCQUFxQjtBQUNsRDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3Rocm91Z2gyL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvQnVmZmVyTGlzdC5qcz9iZWE1Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyO1xudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG5cbmZ1bmN0aW9uIGNvcHlCdWZmZXIoc3JjLCB0YXJnZXQsIG9mZnNldCkge1xuICBzcmMuY29weSh0YXJnZXQsIG9mZnNldCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBCdWZmZXJMaXN0KCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBCdWZmZXJMaXN0KTtcblxuICAgIHRoaXMuaGVhZCA9IG51bGw7XG4gICAgdGhpcy50YWlsID0gbnVsbDtcbiAgICB0aGlzLmxlbmd0aCA9IDA7XG4gIH1cblxuICBCdWZmZXJMaXN0LnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gcHVzaCh2KSB7XG4gICAgdmFyIGVudHJ5ID0geyBkYXRhOiB2LCBuZXh0OiBudWxsIH07XG4gICAgaWYgKHRoaXMubGVuZ3RoID4gMCkgdGhpcy50YWlsLm5leHQgPSBlbnRyeTtlbHNlIHRoaXMuaGVhZCA9IGVudHJ5O1xuICAgIHRoaXMudGFpbCA9IGVudHJ5O1xuICAgICsrdGhpcy5sZW5ndGg7XG4gIH07XG5cbiAgQnVmZmVyTGlzdC5wcm90b3R5cGUudW5zaGlmdCA9IGZ1bmN0aW9uIHVuc2hpZnQodikge1xuICAgIHZhciBlbnRyeSA9IHsgZGF0YTogdiwgbmV4dDogdGhpcy5oZWFkIH07XG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSB0aGlzLnRhaWwgPSBlbnRyeTtcbiAgICB0aGlzLmhlYWQgPSBlbnRyeTtcbiAgICArK3RoaXMubGVuZ3RoO1xuICB9O1xuXG4gIEJ1ZmZlckxpc3QucHJvdG90eXBlLnNoaWZ0ID0gZnVuY3Rpb24gc2hpZnQoKSB7XG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm47XG4gICAgdmFyIHJldCA9IHRoaXMuaGVhZC5kYXRhO1xuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMSkgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbnVsbDtlbHNlIHRoaXMuaGVhZCA9IHRoaXMuaGVhZC5uZXh0O1xuICAgIC0tdGhpcy5sZW5ndGg7XG4gICAgcmV0dXJuIHJldDtcbiAgfTtcblxuICBCdWZmZXJMaXN0LnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG51bGw7XG4gICAgdGhpcy5sZW5ndGggPSAwO1xuICB9O1xuXG4gIEJ1ZmZlckxpc3QucHJvdG90eXBlLmpvaW4gPSBmdW5jdGlvbiBqb2luKHMpIHtcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVybiAnJztcbiAgICB2YXIgcCA9IHRoaXMuaGVhZDtcbiAgICB2YXIgcmV0ID0gJycgKyBwLmRhdGE7XG4gICAgd2hpbGUgKHAgPSBwLm5leHQpIHtcbiAgICAgIHJldCArPSBzICsgcC5kYXRhO1xuICAgIH1yZXR1cm4gcmV0O1xuICB9O1xuXG4gIEJ1ZmZlckxpc3QucHJvdG90eXBlLmNvbmNhdCA9IGZ1bmN0aW9uIGNvbmNhdChuKSB7XG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gQnVmZmVyLmFsbG9jKDApO1xuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMSkgcmV0dXJuIHRoaXMuaGVhZC5kYXRhO1xuICAgIHZhciByZXQgPSBCdWZmZXIuYWxsb2NVbnNhZmUobiA+Pj4gMCk7XG4gICAgdmFyIHAgPSB0aGlzLmhlYWQ7XG4gICAgdmFyIGkgPSAwO1xuICAgIHdoaWxlIChwKSB7XG4gICAgICBjb3B5QnVmZmVyKHAuZGF0YSwgcmV0LCBpKTtcbiAgICAgIGkgKz0gcC5kYXRhLmxlbmd0aDtcbiAgICAgIHAgPSBwLm5leHQ7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH07XG5cbiAgcmV0dXJuIEJ1ZmZlckxpc3Q7XG59KCk7XG5cbmlmICh1dGlsICYmIHV0aWwuaW5zcGVjdCAmJiB1dGlsLmluc3BlY3QuY3VzdG9tKSB7XG4gIG1vZHVsZS5leHBvcnRzLnByb3RvdHlwZVt1dGlsLmluc3BlY3QuY3VzdG9tXSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb2JqID0gdXRpbC5pbnNwZWN0KHsgbGVuZ3RoOiB0aGlzLmxlbmd0aCB9KTtcbiAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci5uYW1lICsgJyAnICsgb2JqO1xuICB9O1xufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/through2/node_modules/readable-stream/lib/internal/streams/BufferList.js\n");

/***/ }),

/***/ "./node_modules/through2/node_modules/readable-stream/lib/internal/streams/destroy.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/through2/node_modules/readable-stream/lib/internal/streams/destroy.js ***!
  \********************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\n\n/*<replacement>*/\n\nvar pna = __webpack_require__(/*! process-nextick-args */ \"./node_modules/process-nextick-args/index.js\");\n/*</replacement>*/\n\n// undocumented cb() API, needed for core, not for public API\nfunction destroy(err, cb) {\n  var _this = this;\n\n  var readableDestroyed = this._readableState && this._readableState.destroyed;\n  var writableDestroyed = this._writableState && this._writableState.destroyed;\n\n  if (readableDestroyed || writableDestroyed) {\n    if (cb) {\n      cb(err);\n    } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {\n      pna.nextTick(emitErrorNT, this, err);\n    }\n    return this;\n  }\n\n  // we set destroyed to true before firing error callbacks in order\n  // to make it re-entrance safe in case destroy() is called within callbacks\n\n  if (this._readableState) {\n    this._readableState.destroyed = true;\n  }\n\n  // if this is a duplex stream mark the writable part as destroyed as well\n  if (this._writableState) {\n    this._writableState.destroyed = true;\n  }\n\n  this._destroy(err || null, function (err) {\n    if (!cb && err) {\n      pna.nextTick(emitErrorNT, _this, err);\n      if (_this._writableState) {\n        _this._writableState.errorEmitted = true;\n      }\n    } else if (cb) {\n      cb(err);\n    }\n  });\n\n  return this;\n}\n\nfunction undestroy() {\n  if (this._readableState) {\n    this._readableState.destroyed = false;\n    this._readableState.reading = false;\n    this._readableState.ended = false;\n    this._readableState.endEmitted = false;\n  }\n\n  if (this._writableState) {\n    this._writableState.destroyed = false;\n    this._writableState.ended = false;\n    this._writableState.ending = false;\n    this._writableState.finished = false;\n    this._writableState.errorEmitted = false;\n  }\n}\n\nfunction emitErrorNT(self, err) {\n  self.emit('error', err);\n}\n\nmodule.exports = {\n  destroy: destroy,\n  undestroy: undestroy\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGhyb3VnaDIvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9kZXN0cm95LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViOztBQUVBLFVBQVUsbUJBQU8sQ0FBQywwRUFBc0I7QUFDeEM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90aHJvdWdoMi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL2Rlc3Ryb3kuanM/M2NiZiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBwbmEgPSByZXF1aXJlKCdwcm9jZXNzLW5leHRpY2stYXJncycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8vIHVuZG9jdW1lbnRlZCBjYigpIEFQSSwgbmVlZGVkIGZvciBjb3JlLCBub3QgZm9yIHB1YmxpYyBBUElcbmZ1bmN0aW9uIGRlc3Ryb3koZXJyLCBjYikge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIHZhciByZWFkYWJsZURlc3Ryb3llZCA9IHRoaXMuX3JlYWRhYmxlU3RhdGUgJiYgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQ7XG4gIHZhciB3cml0YWJsZURlc3Ryb3llZCA9IHRoaXMuX3dyaXRhYmxlU3RhdGUgJiYgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQ7XG5cbiAgaWYgKHJlYWRhYmxlRGVzdHJveWVkIHx8IHdyaXRhYmxlRGVzdHJveWVkKSB7XG4gICAgaWYgKGNiKSB7XG4gICAgICBjYihlcnIpO1xuICAgIH0gZWxzZSBpZiAoZXJyICYmICghdGhpcy5fd3JpdGFibGVTdGF0ZSB8fCAhdGhpcy5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQpKSB7XG4gICAgICBwbmEubmV4dFRpY2soZW1pdEVycm9yTlQsIHRoaXMsIGVycik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gd2Ugc2V0IGRlc3Ryb3llZCB0byB0cnVlIGJlZm9yZSBmaXJpbmcgZXJyb3IgY2FsbGJhY2tzIGluIG9yZGVyXG4gIC8vIHRvIG1ha2UgaXQgcmUtZW50cmFuY2Ugc2FmZSBpbiBjYXNlIGRlc3Ryb3koKSBpcyBjYWxsZWQgd2l0aGluIGNhbGxiYWNrc1xuXG4gIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlKSB7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB0cnVlO1xuICB9XG5cbiAgLy8gaWYgdGhpcyBpcyBhIGR1cGxleCBzdHJlYW0gbWFyayB0aGUgd3JpdGFibGUgcGFydCBhcyBkZXN0cm95ZWQgYXMgd2VsbFxuICBpZiAodGhpcy5fd3JpdGFibGVTdGF0ZSkge1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkID0gdHJ1ZTtcbiAgfVxuXG4gIHRoaXMuX2Rlc3Ryb3koZXJyIHx8IG51bGwsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICBpZiAoIWNiICYmIGVycikge1xuICAgICAgcG5hLm5leHRUaWNrKGVtaXRFcnJvck5ULCBfdGhpcywgZXJyKTtcbiAgICAgIGlmIChfdGhpcy5fd3JpdGFibGVTdGF0ZSkge1xuICAgICAgICBfdGhpcy5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY2IpIHtcbiAgICAgIGNiKGVycik7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gdGhpcztcbn1cblxuZnVuY3Rpb24gdW5kZXN0cm95KCkge1xuICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSkge1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5lbmRlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZW5kRW1pdHRlZCA9IGZhbHNlO1xuICB9XG5cbiAgaWYgKHRoaXMuX3dyaXRhYmxlU3RhdGUpIHtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZW5kZWQgPSBmYWxzZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmVuZGluZyA9IGZhbHNlO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZmluaXNoZWQgPSBmYWxzZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGVtaXRFcnJvck5UKHNlbGYsIGVycikge1xuICBzZWxmLmVtaXQoJ2Vycm9yJywgZXJyKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGRlc3Ryb3k6IGRlc3Ryb3ksXG4gIHVuZGVzdHJveTogdW5kZXN0cm95XG59OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/through2/node_modules/readable-stream/lib/internal/streams/destroy.js\n");

/***/ }),

/***/ "./node_modules/through2/node_modules/readable-stream/lib/internal/streams/stream-browser.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/through2/node_modules/readable-stream/lib/internal/streams/stream-browser.js ***!
  \***************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! events */ \"./node_modules/events/events.js\").EventEmitter;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGhyb3VnaDIvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9zdHJlYW0tYnJvd3Nlci5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQSxrR0FBK0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3Rocm91Z2gyL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvc3RyZWFtLWJyb3dzZXIuanM/MzllMSJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/through2/node_modules/readable-stream/lib/internal/streams/stream-browser.js\n");

/***/ }),

/***/ "./node_modules/through2/node_modules/readable-stream/readable-browser.js":
/*!********************************************************************************!*\
  !*** ./node_modules/through2/node_modules/readable-stream/readable-browser.js ***!
  \********************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("exports = module.exports = __webpack_require__(/*! ./lib/_stream_readable.js */ \"./node_modules/through2/node_modules/readable-stream/lib/_stream_readable.js\");\nexports.Stream = exports;\nexports.Readable = exports;\nexports.Writable = __webpack_require__(/*! ./lib/_stream_writable.js */ \"./node_modules/through2/node_modules/readable-stream/lib/_stream_writable.js\");\nexports.Duplex = __webpack_require__(/*! ./lib/_stream_duplex.js */ \"./node_modules/through2/node_modules/readable-stream/lib/_stream_duplex.js\");\nexports.Transform = __webpack_require__(/*! ./lib/_stream_transform.js */ \"./node_modules/through2/node_modules/readable-stream/lib/_stream_transform.js\");\nexports.PassThrough = __webpack_require__(/*! ./lib/_stream_passthrough.js */ \"./node_modules/through2/node_modules/readable-stream/lib/_stream_passthrough.js\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGhyb3VnaDIvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9yZWFkYWJsZS1icm93c2VyLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBLFVBQVUscUpBQXFEO0FBQy9ELGNBQWM7QUFDZCxnQkFBZ0I7QUFDaEIsdUpBQXVEO0FBQ3ZELGlKQUFtRDtBQUNuRCwwSkFBeUQ7QUFDekQsZ0tBQTZEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90aHJvdWdoMi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL3JlYWRhYmxlLWJyb3dzZXIuanM/ZjE1MSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3JlYWRhYmxlLmpzJyk7XG5leHBvcnRzLlN0cmVhbSA9IGV4cG9ydHM7XG5leHBvcnRzLlJlYWRhYmxlID0gZXhwb3J0cztcbmV4cG9ydHMuV3JpdGFibGUgPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3dyaXRhYmxlLmpzJyk7XG5leHBvcnRzLkR1cGxleCA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fZHVwbGV4LmpzJyk7XG5leHBvcnRzLlRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fdHJhbnNmb3JtLmpzJyk7XG5leHBvcnRzLlBhc3NUaHJvdWdoID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV9wYXNzdGhyb3VnaC5qcycpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/through2/node_modules/readable-stream/readable-browser.js\n");

/***/ }),

/***/ "./node_modules/through2/node_modules/safe-buffer/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/through2/node_modules/safe-buffer/index.js ***!
  \*****************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("/* eslint-disable node/no-deprecated-api */\nvar buffer = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\")\nvar Buffer = buffer.Buffer\n\n// alternative to using Object.keys for old browsers\nfunction copyProps (src, dst) {\n  for (var key in src) {\n    dst[key] = src[key]\n  }\n}\nif (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {\n  module.exports = buffer\n} else {\n  // Copy properties from require('buffer')\n  copyProps(buffer, exports)\n  exports.Buffer = SafeBuffer\n}\n\nfunction SafeBuffer (arg, encodingOrOffset, length) {\n  return Buffer(arg, encodingOrOffset, length)\n}\n\n// Copy static methods from Buffer\ncopyProps(Buffer, SafeBuffer)\n\nSafeBuffer.from = function (arg, encodingOrOffset, length) {\n  if (typeof arg === 'number') {\n    throw new TypeError('Argument must not be a number')\n  }\n  return Buffer(arg, encodingOrOffset, length)\n}\n\nSafeBuffer.alloc = function (size, fill, encoding) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  var buf = Buffer(size)\n  if (fill !== undefined) {\n    if (typeof encoding === 'string') {\n      buf.fill(fill, encoding)\n    } else {\n      buf.fill(fill)\n    }\n  } else {\n    buf.fill(0)\n  }\n  return buf\n}\n\nSafeBuffer.allocUnsafe = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return Buffer(size)\n}\n\nSafeBuffer.allocUnsafeSlow = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return buffer.SlowBuffer(size)\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGhyb3VnaDIvbm9kZV9tb2R1bGVzL3NhZmUtYnVmZmVyL2luZGV4LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0EsYUFBYSxtQkFBTyxDQUFDLDhDQUFRO0FBQzdCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUUsY0FBYztBQUNoQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3Rocm91Z2gyL25vZGVfbW9kdWxlcy9zYWZlLWJ1ZmZlci9pbmRleC5qcz8zMWQ4Il0sInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1kaXNhYmxlIG5vZGUvbm8tZGVwcmVjYXRlZC1hcGkgKi9cbnZhciBidWZmZXIgPSByZXF1aXJlKCdidWZmZXInKVxudmFyIEJ1ZmZlciA9IGJ1ZmZlci5CdWZmZXJcblxuLy8gYWx0ZXJuYXRpdmUgdG8gdXNpbmcgT2JqZWN0LmtleXMgZm9yIG9sZCBicm93c2Vyc1xuZnVuY3Rpb24gY29weVByb3BzIChzcmMsIGRzdCkge1xuICBmb3IgKHZhciBrZXkgaW4gc3JjKSB7XG4gICAgZHN0W2tleV0gPSBzcmNba2V5XVxuICB9XG59XG5pZiAoQnVmZmVyLmZyb20gJiYgQnVmZmVyLmFsbG9jICYmIEJ1ZmZlci5hbGxvY1Vuc2FmZSAmJiBCdWZmZXIuYWxsb2NVbnNhZmVTbG93KSB7XG4gIG1vZHVsZS5leHBvcnRzID0gYnVmZmVyXG59IGVsc2Uge1xuICAvLyBDb3B5IHByb3BlcnRpZXMgZnJvbSByZXF1aXJlKCdidWZmZXInKVxuICBjb3B5UHJvcHMoYnVmZmVyLCBleHBvcnRzKVxuICBleHBvcnRzLkJ1ZmZlciA9IFNhZmVCdWZmZXJcbn1cblxuZnVuY3Rpb24gU2FmZUJ1ZmZlciAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIEJ1ZmZlcihhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuLy8gQ29weSBzdGF0aWMgbWV0aG9kcyBmcm9tIEJ1ZmZlclxuY29weVByb3BzKEJ1ZmZlciwgU2FmZUJ1ZmZlcilcblxuU2FmZUJ1ZmZlci5mcm9tID0gZnVuY3Rpb24gKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3Qgbm90IGJlIGEgbnVtYmVyJylcbiAgfVxuICByZXR1cm4gQnVmZmVyKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG5TYWZlQnVmZmVyLmFsbG9jID0gZnVuY3Rpb24gKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfVxuICB2YXIgYnVmID0gQnVmZmVyKHNpemUpXG4gIGlmIChmaWxsICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJykge1xuICAgICAgYnVmLmZpbGwoZmlsbCwgZW5jb2RpbmcpXG4gICAgfSBlbHNlIHtcbiAgICAgIGJ1Zi5maWxsKGZpbGwpXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGJ1Zi5maWxsKDApXG4gIH1cbiAgcmV0dXJuIGJ1ZlxufVxuXG5TYWZlQnVmZmVyLmFsbG9jVW5zYWZlID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9XG4gIHJldHVybiBCdWZmZXIoc2l6ZSlcbn1cblxuU2FmZUJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH1cbiAgcmV0dXJuIGJ1ZmZlci5TbG93QnVmZmVyKHNpemUpXG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/through2/node_modules/safe-buffer/index.js\n");

/***/ }),

/***/ "./node_modules/through2/node_modules/string_decoder/lib/string_decoder.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/through2/node_modules/string_decoder/lib/string_decoder.js ***!
  \*********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n/*<replacement>*/\n\nvar Buffer = (__webpack_require__(/*! safe-buffer */ \"./node_modules/through2/node_modules/safe-buffer/index.js\").Buffer);\n/*</replacement>*/\n\nvar isEncoding = Buffer.isEncoding || function (encoding) {\n  encoding = '' + encoding;\n  switch (encoding && encoding.toLowerCase()) {\n    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':\n      return true;\n    default:\n      return false;\n  }\n};\n\nfunction _normalizeEncoding(enc) {\n  if (!enc) return 'utf8';\n  var retried;\n  while (true) {\n    switch (enc) {\n      case 'utf8':\n      case 'utf-8':\n        return 'utf8';\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return 'utf16le';\n      case 'latin1':\n      case 'binary':\n        return 'latin1';\n      case 'base64':\n      case 'ascii':\n      case 'hex':\n        return enc;\n      default:\n        if (retried) return; // undefined\n        enc = ('' + enc).toLowerCase();\n        retried = true;\n    }\n  }\n};\n\n// Do not cache `Buffer.isEncoding` when checking encoding names as some\n// modules monkey-patch it to support additional encodings\nfunction normalizeEncoding(enc) {\n  var nenc = _normalizeEncoding(enc);\n  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);\n  return nenc || enc;\n}\n\n// StringDecoder provides an interface for efficiently splitting a series of\n// buffers into a series of JS strings without breaking apart multi-byte\n// characters.\nexports.StringDecoder = StringDecoder;\nfunction StringDecoder(encoding) {\n  this.encoding = normalizeEncoding(encoding);\n  var nb;\n  switch (this.encoding) {\n    case 'utf16le':\n      this.text = utf16Text;\n      this.end = utf16End;\n      nb = 4;\n      break;\n    case 'utf8':\n      this.fillLast = utf8FillLast;\n      nb = 4;\n      break;\n    case 'base64':\n      this.text = base64Text;\n      this.end = base64End;\n      nb = 3;\n      break;\n    default:\n      this.write = simpleWrite;\n      this.end = simpleEnd;\n      return;\n  }\n  this.lastNeed = 0;\n  this.lastTotal = 0;\n  this.lastChar = Buffer.allocUnsafe(nb);\n}\n\nStringDecoder.prototype.write = function (buf) {\n  if (buf.length === 0) return '';\n  var r;\n  var i;\n  if (this.lastNeed) {\n    r = this.fillLast(buf);\n    if (r === undefined) return '';\n    i = this.lastNeed;\n    this.lastNeed = 0;\n  } else {\n    i = 0;\n  }\n  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);\n  return r || '';\n};\n\nStringDecoder.prototype.end = utf8End;\n\n// Returns only complete characters in a Buffer\nStringDecoder.prototype.text = utf8Text;\n\n// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer\nStringDecoder.prototype.fillLast = function (buf) {\n  if (this.lastNeed <= buf.length) {\n    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);\n    return this.lastChar.toString(this.encoding, 0, this.lastTotal);\n  }\n  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);\n  this.lastNeed -= buf.length;\n};\n\n// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a\n// continuation byte. If an invalid byte is detected, -2 is returned.\nfunction utf8CheckByte(byte) {\n  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;\n  return byte >> 6 === 0x02 ? -1 : -2;\n}\n\n// Checks at most 3 bytes at the end of a Buffer in order to detect an\n// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)\n// needed to complete the UTF-8 character (if applicable) are returned.\nfunction utf8CheckIncomplete(self, buf, i) {\n  var j = buf.length - 1;\n  if (j < i) return 0;\n  var nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) self.lastNeed = nb - 1;\n    return nb;\n  }\n  if (--j < i || nb === -2) return 0;\n  nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) self.lastNeed = nb - 2;\n    return nb;\n  }\n  if (--j < i || nb === -2) return 0;\n  nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) {\n      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;\n    }\n    return nb;\n  }\n  return 0;\n}\n\n// Validates as many continuation bytes for a multi-byte UTF-8 character as\n// needed or are available. If we see a non-continuation byte where we expect\n// one, we \"replace\" the validated continuation bytes we've seen so far with\n// a single UTF-8 replacement character ('\\ufffd'), to match v8's UTF-8 decoding\n// behavior. The continuation byte check is included three times in the case\n// where all of the continuation bytes for a character exist in the same buffer.\n// It is also done this way as a slight performance increase instead of using a\n// loop.\nfunction utf8CheckExtraBytes(self, buf, p) {\n  if ((buf[0] & 0xC0) !== 0x80) {\n    self.lastNeed = 0;\n    return '\\ufffd';\n  }\n  if (self.lastNeed > 1 && buf.length > 1) {\n    if ((buf[1] & 0xC0) !== 0x80) {\n      self.lastNeed = 1;\n      return '\\ufffd';\n    }\n    if (self.lastNeed > 2 && buf.length > 2) {\n      if ((buf[2] & 0xC0) !== 0x80) {\n        self.lastNeed = 2;\n        return '\\ufffd';\n      }\n    }\n  }\n}\n\n// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.\nfunction utf8FillLast(buf) {\n  var p = this.lastTotal - this.lastNeed;\n  var r = utf8CheckExtraBytes(this, buf, p);\n  if (r !== undefined) return r;\n  if (this.lastNeed <= buf.length) {\n    buf.copy(this.lastChar, p, 0, this.lastNeed);\n    return this.lastChar.toString(this.encoding, 0, this.lastTotal);\n  }\n  buf.copy(this.lastChar, p, 0, buf.length);\n  this.lastNeed -= buf.length;\n}\n\n// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a\n// partial character, the character's bytes are buffered until the required\n// number of bytes are available.\nfunction utf8Text(buf, i) {\n  var total = utf8CheckIncomplete(this, buf, i);\n  if (!this.lastNeed) return buf.toString('utf8', i);\n  this.lastTotal = total;\n  var end = buf.length - (total - this.lastNeed);\n  buf.copy(this.lastChar, 0, end);\n  return buf.toString('utf8', i, end);\n}\n\n// For UTF-8, a replacement character is added when ending on a partial\n// character.\nfunction utf8End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) return r + '\\ufffd';\n  return r;\n}\n\n// UTF-16LE typically needs two bytes per character, but even if we have an even\n// number of bytes available, we need to check if we end on a leading/high\n// surrogate. In that case, we need to wait for the next two bytes in order to\n// decode the last character properly.\nfunction utf16Text(buf, i) {\n  if ((buf.length - i) % 2 === 0) {\n    var r = buf.toString('utf16le', i);\n    if (r) {\n      var c = r.charCodeAt(r.length - 1);\n      if (c >= 0xD800 && c <= 0xDBFF) {\n        this.lastNeed = 2;\n        this.lastTotal = 4;\n        this.lastChar[0] = buf[buf.length - 2];\n        this.lastChar[1] = buf[buf.length - 1];\n        return r.slice(0, -1);\n      }\n    }\n    return r;\n  }\n  this.lastNeed = 1;\n  this.lastTotal = 2;\n  this.lastChar[0] = buf[buf.length - 1];\n  return buf.toString('utf16le', i, buf.length - 1);\n}\n\n// For UTF-16LE we do not explicitly append special replacement characters if we\n// end on a partial character, we simply let v8 handle that.\nfunction utf16End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) {\n    var end = this.lastTotal - this.lastNeed;\n    return r + this.lastChar.toString('utf16le', 0, end);\n  }\n  return r;\n}\n\nfunction base64Text(buf, i) {\n  var n = (buf.length - i) % 3;\n  if (n === 0) return buf.toString('base64', i);\n  this.lastNeed = 3 - n;\n  this.lastTotal = 3;\n  if (n === 1) {\n    this.lastChar[0] = buf[buf.length - 1];\n  } else {\n    this.lastChar[0] = buf[buf.length - 2];\n    this.lastChar[1] = buf[buf.length - 1];\n  }\n  return buf.toString('base64', i, buf.length - n);\n}\n\nfunction base64End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);\n  return r;\n}\n\n// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)\nfunction simpleWrite(buf) {\n  return buf.toString(this.encoding);\n}\n\nfunction simpleEnd(buf) {\n  return buf && buf.length ? this.write(buf) : '';\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGhyb3VnaDIvbm9kZV9tb2R1bGVzL3N0cmluZ19kZWNvZGVyL2xpYi9zdHJpbmdfZGVjb2Rlci5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVhOztBQUViOztBQUVBLGFBQWEsNEdBQTZCO0FBQzFDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixzQ0FBc0Msc0NBQXNDO0FBQ3pHO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdGhyb3VnaDIvbm9kZV9tb2R1bGVzL3N0cmluZ19kZWNvZGVyL2xpYi9zdHJpbmdfZGVjb2Rlci5qcz9lYjU1Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlcjtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgaXNFbmNvZGluZyA9IEJ1ZmZlci5pc0VuY29kaW5nIHx8IGZ1bmN0aW9uIChlbmNvZGluZykge1xuICBlbmNvZGluZyA9ICcnICsgZW5jb2Rpbmc7XG4gIHN3aXRjaCAoZW5jb2RpbmcgJiYgZW5jb2RpbmcudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ2hleCc6Y2FzZSAndXRmOCc6Y2FzZSAndXRmLTgnOmNhc2UgJ2FzY2lpJzpjYXNlICdiaW5hcnknOmNhc2UgJ2Jhc2U2NCc6Y2FzZSAndWNzMic6Y2FzZSAndWNzLTInOmNhc2UgJ3V0ZjE2bGUnOmNhc2UgJ3V0Zi0xNmxlJzpjYXNlICdyYXcnOlxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcblxuZnVuY3Rpb24gX25vcm1hbGl6ZUVuY29kaW5nKGVuYykge1xuICBpZiAoIWVuYykgcmV0dXJuICd1dGY4JztcbiAgdmFyIHJldHJpZWQ7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgc3dpdGNoIChlbmMpIHtcbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gJ3V0ZjgnO1xuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuICd1dGYxNmxlJztcbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gJ2xhdGluMSc7XG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGVuYztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChyZXRyaWVkKSByZXR1cm47IC8vIHVuZGVmaW5lZFxuICAgICAgICBlbmMgPSAoJycgKyBlbmMpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHJldHJpZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxufTtcblxuLy8gRG8gbm90IGNhY2hlIGBCdWZmZXIuaXNFbmNvZGluZ2Agd2hlbiBjaGVja2luZyBlbmNvZGluZyBuYW1lcyBhcyBzb21lXG4vLyBtb2R1bGVzIG1vbmtleS1wYXRjaCBpdCB0byBzdXBwb3J0IGFkZGl0aW9uYWwgZW5jb2RpbmdzXG5mdW5jdGlvbiBub3JtYWxpemVFbmNvZGluZyhlbmMpIHtcbiAgdmFyIG5lbmMgPSBfbm9ybWFsaXplRW5jb2RpbmcoZW5jKTtcbiAgaWYgKHR5cGVvZiBuZW5jICE9PSAnc3RyaW5nJyAmJiAoQnVmZmVyLmlzRW5jb2RpbmcgPT09IGlzRW5jb2RpbmcgfHwgIWlzRW5jb2RpbmcoZW5jKSkpIHRocm93IG5ldyBFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuYyk7XG4gIHJldHVybiBuZW5jIHx8IGVuYztcbn1cblxuLy8gU3RyaW5nRGVjb2RlciBwcm92aWRlcyBhbiBpbnRlcmZhY2UgZm9yIGVmZmljaWVudGx5IHNwbGl0dGluZyBhIHNlcmllcyBvZlxuLy8gYnVmZmVycyBpbnRvIGEgc2VyaWVzIG9mIEpTIHN0cmluZ3Mgd2l0aG91dCBicmVha2luZyBhcGFydCBtdWx0aS1ieXRlXG4vLyBjaGFyYWN0ZXJzLlxuZXhwb3J0cy5TdHJpbmdEZWNvZGVyID0gU3RyaW5nRGVjb2RlcjtcbmZ1bmN0aW9uIFN0cmluZ0RlY29kZXIoZW5jb2RpbmcpIHtcbiAgdGhpcy5lbmNvZGluZyA9IG5vcm1hbGl6ZUVuY29kaW5nKGVuY29kaW5nKTtcbiAgdmFyIG5iO1xuICBzd2l0Y2ggKHRoaXMuZW5jb2RpbmcpIHtcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIHRoaXMudGV4dCA9IHV0ZjE2VGV4dDtcbiAgICAgIHRoaXMuZW5kID0gdXRmMTZFbmQ7XG4gICAgICBuYiA9IDQ7XG4gICAgICBicmVhaztcbiAgICBjYXNlICd1dGY4JzpcbiAgICAgIHRoaXMuZmlsbExhc3QgPSB1dGY4RmlsbExhc3Q7XG4gICAgICBuYiA9IDQ7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgdGhpcy50ZXh0ID0gYmFzZTY0VGV4dDtcbiAgICAgIHRoaXMuZW5kID0gYmFzZTY0RW5kO1xuICAgICAgbmIgPSAzO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRoaXMud3JpdGUgPSBzaW1wbGVXcml0ZTtcbiAgICAgIHRoaXMuZW5kID0gc2ltcGxlRW5kO1xuICAgICAgcmV0dXJuO1xuICB9XG4gIHRoaXMubGFzdE5lZWQgPSAwO1xuICB0aGlzLmxhc3RUb3RhbCA9IDA7XG4gIHRoaXMubGFzdENoYXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUobmIpO1xufVxuXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChidWYpIHtcbiAgaWYgKGJ1Zi5sZW5ndGggPT09IDApIHJldHVybiAnJztcbiAgdmFyIHI7XG4gIHZhciBpO1xuICBpZiAodGhpcy5sYXN0TmVlZCkge1xuICAgIHIgPSB0aGlzLmZpbGxMYXN0KGJ1Zik7XG4gICAgaWYgKHIgPT09IHVuZGVmaW5lZCkgcmV0dXJuICcnO1xuICAgIGkgPSB0aGlzLmxhc3ROZWVkO1xuICAgIHRoaXMubGFzdE5lZWQgPSAwO1xuICB9IGVsc2Uge1xuICAgIGkgPSAwO1xuICB9XG4gIGlmIChpIDwgYnVmLmxlbmd0aCkgcmV0dXJuIHIgPyByICsgdGhpcy50ZXh0KGJ1ZiwgaSkgOiB0aGlzLnRleHQoYnVmLCBpKTtcbiAgcmV0dXJuIHIgfHwgJyc7XG59O1xuXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS5lbmQgPSB1dGY4RW5kO1xuXG4vLyBSZXR1cm5zIG9ubHkgY29tcGxldGUgY2hhcmFjdGVycyBpbiBhIEJ1ZmZlclxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUudGV4dCA9IHV0ZjhUZXh0O1xuXG4vLyBBdHRlbXB0cyB0byBjb21wbGV0ZSBhIHBhcnRpYWwgbm9uLVVURi04IGNoYXJhY3RlciB1c2luZyBieXRlcyBmcm9tIGEgQnVmZmVyXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS5maWxsTGFzdCA9IGZ1bmN0aW9uIChidWYpIHtcbiAgaWYgKHRoaXMubGFzdE5lZWQgPD0gYnVmLmxlbmd0aCkge1xuICAgIGJ1Zi5jb3B5KHRoaXMubGFzdENoYXIsIHRoaXMubGFzdFRvdGFsIC0gdGhpcy5sYXN0TmVlZCwgMCwgdGhpcy5sYXN0TmVlZCk7XG4gICAgcmV0dXJuIHRoaXMubGFzdENoYXIudG9TdHJpbmcodGhpcy5lbmNvZGluZywgMCwgdGhpcy5sYXN0VG90YWwpO1xuICB9XG4gIGJ1Zi5jb3B5KHRoaXMubGFzdENoYXIsIHRoaXMubGFzdFRvdGFsIC0gdGhpcy5sYXN0TmVlZCwgMCwgYnVmLmxlbmd0aCk7XG4gIHRoaXMubGFzdE5lZWQgLT0gYnVmLmxlbmd0aDtcbn07XG5cbi8vIENoZWNrcyB0aGUgdHlwZSBvZiBhIFVURi04IGJ5dGUsIHdoZXRoZXIgaXQncyBBU0NJSSwgYSBsZWFkaW5nIGJ5dGUsIG9yIGFcbi8vIGNvbnRpbnVhdGlvbiBieXRlLiBJZiBhbiBpbnZhbGlkIGJ5dGUgaXMgZGV0ZWN0ZWQsIC0yIGlzIHJldHVybmVkLlxuZnVuY3Rpb24gdXRmOENoZWNrQnl0ZShieXRlKSB7XG4gIGlmIChieXRlIDw9IDB4N0YpIHJldHVybiAwO2Vsc2UgaWYgKGJ5dGUgPj4gNSA9PT0gMHgwNikgcmV0dXJuIDI7ZWxzZSBpZiAoYnl0ZSA+PiA0ID09PSAweDBFKSByZXR1cm4gMztlbHNlIGlmIChieXRlID4+IDMgPT09IDB4MUUpIHJldHVybiA0O1xuICByZXR1cm4gYnl0ZSA+PiA2ID09PSAweDAyID8gLTEgOiAtMjtcbn1cblxuLy8gQ2hlY2tzIGF0IG1vc3QgMyBieXRlcyBhdCB0aGUgZW5kIG9mIGEgQnVmZmVyIGluIG9yZGVyIHRvIGRldGVjdCBhblxuLy8gaW5jb21wbGV0ZSBtdWx0aS1ieXRlIFVURi04IGNoYXJhY3Rlci4gVGhlIHRvdGFsIG51bWJlciBvZiBieXRlcyAoMiwgMywgb3IgNClcbi8vIG5lZWRlZCB0byBjb21wbGV0ZSB0aGUgVVRGLTggY2hhcmFjdGVyIChpZiBhcHBsaWNhYmxlKSBhcmUgcmV0dXJuZWQuXG5mdW5jdGlvbiB1dGY4Q2hlY2tJbmNvbXBsZXRlKHNlbGYsIGJ1ZiwgaSkge1xuICB2YXIgaiA9IGJ1Zi5sZW5ndGggLSAxO1xuICBpZiAoaiA8IGkpIHJldHVybiAwO1xuICB2YXIgbmIgPSB1dGY4Q2hlY2tCeXRlKGJ1ZltqXSk7XG4gIGlmIChuYiA+PSAwKSB7XG4gICAgaWYgKG5iID4gMCkgc2VsZi5sYXN0TmVlZCA9IG5iIC0gMTtcbiAgICByZXR1cm4gbmI7XG4gIH1cbiAgaWYgKC0taiA8IGkgfHwgbmIgPT09IC0yKSByZXR1cm4gMDtcbiAgbmIgPSB1dGY4Q2hlY2tCeXRlKGJ1ZltqXSk7XG4gIGlmIChuYiA+PSAwKSB7XG4gICAgaWYgKG5iID4gMCkgc2VsZi5sYXN0TmVlZCA9IG5iIC0gMjtcbiAgICByZXR1cm4gbmI7XG4gIH1cbiAgaWYgKC0taiA8IGkgfHwgbmIgPT09IC0yKSByZXR1cm4gMDtcbiAgbmIgPSB1dGY4Q2hlY2tCeXRlKGJ1ZltqXSk7XG4gIGlmIChuYiA+PSAwKSB7XG4gICAgaWYgKG5iID4gMCkge1xuICAgICAgaWYgKG5iID09PSAyKSBuYiA9IDA7ZWxzZSBzZWxmLmxhc3ROZWVkID0gbmIgLSAzO1xuICAgIH1cbiAgICByZXR1cm4gbmI7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbi8vIFZhbGlkYXRlcyBhcyBtYW55IGNvbnRpbnVhdGlvbiBieXRlcyBmb3IgYSBtdWx0aS1ieXRlIFVURi04IGNoYXJhY3RlciBhc1xuLy8gbmVlZGVkIG9yIGFyZSBhdmFpbGFibGUuIElmIHdlIHNlZSBhIG5vbi1jb250aW51YXRpb24gYnl0ZSB3aGVyZSB3ZSBleHBlY3Rcbi8vIG9uZSwgd2UgXCJyZXBsYWNlXCIgdGhlIHZhbGlkYXRlZCBjb250aW51YXRpb24gYnl0ZXMgd2UndmUgc2VlbiBzbyBmYXIgd2l0aFxuLy8gYSBzaW5nbGUgVVRGLTggcmVwbGFjZW1lbnQgY2hhcmFjdGVyICgnXFx1ZmZmZCcpLCB0byBtYXRjaCB2OCdzIFVURi04IGRlY29kaW5nXG4vLyBiZWhhdmlvci4gVGhlIGNvbnRpbnVhdGlvbiBieXRlIGNoZWNrIGlzIGluY2x1ZGVkIHRocmVlIHRpbWVzIGluIHRoZSBjYXNlXG4vLyB3aGVyZSBhbGwgb2YgdGhlIGNvbnRpbnVhdGlvbiBieXRlcyBmb3IgYSBjaGFyYWN0ZXIgZXhpc3QgaW4gdGhlIHNhbWUgYnVmZmVyLlxuLy8gSXQgaXMgYWxzbyBkb25lIHRoaXMgd2F5IGFzIGEgc2xpZ2h0IHBlcmZvcm1hbmNlIGluY3JlYXNlIGluc3RlYWQgb2YgdXNpbmcgYVxuLy8gbG9vcC5cbmZ1bmN0aW9uIHV0ZjhDaGVja0V4dHJhQnl0ZXMoc2VsZiwgYnVmLCBwKSB7XG4gIGlmICgoYnVmWzBdICYgMHhDMCkgIT09IDB4ODApIHtcbiAgICBzZWxmLmxhc3ROZWVkID0gMDtcbiAgICByZXR1cm4gJ1xcdWZmZmQnO1xuICB9XG4gIGlmIChzZWxmLmxhc3ROZWVkID4gMSAmJiBidWYubGVuZ3RoID4gMSkge1xuICAgIGlmICgoYnVmWzFdICYgMHhDMCkgIT09IDB4ODApIHtcbiAgICAgIHNlbGYubGFzdE5lZWQgPSAxO1xuICAgICAgcmV0dXJuICdcXHVmZmZkJztcbiAgICB9XG4gICAgaWYgKHNlbGYubGFzdE5lZWQgPiAyICYmIGJ1Zi5sZW5ndGggPiAyKSB7XG4gICAgICBpZiAoKGJ1ZlsyXSAmIDB4QzApICE9PSAweDgwKSB7XG4gICAgICAgIHNlbGYubGFzdE5lZWQgPSAyO1xuICAgICAgICByZXR1cm4gJ1xcdWZmZmQnO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vLyBBdHRlbXB0cyB0byBjb21wbGV0ZSBhIG11bHRpLWJ5dGUgVVRGLTggY2hhcmFjdGVyIHVzaW5nIGJ5dGVzIGZyb20gYSBCdWZmZXIuXG5mdW5jdGlvbiB1dGY4RmlsbExhc3QoYnVmKSB7XG4gIHZhciBwID0gdGhpcy5sYXN0VG90YWwgLSB0aGlzLmxhc3ROZWVkO1xuICB2YXIgciA9IHV0ZjhDaGVja0V4dHJhQnl0ZXModGhpcywgYnVmLCBwKTtcbiAgaWYgKHIgIT09IHVuZGVmaW5lZCkgcmV0dXJuIHI7XG4gIGlmICh0aGlzLmxhc3ROZWVkIDw9IGJ1Zi5sZW5ndGgpIHtcbiAgICBidWYuY29weSh0aGlzLmxhc3RDaGFyLCBwLCAwLCB0aGlzLmxhc3ROZWVkKTtcbiAgICByZXR1cm4gdGhpcy5sYXN0Q2hhci50b1N0cmluZyh0aGlzLmVuY29kaW5nLCAwLCB0aGlzLmxhc3RUb3RhbCk7XG4gIH1cbiAgYnVmLmNvcHkodGhpcy5sYXN0Q2hhciwgcCwgMCwgYnVmLmxlbmd0aCk7XG4gIHRoaXMubGFzdE5lZWQgLT0gYnVmLmxlbmd0aDtcbn1cblxuLy8gUmV0dXJucyBhbGwgY29tcGxldGUgVVRGLTggY2hhcmFjdGVycyBpbiBhIEJ1ZmZlci4gSWYgdGhlIEJ1ZmZlciBlbmRlZCBvbiBhXG4vLyBwYXJ0aWFsIGNoYXJhY3RlciwgdGhlIGNoYXJhY3RlcidzIGJ5dGVzIGFyZSBidWZmZXJlZCB1bnRpbCB0aGUgcmVxdWlyZWRcbi8vIG51bWJlciBvZiBieXRlcyBhcmUgYXZhaWxhYmxlLlxuZnVuY3Rpb24gdXRmOFRleHQoYnVmLCBpKSB7XG4gIHZhciB0b3RhbCA9IHV0ZjhDaGVja0luY29tcGxldGUodGhpcywgYnVmLCBpKTtcbiAgaWYgKCF0aGlzLmxhc3ROZWVkKSByZXR1cm4gYnVmLnRvU3RyaW5nKCd1dGY4JywgaSk7XG4gIHRoaXMubGFzdFRvdGFsID0gdG90YWw7XG4gIHZhciBlbmQgPSBidWYubGVuZ3RoIC0gKHRvdGFsIC0gdGhpcy5sYXN0TmVlZCk7XG4gIGJ1Zi5jb3B5KHRoaXMubGFzdENoYXIsIDAsIGVuZCk7XG4gIHJldHVybiBidWYudG9TdHJpbmcoJ3V0ZjgnLCBpLCBlbmQpO1xufVxuXG4vLyBGb3IgVVRGLTgsIGEgcmVwbGFjZW1lbnQgY2hhcmFjdGVyIGlzIGFkZGVkIHdoZW4gZW5kaW5nIG9uIGEgcGFydGlhbFxuLy8gY2hhcmFjdGVyLlxuZnVuY3Rpb24gdXRmOEVuZChidWYpIHtcbiAgdmFyIHIgPSBidWYgJiYgYnVmLmxlbmd0aCA/IHRoaXMud3JpdGUoYnVmKSA6ICcnO1xuICBpZiAodGhpcy5sYXN0TmVlZCkgcmV0dXJuIHIgKyAnXFx1ZmZmZCc7XG4gIHJldHVybiByO1xufVxuXG4vLyBVVEYtMTZMRSB0eXBpY2FsbHkgbmVlZHMgdHdvIGJ5dGVzIHBlciBjaGFyYWN0ZXIsIGJ1dCBldmVuIGlmIHdlIGhhdmUgYW4gZXZlblxuLy8gbnVtYmVyIG9mIGJ5dGVzIGF2YWlsYWJsZSwgd2UgbmVlZCB0byBjaGVjayBpZiB3ZSBlbmQgb24gYSBsZWFkaW5nL2hpZ2hcbi8vIHN1cnJvZ2F0ZS4gSW4gdGhhdCBjYXNlLCB3ZSBuZWVkIHRvIHdhaXQgZm9yIHRoZSBuZXh0IHR3byBieXRlcyBpbiBvcmRlciB0b1xuLy8gZGVjb2RlIHRoZSBsYXN0IGNoYXJhY3RlciBwcm9wZXJseS5cbmZ1bmN0aW9uIHV0ZjE2VGV4dChidWYsIGkpIHtcbiAgaWYgKChidWYubGVuZ3RoIC0gaSkgJSAyID09PSAwKSB7XG4gICAgdmFyIHIgPSBidWYudG9TdHJpbmcoJ3V0ZjE2bGUnLCBpKTtcbiAgICBpZiAocikge1xuICAgICAgdmFyIGMgPSByLmNoYXJDb2RlQXQoci5sZW5ndGggLSAxKTtcbiAgICAgIGlmIChjID49IDB4RDgwMCAmJiBjIDw9IDB4REJGRikge1xuICAgICAgICB0aGlzLmxhc3ROZWVkID0gMjtcbiAgICAgICAgdGhpcy5sYXN0VG90YWwgPSA0O1xuICAgICAgICB0aGlzLmxhc3RDaGFyWzBdID0gYnVmW2J1Zi5sZW5ndGggLSAyXTtcbiAgICAgICAgdGhpcy5sYXN0Q2hhclsxXSA9IGJ1ZltidWYubGVuZ3RoIC0gMV07XG4gICAgICAgIHJldHVybiByLnNsaWNlKDAsIC0xKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHI7XG4gIH1cbiAgdGhpcy5sYXN0TmVlZCA9IDE7XG4gIHRoaXMubGFzdFRvdGFsID0gMjtcbiAgdGhpcy5sYXN0Q2hhclswXSA9IGJ1ZltidWYubGVuZ3RoIC0gMV07XG4gIHJldHVybiBidWYudG9TdHJpbmcoJ3V0ZjE2bGUnLCBpLCBidWYubGVuZ3RoIC0gMSk7XG59XG5cbi8vIEZvciBVVEYtMTZMRSB3ZSBkbyBub3QgZXhwbGljaXRseSBhcHBlbmQgc3BlY2lhbCByZXBsYWNlbWVudCBjaGFyYWN0ZXJzIGlmIHdlXG4vLyBlbmQgb24gYSBwYXJ0aWFsIGNoYXJhY3Rlciwgd2Ugc2ltcGx5IGxldCB2OCBoYW5kbGUgdGhhdC5cbmZ1bmN0aW9uIHV0ZjE2RW5kKGJ1Zikge1xuICB2YXIgciA9IGJ1ZiAmJiBidWYubGVuZ3RoID8gdGhpcy53cml0ZShidWYpIDogJyc7XG4gIGlmICh0aGlzLmxhc3ROZWVkKSB7XG4gICAgdmFyIGVuZCA9IHRoaXMubGFzdFRvdGFsIC0gdGhpcy5sYXN0TmVlZDtcbiAgICByZXR1cm4gciArIHRoaXMubGFzdENoYXIudG9TdHJpbmcoJ3V0ZjE2bGUnLCAwLCBlbmQpO1xuICB9XG4gIHJldHVybiByO1xufVxuXG5mdW5jdGlvbiBiYXNlNjRUZXh0KGJ1ZiwgaSkge1xuICB2YXIgbiA9IChidWYubGVuZ3RoIC0gaSkgJSAzO1xuICBpZiAobiA9PT0gMCkgcmV0dXJuIGJ1Zi50b1N0cmluZygnYmFzZTY0JywgaSk7XG4gIHRoaXMubGFzdE5lZWQgPSAzIC0gbjtcbiAgdGhpcy5sYXN0VG90YWwgPSAzO1xuICBpZiAobiA9PT0gMSkge1xuICAgIHRoaXMubGFzdENoYXJbMF0gPSBidWZbYnVmLmxlbmd0aCAtIDFdO1xuICB9IGVsc2Uge1xuICAgIHRoaXMubGFzdENoYXJbMF0gPSBidWZbYnVmLmxlbmd0aCAtIDJdO1xuICAgIHRoaXMubGFzdENoYXJbMV0gPSBidWZbYnVmLmxlbmd0aCAtIDFdO1xuICB9XG4gIHJldHVybiBidWYudG9TdHJpbmcoJ2Jhc2U2NCcsIGksIGJ1Zi5sZW5ndGggLSBuKTtcbn1cblxuZnVuY3Rpb24gYmFzZTY0RW5kKGJ1Zikge1xuICB2YXIgciA9IGJ1ZiAmJiBidWYubGVuZ3RoID8gdGhpcy53cml0ZShidWYpIDogJyc7XG4gIGlmICh0aGlzLmxhc3ROZWVkKSByZXR1cm4gciArIHRoaXMubGFzdENoYXIudG9TdHJpbmcoJ2Jhc2U2NCcsIDAsIDMgLSB0aGlzLmxhc3ROZWVkKTtcbiAgcmV0dXJuIHI7XG59XG5cbi8vIFBhc3MgYnl0ZXMgb24gdGhyb3VnaCBmb3Igc2luZ2xlLWJ5dGUgZW5jb2RpbmdzIChlLmcuIGFzY2lpLCBsYXRpbjEsIGhleClcbmZ1bmN0aW9uIHNpbXBsZVdyaXRlKGJ1Zikge1xuICByZXR1cm4gYnVmLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcpO1xufVxuXG5mdW5jdGlvbiBzaW1wbGVFbmQoYnVmKSB7XG4gIHJldHVybiBidWYgJiYgYnVmLmxlbmd0aCA/IHRoaXMud3JpdGUoYnVmKSA6ICcnO1xufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/through2/node_modules/string_decoder/lib/string_decoder.js\n");

/***/ }),

/***/ "./node_modules/through2/through2.js":
/*!*******************************************!*\
  !*** ./node_modules/through2/through2.js ***!
  \*******************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("/* provided dependency */ var process = __webpack_require__(/*! process */ \"./node_modules/process/browser.js\");\nvar Transform = (__webpack_require__(/*! readable-stream */ \"./node_modules/through2/node_modules/readable-stream/readable-browser.js\").Transform)\n  , inherits  = (__webpack_require__(/*! util */ \"./node_modules/util/util.js\").inherits)\n  , xtend     = __webpack_require__(/*! xtend */ \"./node_modules/xtend/immutable.js\")\n\nfunction DestroyableTransform(opts) {\n  Transform.call(this, opts)\n  this._destroyed = false\n}\n\ninherits(DestroyableTransform, Transform)\n\nDestroyableTransform.prototype.destroy = function(err) {\n  if (this._destroyed) return\n  this._destroyed = true\n  \n  var self = this\n  process.nextTick(function() {\n    if (err)\n      self.emit('error', err)\n    self.emit('close')\n  })\n}\n\n// a noop _transform function\nfunction noop (chunk, enc, callback) {\n  callback(null, chunk)\n}\n\n\n// create a new export function, used by both the main export and\n// the .ctor export, contains common logic for dealing with arguments\nfunction through2 (construct) {\n  return function (options, transform, flush) {\n    if (typeof options == 'function') {\n      flush     = transform\n      transform = options\n      options   = {}\n    }\n\n    if (typeof transform != 'function')\n      transform = noop\n\n    if (typeof flush != 'function')\n      flush = null\n\n    return construct(options, transform, flush)\n  }\n}\n\n\n// main export, just make me a transform stream!\nmodule.exports = through2(function (options, transform, flush) {\n  var t2 = new DestroyableTransform(options)\n\n  t2._transform = transform\n\n  if (flush)\n    t2._flush = flush\n\n  return t2\n})\n\n\n// make me a reusable prototype that I can `new`, or implicitly `new`\n// with a constructor call\nmodule.exports.ctor = through2(function (options, transform, flush) {\n  function Through2 (override) {\n    if (!(this instanceof Through2))\n      return new Through2(override)\n\n    this.options = xtend(options, override)\n\n    DestroyableTransform.call(this, this.options)\n  }\n\n  inherits(Through2, DestroyableTransform)\n\n  Through2.prototype._transform = transform\n\n  if (flush)\n    Through2.prototype._flush = flush\n\n  return Through2\n})\n\n\nmodule.exports.obj = through2(function (options, transform, flush) {\n  var t2 = new DestroyableTransform(xtend({ objectMode: true, highWaterMark: 16 }, options))\n\n  t2._transform = transform\n\n  if (flush)\n    t2._flush = flush\n\n  return t2\n})\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGhyb3VnaDIvdGhyb3VnaDIuanMuanMiLCJtYXBwaW5ncyI6IjtBQUFBLGdCQUFnQixrSUFBb0M7QUFDcEQsZ0JBQWdCLHlFQUF3QjtBQUN4QyxnQkFBZ0IsbUJBQU8sQ0FBQyxnREFBTzs7QUFFL0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsT0FBTztBQUNUO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7O0FBR0Qsa0JBQWtCO0FBQ2xCLDRDQUE0QyxxQ0FBcUM7O0FBRWpGOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90aHJvdWdoMi90aHJvdWdoMi5qcz9hOGRjIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBUcmFuc2Zvcm0gPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0nKS5UcmFuc2Zvcm1cbiAgLCBpbmhlcml0cyAgPSByZXF1aXJlKCd1dGlsJykuaW5oZXJpdHNcbiAgLCB4dGVuZCAgICAgPSByZXF1aXJlKCd4dGVuZCcpXG5cbmZ1bmN0aW9uIERlc3Ryb3lhYmxlVHJhbnNmb3JtKG9wdHMpIHtcbiAgVHJhbnNmb3JtLmNhbGwodGhpcywgb3B0cylcbiAgdGhpcy5fZGVzdHJveWVkID0gZmFsc2Vcbn1cblxuaW5oZXJpdHMoRGVzdHJveWFibGVUcmFuc2Zvcm0sIFRyYW5zZm9ybSlcblxuRGVzdHJveWFibGVUcmFuc2Zvcm0ucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbihlcnIpIHtcbiAgaWYgKHRoaXMuX2Rlc3Ryb3llZCkgcmV0dXJuXG4gIHRoaXMuX2Rlc3Ryb3llZCA9IHRydWVcbiAgXG4gIHZhciBzZWxmID0gdGhpc1xuICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgIGlmIChlcnIpXG4gICAgICBzZWxmLmVtaXQoJ2Vycm9yJywgZXJyKVxuICAgIHNlbGYuZW1pdCgnY2xvc2UnKVxuICB9KVxufVxuXG4vLyBhIG5vb3AgX3RyYW5zZm9ybSBmdW5jdGlvblxuZnVuY3Rpb24gbm9vcCAoY2h1bmssIGVuYywgY2FsbGJhY2spIHtcbiAgY2FsbGJhY2sobnVsbCwgY2h1bmspXG59XG5cblxuLy8gY3JlYXRlIGEgbmV3IGV4cG9ydCBmdW5jdGlvbiwgdXNlZCBieSBib3RoIHRoZSBtYWluIGV4cG9ydCBhbmRcbi8vIHRoZSAuY3RvciBleHBvcnQsIGNvbnRhaW5zIGNvbW1vbiBsb2dpYyBmb3IgZGVhbGluZyB3aXRoIGFyZ3VtZW50c1xuZnVuY3Rpb24gdGhyb3VnaDIgKGNvbnN0cnVjdCkge1xuICByZXR1cm4gZnVuY3Rpb24gKG9wdGlvbnMsIHRyYW5zZm9ybSwgZmx1c2gpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZmx1c2ggICAgID0gdHJhbnNmb3JtXG4gICAgICB0cmFuc2Zvcm0gPSBvcHRpb25zXG4gICAgICBvcHRpb25zICAgPSB7fVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdHJhbnNmb3JtICE9ICdmdW5jdGlvbicpXG4gICAgICB0cmFuc2Zvcm0gPSBub29wXG5cbiAgICBpZiAodHlwZW9mIGZsdXNoICE9ICdmdW5jdGlvbicpXG4gICAgICBmbHVzaCA9IG51bGxcblxuICAgIHJldHVybiBjb25zdHJ1Y3Qob3B0aW9ucywgdHJhbnNmb3JtLCBmbHVzaClcbiAgfVxufVxuXG5cbi8vIG1haW4gZXhwb3J0LCBqdXN0IG1ha2UgbWUgYSB0cmFuc2Zvcm0gc3RyZWFtIVxubW9kdWxlLmV4cG9ydHMgPSB0aHJvdWdoMihmdW5jdGlvbiAob3B0aW9ucywgdHJhbnNmb3JtLCBmbHVzaCkge1xuICB2YXIgdDIgPSBuZXcgRGVzdHJveWFibGVUcmFuc2Zvcm0ob3B0aW9ucylcblxuICB0Mi5fdHJhbnNmb3JtID0gdHJhbnNmb3JtXG5cbiAgaWYgKGZsdXNoKVxuICAgIHQyLl9mbHVzaCA9IGZsdXNoXG5cbiAgcmV0dXJuIHQyXG59KVxuXG5cbi8vIG1ha2UgbWUgYSByZXVzYWJsZSBwcm90b3R5cGUgdGhhdCBJIGNhbiBgbmV3YCwgb3IgaW1wbGljaXRseSBgbmV3YFxuLy8gd2l0aCBhIGNvbnN0cnVjdG9yIGNhbGxcbm1vZHVsZS5leHBvcnRzLmN0b3IgPSB0aHJvdWdoMihmdW5jdGlvbiAob3B0aW9ucywgdHJhbnNmb3JtLCBmbHVzaCkge1xuICBmdW5jdGlvbiBUaHJvdWdoMiAob3ZlcnJpZGUpIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgVGhyb3VnaDIpKVxuICAgICAgcmV0dXJuIG5ldyBUaHJvdWdoMihvdmVycmlkZSlcblxuICAgIHRoaXMub3B0aW9ucyA9IHh0ZW5kKG9wdGlvbnMsIG92ZXJyaWRlKVxuXG4gICAgRGVzdHJveWFibGVUcmFuc2Zvcm0uY2FsbCh0aGlzLCB0aGlzLm9wdGlvbnMpXG4gIH1cblxuICBpbmhlcml0cyhUaHJvdWdoMiwgRGVzdHJveWFibGVUcmFuc2Zvcm0pXG5cbiAgVGhyb3VnaDIucHJvdG90eXBlLl90cmFuc2Zvcm0gPSB0cmFuc2Zvcm1cblxuICBpZiAoZmx1c2gpXG4gICAgVGhyb3VnaDIucHJvdG90eXBlLl9mbHVzaCA9IGZsdXNoXG5cbiAgcmV0dXJuIFRocm91Z2gyXG59KVxuXG5cbm1vZHVsZS5leHBvcnRzLm9iaiA9IHRocm91Z2gyKGZ1bmN0aW9uIChvcHRpb25zLCB0cmFuc2Zvcm0sIGZsdXNoKSB7XG4gIHZhciB0MiA9IG5ldyBEZXN0cm95YWJsZVRyYW5zZm9ybSh4dGVuZCh7IG9iamVjdE1vZGU6IHRydWUsIGhpZ2hXYXRlck1hcms6IDE2IH0sIG9wdGlvbnMpKVxuXG4gIHQyLl90cmFuc2Zvcm0gPSB0cmFuc2Zvcm1cblxuICBpZiAoZmx1c2gpXG4gICAgdDIuX2ZsdXNoID0gZmx1c2hcblxuICByZXR1cm4gdDJcbn0pXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/through2/through2.js\n");

/***/ }),

/***/ "?44e1":
/*!**********************!*\
  !*** util (ignored) ***!
  \**********************/
/***/ (function() {

/* (ignored) */

/***/ }),

/***/ "?6818":
/*!**********************!*\
  !*** util (ignored) ***!
  \**********************/
/***/ (function() {

/* (ignored) */

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js ***!
  \****************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ _objectWithoutProperties; }\n/* harmony export */ });\n/* harmony import */ var _objectWithoutPropertiesLoose_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./objectWithoutPropertiesLoose.js */ \"./node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js\");\n\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n  var target = (0,_objectWithoutPropertiesLoose_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(source, excluded);\n  var key, i;\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n  return target;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vb2JqZWN0V2l0aG91dFByb3BlcnRpZXMuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBNkU7QUFDOUQ7QUFDZjtBQUNBLGVBQWUsNEVBQTRCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw2QkFBNkI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vb2JqZWN0V2l0aG91dFByb3BlcnRpZXMuanM/ODhjNSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZSBmcm9tIFwiLi9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlLmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoc291cmNlLCBleGNsdWRlZCkge1xuICBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTtcbiAgdmFyIHRhcmdldCA9IG9iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCk7XG4gIHZhciBrZXksIGk7XG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgdmFyIHNvdXJjZVN5bWJvbEtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSk7XG4gICAgZm9yIChpID0gMDsgaSA8IHNvdXJjZVN5bWJvbEtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGtleSA9IHNvdXJjZVN5bWJvbEtleXNbaV07XG4gICAgICBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlO1xuICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoc291cmNlLCBrZXkpKSBjb250aW51ZTtcbiAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgfVxuICB9XG4gIHJldHVybiB0YXJnZXQ7XG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\n");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js ***!
  \*********************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ _objectWithoutPropertiesLoose; }\n/* harmony export */ });\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n  return target;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZS5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsdUJBQXVCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZS5qcz9jNzk0Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpIHtcbiAgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307XG4gIHZhciB0YXJnZXQgPSB7fTtcbiAgdmFyIHNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuICB2YXIga2V5LCBpO1xuICBmb3IgKGkgPSAwOyBpIDwgc291cmNlS2V5cy5sZW5ndGg7IGkrKykge1xuICAgIGtleSA9IHNvdXJjZUtleXNbaV07XG4gICAgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTtcbiAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICB9XG4gIHJldHVybiB0YXJnZXQ7XG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js\n");

/***/ })

}]);